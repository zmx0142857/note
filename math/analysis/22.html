<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>场论初步</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<h2>曲线/曲面积分</h2>

<table>
  <tr>
    <td>第一类曲线积分</td>
    <td>`int_L f(x,y,z) "d"s`</td>
    <td>第二类曲线积分</td>
    <td>`int_L bm F(x,y,z) * "d"bm r`</td>
  </tr>
  <tr>
    <td>第一类曲面积分</td>
    <td>`int_Sigma f(x,y,z) "d"sigma`</td>
    <td>第二类曲面积分</td>
    <td>`int_Sigma bm F(x,y,z) * "d"bm S`</td>
  </tr>
</table>

<p>形式上有</p>

<table>
  <tr>
    <td>曲线切向微元</td>
    <td>`"d"bm r = (dx, dy, dz)`</td>
    <td>曲线弧长微元</td>
    <td>`"d"s = |"d"bm r|`</td>
  </tr>
  <tr>
    <td>曲面法向微元</td>
    <td>`"d"bm S = (dy dz, dz dx, dx dy)`</td>
    <td>曲面面积微元</td>
    <td>`"d"sigma = |"d"bm S|`</td>
  </tr>
</table>

<p>
  实际计算时, 为曲线 `L` (曲面 `Sigma`) 选取合适的参数, 就有
  <span class="formula">
    `"d"bm r = bm v dt`, `quad "d"s = |bm v| dt`;<br/>
    `"d"bm S = bm n "d"u"d"v`, `quad "d"sigma = |bm n|"d"u"d"v`.
  </span>
  其中
  <span class="formula">
    切向量 `bm v = ("d"bm r)/dt` `= (dx/dt, dy/dt, dz/dt)`, `quad`
    法向量 `bm n = bm r_u xx bm r_v` `= |bm i, bm j, bm k; x_u, y_u, z_u; x_v, y_v, z_v|`
  </span>
  依赖于参数选取.
</p>

<ol class="remark">
  <li>
  把曲面的单位法向量记为 `(cos alpha, cos beta, cos gamma)`, 则
  <span class="formula">
    `"d"bm S = (cos alpha, cos beta, cos gamma) "d"sigma`.
  </span>
  </li>
  <li>对于平面曲线, 其法向微元定义为 `"d"bm n = (dy, -dx)`,
    从而 `("d"bm r, "d"bm n)` 成左手系, 即 `|dx, dy; dy, -dx|
    = -"d"s^2 lt 0`.
  </li>
</ol>

<p class="example">
  求 `int_L x y "d"s`, 其中 `L: {x+y+z = 0; x^2+y^2+z^2=1:}`
</p>

<p class="solution">
  利用积分区域的对称性,
  <span class="formula">
    `int_L x y "d"s`
    `= 1/3 int_L (x y+y z+z x) "d"s`
    `= 1/6 int_L [(x+y+z)^2 - (x^2+y^2+z^2)] "d"s`
    `= -1/6 int_L "d"s`
    `= -pi/3`.
  </span>
</p>

<h2>微分算子</h2>

<h3>Nabla 算子</h3>

<span class="formula">
  `grad := (del/(del x_1), cdots, del/(del x_m))`
</span>

<p class="definition">
  标量场 (数量场) `f` 具有梯度 `"grad" f = grad f`.
  梯度是矢量, 其与坐标选取无关.
  梯度是导数的推广, 它简单地将求导运算推广到各分量,
  其加减乘除及函数复合的运算和导数完全一致.
</p>

<p>方向导数定义为函数值沿某个方向的变化率:
  <span class="formula">
    `("d"f)/("d"bm n) = lim_(t to 0) (f(bm x_0 + t bm n) - f(bm x_0))//t`
  </span>
  可以证明 `("d"f)/("d"bm n) = bm n * grad f`,
  因此梯度方向是该点处方向导数取得最大的方向, 大小等于这个最大的方向导数.
</p>

<table>
  <tr>
    <td>`grad c = 0`</td>
    <td>`grad (cf) = c grad f`</td>
  </tr>
  <tr>
    <td>`grad (f +- g) = grad f +- grad g`</td>
    <td>`grad (fg) = g grad f + f grad g`</td>
  </tr>
  <tr>
    <td>`grad (f//g) = (g grad f - f grad g) // g^2`</td>
    <td>`grad f(g) = ("d"f)/("d"g) grad g`</td>
  </tr>
  <tr>
    <td>`grad f(g_1, cdots, g_n) = sum (del f)/(del g_i) grad g_i`</td>
  </tr>
</table>

<p class="definition">
  矢量场 (向量场) `bm F` 具有散度
  <span class="formula">
    `"div" bm F = grad * bm F`
    `= (del F_1)/(del x_1) + cdots + (del F_n)/(del x_n)`.
  </span>
  和旋度 (三维空间):
  <span class="formula">
    `"rot" bm F = grad xx bm F`
    `= |bm i, bm j, bm k; del/(del x), del/(del y), del/(del z); F_1, F_2, F_3|`.
  </span>
  散度是标量而旋度是矢量.
</p>

<p>
  散度定义为封闭曲面包围区域趋于无穷小时, 单位体积的通量之极限,
  规定向外为正方向:
  <span class="formula">
    `"div" bm F = lim_("diam"V to 0) (iint_(del V) bm F * "d"bm S)/V`.
  </span>
  散度的符号指出矢量场在一点处有正源/负源, 散度的大小指出源的强度.
</p>

<p>
  方向旋量定义为给定法向量的平面上单位面积的环量之极限,
  规定右手螺旋为正方向:
  <span class="formula">
    `"rot"_(bm v) bm F = lim_("diam"S to 0) (int_(del S) bm F * "d"bm r)/S`.
  </span>
  `bm F` 与切向 `"d"bm r` 方向越近似, 环量就越是取正值.
  因此环量反映了矢量场沿曲线是否有旋涡, 以及旋涡的强度.
  方向旋量反映了矢量场在一点处沿给定方向的旋转情况, 显然只要 `bm v`
  取反方向, 方向旋量的符号就取反.
  由 Stokes 公式可以证明 `"rot"_(bm v) bm F = bm v * "rot" bm F`.
  旋度的方向是该点处方向旋量取得最大的方向, 大小等于这个最大的方向旋量.
</p>

<table>
  <tr>
    <td>`grad * bm c = 0`</td>
    <td>`grad xx bm c = bm 0`</td>
  </tr>
  <tr>
    <td>`grad * (c bm F) = c (grad * bm F)`</td>
    <td>`grad xx (c bm F) = c (grad xx bm F)`</td>
  </tr>
  <tr>
    <td>`grad * (bm F +- bm G) = grad * bm F +- grad * bm G`</td>
    <td>`grad xx (bm F +- bm G) = grad xx bm F +- grad xx bm G`</td>
  </tr>
  <tr>
    <td>`grad * (f bm F) = grad f * bm F + f (grad * bm F)`</td>
    <td>`grad xx (f bm F) = grad f xx bm F + f(grad xx bm F)`</td>
  </tr>
</table>

<p class="proposition">
  设 `f`, `bm F` 二阶连续可微, 因此二阶混合偏导相等.
  梯度场的散度是 laplace 算子 (见下节);
  梯度场的旋度为零向量, 旋度场的散度为 0.
  <span class="formula">
    `grad * (grad f) = (grad * grad) f := grad^2 f`,<br>
    `grad xx (grad f) = bm 0`,
    `quad grad * (grad xx bm F) = 0`.
  </tr>
</p>

<p class="definition">
  <b>`bm A * grad` 算子</b>可以用于标量或矢量. 输入标量, 输出标量; 输入矢量, 输出矢量:
  <span class="formula">
    `(bm A * grad) f`
    `= A_1 (del f)/(del x_1) + cdots + A_n (del f)/(del x_n)`,<br>
    `(bm A * grad) bm F`
    `= ((bm A * grad) F_1, cdots, (bm A * grad) F_n)`.
  </span>
</p>

<p class="remark">
  注意 `bm A * grad` 是一个算子, 而 `grad * bm A` 是一个标量. 比如在三维情形:
  <span class="formula">
    `bm A * grad = A_1 del/(del x) + A_2 del/(del y) + A_3 del/(del z)`,<br>
    `grad * bm A = pp A_1 x + pp A_2 y + pp A_3 z`.
  </span>
</p>

<p><b>`D` 算子</b>作用于矢量, 得到它的导矩阵:
  <span class="formula">
    `D bm F`
    `= [grad F_1; vdots; grad F_n]`
    `= [
      (del F_1)/(del x_1), cdots, (del F_1)/(del x_n);
      vdots, , vdots;
      (del F_n)/(del x_1), cdots, (del F_n)/(del x_n);
    ]`
  </span>
  作用于标量时, 就是 `D f = grad f`.
</p>

<ol class="proposition">
  <b>nabla 算子的综合公式</b>
  以下公式都涉及旋度, 因此只限于三维空间:
  <li>`grad(bm F * bm G)` `= bm F D bm G + bm G D bm F`
    `= bm F xx (grad xx bm G) + bm G xx (grad xx bm F) + (bm F * grad) bm G + (bm G * grad) bm F`;
  </li>
  <li>`grad * (bm F xx bm G) = bm G * grad xx bm F + bm F * grad xx bm G`;</li>
  <li>`grad xx (bm F xx bm G) = (grad * bm G) bm F - (grad * bm F) bm G + (bm G * grad) bm F - (bm F * grad) bm G`;</li>
  <li>`grad xx (grad xx bm F) = grad(grad * bm F) - (grad * grad)bm F`</li>
</ol>

<p class="proof">
  直接计算验证. 注意到各个分量的地位对称, 因此只验证 `x` 分量相等即可.
  以 1. 的证明为例, 左边的 `x` 分量等于
  <span class="formula">
    `F_1 (del G_1)/(del x) + F_2 (del G_2)/(del x) + F_3 (del G_3)/(del x)`
    `+ ** + ** + **`.
  </span>
  右边的 `x` 分量等于
  <span class="formula">
    `|F_2, F_3; (del G_1)/(del z) - (del G_3)/(del x), (del G_2)/(del x) - (del G_1)/(del y)|`
    `+ (F_1 del/(del x) + F_2 del/(del y) + F_3 del/(del z)) G_1`
    `+ | ** |`
    `+ **`.
  </span>
  其中 `**` 号省略的部分, 只需将字母 `F, G` 对换就可得到. 因此两式相等.
</p>

<h3>Laplace 算子</h3>

<span class="formula">
    `laplace := grad^2 = grad * grad = sum del^2/(del x_i^2)`
</span>

<table>
	<tr>
		<td>`laplace c = 0`</td>
	</tr>
	<tr>
		<td>`laplace (cf) = c laplace f`</td>
	</tr>
	<tr>
		<td>`laplace (f +- g) = laplace f +- laplace g`</td>
	</tr>
	<tr>
		<td>`laplace (fg) = f laplace g + g laplace f + 2 grad f * grad g`</td>
	</tr>
	<tr>
		<td>`laplace f(g) = grad ("d"f)/("d"g) * grad g + ("d"f)/("d"g) laplace g`</td>
	</tr>
	<tr>
		<td>`laplace f(g_1, cdots, g_n) = sum grad (del f)/(del g_i) * grad
		g_i + sum (del f)/(del g_i) laplace g_i`</td>
	</tr>
</table>

<p class="proof">
  如 `laplace(f g) = grad^2(f g)`
  `= grad * (f grad g + g grad f)`
  `= f grad^2 g + g grad^2 f + 2 grad f * grad g`.
</p>

<p>满足 `laplace f -= 0` 的函数称为<b>调和函数</b>.</p>

<h3>径向函数</h3>

<p>	设 `bm r = (x_1, cdots, x_m)`, `r = |bm r|`, 则
	<span class="formula">
		`grad r = (bm r)/r`, `quad |grad r| = 1`,
        `quad grad * bm r = m`, `quad laplace r = (m-1)/r`;<br/>
		`grad f(r) = ("d"f)/("d"r) grad r`,
		`quad laplace f(r) = ("d"^2 f)/("d"r^2) + (m-1)/r ("d"f)/("d"r)`;<br/>
	</span>
</p>

<p class="proof">
    `laplace r = grad * grad r`
    `= grad * (bm r)/r`
    `= 1/r grad * bm r + bm r * grad 1/r`
    `= m/r - 1/r^2 bm r * grad r`
    `= m/r - 1/r^3 bm r * bm r`
    `= (m-1)/r`.<br/>
    `laplace f(r) = grad * grad f(r)`
    `= grad ("d"f)/("d"r) * grad r + ("d"f)/("d"r) laplace r`
    `= ("d"^2 f)/("d"r^2) grad r * grad r + ("d"f)/("d"r) laplace r`
    `= ("d"^2 f)/("d"r^2) + (m-1)/r ("d"f)/("d"r)`.
</p>

<p> 特别当 `m = 3`, 在三维空间中有
    <span class="formula">
		`r laplace f = "d"^2/("d"r^2) (rf)`,
    </span>
    因此, `1//r` 是三维空间中的调和函数; 类似可证 `ln r`
    是二维空间的调和函数. 一般地, 微分方程
    <span class="formula">
        `f'' + (m-1)/r f' = 0`
    </span>
    的通解 `{ c_1 x^(2-m) + c_2, if m != 2;
    c_1 ln x + c_2, if m = 2:}` 给出 `m` 维空间的调和径向函数.
</p>

<h2>多元积分公式</h2>

<p>在二维空间中, 约定 `"d"V = dx dy`, 三维空间中则 `"d"V = dx dy dz`.</p>

<h3>Green, Gauss, Stokes</h3>

<p>	Leibniz:
	<span class="formula">
		`"d"/dt int_(alpha(t))^(beta(t)) f(x, t) dx`
		`= int_(alpha(t))^(beta(t)) del/(del t) f(x, t) dx`
		`+ f(beta(t), t) beta'(t)`
		`- f(alpha(t), t) alpha'(t).`
	</span>
	Green (记忆: `del y` 者符号相反):
	<span class="formula">
		`iint_V |del/(del x), del/(del y); P, Q| "d"V
		= oint_(del V) P dx + Q dy`
	</span>
	Gauss:
	<span class="formula">
		`iiint_V grad * bm F "d"V`
		`= oiint_(del V) bm F * "d" bm S`
	</span>
	Stokes:
	<span class="formula">
		`iint_Sigma grad xx bm F * "d" bm S
        = oint_(del Sigma) bm F * "d" bm r`,
	</span>
</p>

<p class="remark">
    用混合积的定义, Stokes 公式可以写为
    <span class="formula">
		`iint_S |
			del/(del x), del/(del y), del/(del z);
			P, Q, R;
			dy dz, dz dx, dx dy;
		|
		= oint_(del S) P dx + Q dy + R dz`,
    </span>
    取 `dz = 0` 就得到 Green 公式.
</p>

<p class="example">
  [来自 群Scalar] 求 `(t - t^3, 1 - t^4)`, `t in [-1, 1]` 围成图形的面积.
</p>

<p class="solution">
  由 Green 公式 (注意 `t` 从 `-1` 到 `1` 曲线为顺时针)
  <span class="formula">
    `iint_V dx dy`
    `= 1/2 oint_(del V) x dy - y dx`
    `= 1/2 int_1^(-1) [(t - t^3)(-4 t^3) - (1-t^4)(1-3t^2)] dt`
    `= 16/35`.
  </span>
</p>

<h3>Green 三大公式</h3>

<p> 回忆方向导数的定义: `(del f)/(del bm n) = grad f * bm n`,
    在 Gauss 公式中取 `bm F = grad f`, 则
    <span class="formula">
        `bm F * "d"bm S`
        `= grad f * bm n |"d"bm S|`
        `= (del f)/(del bm n) "d"sigma`,
    </span>
    得到有用的方向导数形式:
    <span class="formula">
		`iiint_V Delta f "d"V
		= oiint_(del V) (del f)/(del bm n) "d" sigma`,
		`quad bm n` 是单位外法向量.
    </span>
    在 Green 公式中取 `(Q, -P) = grad f`, 也得到方向导数形式:
    <span class="formula">
		`iint_V Delta f "d"V = oint_(del V) (del f)/(del bm n) "d"s`,
        `quad bm n` 是单位外法向量 `(dy/("d"s), -dx/("d"s))`.
    </span>
    这个公式实际是下面 Green 第一公式的特殊情形.
</p>

<ol class="theorem">
    <b>Green 第一公式</b>
    类比于分部积分公式将导数从一个因子转移到另一个因子上,
    此公式将 nabla 算子从 `g` 转移到 `f` 上:
    <li>(2d) `iint_V grad f * grad g "d"V
		= int_(del V) g{::} (del f)/(del bm n) "d"s
        - iint_V g laplace f "d"V`;
    </li>
    <li>(3d) `iiint_V grad f * grad g "d"V
		= iint_(del V) g{::} (del f)/(del bm n) "d"sigma
        - iiint_V g laplace f "d"V`.
    </li>
</ol>

<p class="proof">
    只证 2d 情形 (3d 情形其实更简单).
    利用方向导数的定义和 `bm n = (dy/("d"s), -dx/("d"s))`,
    <span class="formula">
        `int_(del V) g{::} (del f)/(del bm n) "d"s`
        `= int_(del V) g grad f * bm n "d"s`
        `= int_(del V) g ((del f)/(del x) dy - (del f)/(del y) dx)`
        `= iint_V [del/(del x)(g{::}(del f)/(del x))
        + del/(del y)(g{::}(del f)/(del y))] "d"V`
        `= iint_V grad f * grad g "d"V + iint_V g laplace f "d"V`.
    </span>
</p>

<ol class="theorem">
    <b>Green 第二公式</b>
    <li>(2d) `iint_V |laplace f, laplace g; f, g| "d"V
        = int_(del V) |(del f)/(del bm n), (del g)/(del bm n);
        f, g| "d"s`;
    </li>
    <li>(3d) `iiint_V |laplace f, laplace g; f, g| "d"V
        = iint_(del V) |(del f)/(del bm n), (del g)/(del bm n);
        f, g| "d"sigma`.
    </li>
</ol>

<p class="proof">
    分别对函数 `f, g` 应用 Green 第一公式即可.
    `grad f * grad g` 的积分刚好抵消.
</p>

<ol class="theorem">
    <b>Green 第三公式</b>
    设 `u` 为调和函数, `r` 是点 `(x,y)` 或 `(x,y,z)` 到 `del V`
    上积分变动点的距离.
    <li>(2d) `u(x,y) = 1/(2pi) int_(del V) (u (del ln r)/(del bm n)
        - ln r (del u)/(del bm n)) "d"s`;
    </li>
    <li>(3d) `u(x,y,z) = 1/(4pi) iint_(del V) (1/r (del u)/(del bm n)
        - u (del(1//r))/(del bm n)) "d"sigma`.
    </li>
</ol>

<p class="proof">
    只证 2d 情形.
    取 `C` 是以 `(x,y)` 为心, `rho` 为半径的圆周.
    对函数 `u` 和 `ln r`, 在 `C` 和 `del V` 所夹的区域上应用 Green
    第二公式, 注意 `ln r` 是二维空间的调和函数, 有
    <span class="formula">
        `int_(del V) - int_C = 0`,
    </span>
    其中被积函数是 `|(del ln r)/(del bm n), (del u)/(del bm n);
    ln r, u|`.
    于是
    <span class="formula">
        `int_(del V)`
        `= int_C (u (del ln r)/(del bm n) - ln r (del u)/(del bm n)) "d"s`
        `= int_C (u (del ln r)/(del r) - ln rho (del u)/(del bm n)) "d"s`
        `= 1/rho int_C u "d"s`.
    </span>
    令 `rho to 0`, 则 `u` 在 `C` 上的平均值
    `1/(2pi rho) int_C u "d"s` 趋于 `u(x,y)`,
    从而 `u(x,y) = 1/(2pi) int_(del V)`.
</p>

<p class="example">
	<b>Dirichlet 原理</b> 在区域边界上取给定值的连续可微函数,
	其 Dirichlet 积分 (函数的梯度的模的平方在区域上的积分)
	取最小值当且仅当该函数为调和函数.
</p>

<p class="proof">
	设 `laplace f = 0`, 且 `f|{::}_(del V) = g|_(del V)`.
	在 Green 第一公式中令 `g = f`, 利用边界条件得
	<span class="formula">
		`iint_V |grad f|^2 "d"V`
		`= int_(del V) f{::} (del f)/(del bm n) "d"s`
		`= int_(del V) g{::} (del f)/(del bm n) "d"s`
		`= iint_V grad f * grad g "d"V`.
	</span>
	从而
	<span class="formula">
		`iint_V |grad g|^2 "d"V - iint_V |grad f|^2 "d"V`
		`= iint_V |grad g|^2 "d"V + iint_V |grad f|^2 "d"V
        - 2 iint_V grad f * grad g "d"V`
		`= iint_V |grad g - grad f|^2 "d"V ge 0`.
	</span>
</p>

<h2>微分形式与外微分运算</h2>

[来自 <a href="https://zhuanlan.zhihu.com/p/392443514">茶凉凉凉凉</a>]

<ol class="definition">
  <b>外积</b>
  观察多元积分换元公式
  <span class="formula">
    `"d"u"d"v = (del(u, v))/(del(x, y)) dx dy`,
  </span>
  如果将 `x, y` 的次序对调, 得到
  <span class="formula">
    `dy dx = (del(y, x))/(del(x, y)) dx dy`
    `= |y_x, y_y; x_x, x_y| dx dy`
    `= |0, 1; 1, 0| dx dy`
    `= -dx dy`.
  </span>
  这个性质类似于向量的外积, 我们也把它称为外积, 写作 `dx ^^ dy`.
  外积运算满足
  <li>线性性. `(P dx + Q dy) ^^ "d"u = P dx ^^ "d"u + Q dy ^^ "d"u`;</li>
  <li>反对称性. `dx ^^ dy = - dy ^^ dx`.</li>
  由反对称性立即得到 `dx ^^ dx = 0`.<br>
  一般地, 在 `n` 维空间中, 规定每交换一对变量, 外积就改变一次符号:
  <span class="formula align">
    `dx_1 ^^ cdots ^^ color(red)(dx_i) ^^ cdots ^^ color(blue)(dx_j) ^^ cdots ^^ dx_n`<br>
    `= -dx_1 ^^ cdots ^^ color(blue)(dx_j) ^^ cdots ^^ color(red)(dx_i) ^^ cdots ^^ dx_n`.
  </span>
</ol>

<ol class="definition">
  <li><b>零阶微分形式</b> 就是普通的多元函数 `f`.</li>
  <li><b>一阶微分形式</b> 是 `dx, dy, dz` 以及它们的线性组合 (系数是普通函数, 如 `P dx + Q dy`).</li>
  <li><b>二阶微分形式</b> 是 `dx ^^ dy`, `dy ^^ dz`, `dz ^^ dx`
  以及它们的线性组合.</li>
  <li><b>三阶微分形式</b> 是 `dx ^^ dy ^^ dz` 以及它的线性组合 (其实在三维空间中只有一种组合).</li>
  由 `dx ^^ dx = 0` 知道, 在 `n` 维空间中, 最高只有 `n` 阶微分形式.
</ol>

<ol class="definition">
  设 `omega` 是微分形式, 定义<b>外微分</b>运算 `"d"omega` 如下:
  <li>零阶微分形式 `f` 的外微分定义为它的全微分:
    <span class="formula">
      `"d"f = grad f * "d"bm r`
      `= sum (del f)/(del x_i) dx_i`.
    </span>
  </li>
  <li>若 `omega` 形如 `omega = dx_1 cdots dx_n`, 则单项式 `f omega`
    的外微分定义为
    <span class="formula">
      `"d"(f omega) = "d"f ^^ omega`.
    </span>
    利用外积运算的线性性, 可将 `"d"f` 展开各项与 `"d"omega` 相乘,
    再合并同类项.
  </li>
  <li>最后, 规定外微分具有线性性
    <span class="formula">
      `"d"(omega_1 + omega_2) = "d"omega_1 + "d"omega_2`,
    </span>
    欲求整个微分形式的外微分, 只需将各个单项式的外微分相加.
  </li>
</ol>

<ol class="corollary">
  <li>零阶微分形式 (普通函数) 求两次外微分结果为零: `"d"^2 f = 0`.</li>
</ol>

<ol class="proof">
  <li>
    <span class="formula">
      `"d"^2 f`
      `= "d"(sum_i pp f x_i "d"x_i)`
      `= sum_i "d"(pp f x_i) ^^ "d"x_i`
      `= sum_i sum_j pp^2 f (x_i x_j) "d"x_j ^^ "d"x_i`,
    </span>
    从而 `"d"^2 f` 展开为 `("d"x_1, cdots, "d"x_n)` 的二次型,
    其系数矩阵反对称, 因此结果为零.
  </li>
</ol>

<ol class="example">
  <b>外微分下的三大公式</b>
  <li>Green: `"d"(P dx + Q dy)`
    `= ((del Q)/(del x) - (del P)/(del y)) dx ^^ dy`.
  </li>
  <li>Stokes: `"d"(P dx+Q dy+R dz)`
    `= ((del R)/(del y)-(del Q)/(del z)) dy ^^ dz`
    `+ ((del P)/(del z)-(del R)/(del x)) dz ^^ dx`
    `+ ((del Q)/(del x)-(del P)/(del y)) dx ^^ dy`.
  </li>
  <li>Gauss: `"d"(P dy^^dz + Q dz^^dx + R dx^^dy)`
    `= ((del P)/(del x) +(del Q)/(del y) + (del R)/(del z)) dx ^^ dy ^^ dz`.</li>
  至此三大公式, 包括 Newton-Leibniz 公式都统一写成:
  <span class="formula">
    `int_(del D) omega = int_D "d" omega`.
  </span>
</ol>

<ol class="proof">
  <li>左边等于
    <span class="formula">
      `"d"P ^^ dx + "d"Q ^^ dy`
      `= ((del P)/(del x) dx + (del P)/(del y) dy) ^^ dx`
      `+ ((del Q)/(del x) dx + (del Q)/(del y) dy) ^^ dy`
    </span>
    等于右边.
  </li>
  <li>和 Green 公式完全类似.</li>
  <li>第一项
    <span class="formula">
      `"d"P ^^ dy ^^ dz`
      `= ((del P)/(del x)dx+(del P)/(del y)dy+(del P)/(del z)dz) ^^ dy ^^
      dz`
      `= (del P)/(del x) dx ^^ dy ^^ dz`.
    </span>
    其余两项是类似的 (注意 `dx ^^ dy ^^ dz = dy ^^ dz ^^ dx = dz ^^ dx ^^
    dy`).
  </li>
</ol>

<h2>张量记号</h2>

<ol>
  <b>张量 (tensor)</b> 是向量、矩阵的自然推广, 向量是一维张量,
  矩阵是二维张量.
  <li>用 `X, Y, Z` 等表示张量, `X^mu` 或 `X_mu` 表示它的第 `mu`
    分量. 张量的上标称为<b>逆变指标</b>, 下标称为<b>协变指标</b>.
  </li>
  <li>指标的缩并: `x^mu y_mu = x_mu y^mu = sum_mu x_mu y^mu`;
    缩并的指标 `mu` 可以随意地换成其它未在表达式中出现的字母,
    它们称为<b>哑指标</b>.
  </li>
  <li>指标的升降:
    空间中的度规 (或第一基本形式) 可以写作 `g_(mu nu)` 或 `g^(mu nu)`;
    我们有 `X_mu = g_(mu nu) X^nu`, `Y^mu = g^(mu nu) Y_nu`.
  </li>
  <li>对称性:
    关于两个指标对称: `X^(mu nu) = X^(nu mu)`.
    关于两个指标反对称: `X^(mu nu) = -X^(nu mu)`.
    关于多个指标对称, 是指随意交换任意两个指标而结果相等;
    关于多个指标反对称是指随意交换任意两个指标而结果相差一个负号.
  </li>
  <li>对称指标与反对称指标缩并, 结果为零, 例如
    <span class="formula">
      `X^(mu nu) Y_(mu nu lambda)`
      `= -X^(nu mu) Y_(nu mu lambda)`
      `= -X^(mu nu) Y_(mu nu lambda)`.
    </span>
  </li>
</ol>

<script src="../../js/note.js?type=math"></script>
</body>
</html>
