<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>基数</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<!--
<p class="theorem" id="the-isb-map-exist">
	<b>鸽巢原理</b>
	设 `X, Y != O/` 为有限集,
	则存在 `X to Y` 的单射的充要条件是 `|X| le |Y|`,
	存在 `X to Y` 的满射的充要条件是 `|X| ge |Y|`;
	因此, 存在 `X to Y` 的双射的充要条件是 `|X| = |Y|`.
</p>

<p class="proof">
	我们只证明单射的情形, 满射的证明类似.
	设 `X = {x_1, x_2, cdots, x_m}`, `Y = {y_1, y_2, cdots, y_n}`,
	则 `|X| = m`, `|Y| = n`.
	<br/>
	充分性: 当 `m le n` 时, 显然 `f(x_i) = y_i`, `i = 1, 2, cdots, m`
	是 `X` 到 `Y` 的单射.
	<br/>
	必要性: 若 `f: X to Y` 是单射, 对每个 `y_i in Y`,
	考虑原像集 `f^-1(y_i)`, 有 `|f^-1(y_i)| le 1`.
	注意到 `X` 是各 `f^-1(y_i)` 的不交并, 由加法原理,
	<span class="formula">
		` |X|
		= |uuu_(i=1)^n f^-1(y_i)|
		= sum_(i=1)^n |f^-1(y_i)|
		le n`.
	</span>
</p>

<p class="theorem">
	设 `X, Y != O/` 为有限集, 且 `|X| = |Y|`. 若 `f: X to Y`, 则
	`f` 是单射当且仅当 `f` 是满射, 从而当且仅当 `f` 是双射.
</p>

<ol class="proof">
	<li>设 `f` 不是满射,
		由定义, 存在 `y in Y`, 对任意 `x in X`, `f(x) != y`.
		所以 `f` 也是从 `X` 到 `Y\\{y}` 的映射.
		但 `|Y\\{y}| lt |Y| = |X|`, 所以由<a class="ref"
			href="#the-isb-map-exist"></a>, `f` 不是单射.
	</li>
	<li>设 `f` 不是单射, 则存在 `x_1, x_2 in X`, `x_1 != x_2`,
		`f(x_1) = f(x_2)`.
		所以 `f` 限制在 `X\\{x_1}` 上是 `X\\{x_1}` 到 `Y` 的映射.
		但 `|X\\{x_1}| lt |X| = |Y|`,
		所以由<a class="ref" href="#the-isb-map-exist"></a>,
		`f` 限制在 `X\\{x_1}` 上不是满射,
		即存在 `y in Y`, 对任意 `x in X\\{x_1}`, `f(x) != y`.
		因为 `x_2 in X\\{x_1}`,
		所以 `f(x_1) = f(x_2) != y`.
		因而 `f` 不是满射.
	</li>
</ol>
-->

<p>[来自周民强《实变函数论》、李文威《代数学方法》]</p>

<h2>等势</h2>

<p>	我们知道, 有限集的元素个数可以用一个非负整数 `n` 表示,
	基数就是对 "有限集的元素个数" 这个概念的扩充.
</p>

<ol class="definition">
	<li>设 `X, Y sube Omega`.  如果存在 `X` 到 `Y` 的双射, 就称集合 `X` 与 `Y`
		<b>等势</b>. 可以验证, 等势构成 `2^Omega` 上的等价关系.
        用记号 `|X|` 或者 `"card" X` 表示等势的等价类.
	</li>
	<li>若 `X` 与 `Y` 的一个子集等势, 换言之存在 `X` 到 `Y` 的单射, 则称 `|X| le |Y|`;
		若 `|X| le |Y|` 且 `|X| != |Y|`, 则称 `|X| lt |Y|`.
        关系 `le` 满足传递性.  下文将证明 `le` 的反对称性, 从而它构成偏序.
	</li>
</ol>

<p class="example">
  <b>无限旅馆</b>
  `NN` 与 `NN uu {x}` 等势.
</p>

<p class="proof">
  若 `x in NN` 则结论显然, 否则令
  <span class="formula">
    `f(y) := {
      y + 1, if y in NN;
      y, if y = x;
    :}`
  </span>
  则 `f` 是 `NN uu {x}` 到 `NN` 的双射.
</p>

<p class="remark">
  用形象的语言, `NN` 是一座有着无限房间的旅馆, 每个房间都住了人. `x` 是一个新来的客人, 为了给它腾出房间, 我们让 `n` 号房间的客人搬到 `n+1` 号住, 从而把 0 号房间空出来.
</p>

<p class="lemma">
	<b>Banach 映射分解定理*</b>
	若 `f: X to Y`, `g: Y to X`, 则存在 `A sube X`,
	`B sube Y`, 使得
	<span class="formula">
		`f(A) = B`, `quad g(overset ~ B) = overset ~ A`,
	</span>
	其中 `overset ~ A = X\\A`, `overset ~ B = Y\\B`.
</p>

<ol class="proof">
	<li>对任意 `E sube X`, 记
		<span class="formula">
			`F = f(E)`, `quad Y\\F = overset ~ F`,
			`quad g(overset ~ F) = overset ~ E`.
		</span>
		若 `E nn overset ~ E = O/`, 则称 `E` 为 `X` 中的<b>分离集</b>.
		显然, `O/` 就是 `X` 中一分离集.
	</li>
	<li>令 `A` 为 `X` 中全体分离集的并, 下证 `A` 是分离集.
		对 `X` 中任意分离集 `E`, 有 `E sube A`, 从而
		<span class="formula">
			`F := f(E) sube B := f(A)`,<br/>
			`quad overset ~ F := Y\\F supe overset ~ B := Y\\B`,<br/>
			`quad overset ~ E := g(overset ~ F) supe overset ~ A :=
			g(overset ~ B)`.
		</span>
		由 `E nn overset ~ E = O/` 知 `E nn overset ~ A = O/`,
		再由 `E` 的任意性得 `A nn overset ~ A = O/`.
	</li>
	<li>下证 `A uu overset ~ A = X`. 如若不然, 则存在 `x in X`, `x !in
		A uu overset ~ A`. 记 `E = A uu {x}`, 则 `E nn overset ~ A = O/`.
		于是
		<span class="formula">
			`B = f(A) sube F := f(E)`,<br/>
			`overset ~ B = Y\\B supe overset ~ F := Y\\F`,<br/>
			`overset ~ A = g(overset ~ B) supe overset ~ E := g(overset
			~ F)`.
		</span>
		联系 `A nn overset ~ A = O/` 有 `E nn overset ~ E = O/`,
		与 `A` 是 `X` 中最大的分离集矛盾.
	</li>
</ol>
	
<p class="theorem">
	<b>Cantor-Bernstein 定理</b>
	若 `|X| le |Y|`, `|Y| le |X|`, 则 `|X| = |Y|`.
	因此, "`le`" 构成一偏序关系.
</p>

<p class="proof">
	(Banach) 由已知存在单射 `f: X to Y` 和单射 `g: Y to X`.
	由映射分解定理, 存在 `A sube X`, `B sube Y` 使得
	`f(A) = B`, `g(Y\\B) = X\\A`. 从而下面的映射是 `X` 到 `Y` 的双射:
	<span class="formula">`F(x) = {
		f(x), if x in A;
		g^-1(x), if x in X\\A;
	:}`</span>
</p>

<div class="proof">
  考虑单射 `f: X to Y` 和 `g: Y to X`.
  显然 `|g(Y)| = |Y|`, 因此只需证 `|X| = |g(Y)|`.
  下设 `Y sube X`, 且 `g` 是包含映射 `y mapsto y`.
  令 `X_0 := X`, `Y_0 := Y`, 递归定义
  <span class="formula">
    `X_(n+1) := f(X_n)`, `quad Y_(n+1) := f(Y_n)`.
  </span>
  由于 `Y_0 sube X_0`, 我们有 `f(Y_0) sube f(X_0)`, 进而对一切 `n` 有 `Y_n sube X_n`.
  另一方面 `f(X_0) sube Y_0`, 进而对一切 `n` 有 `X_(n+1) sube Y_n`.
  于是得到一列嵌套的子集
  <span class="formula">
    `X_0 supe Y_0 supe cdots supe X_n supe Y_n supe X_(n+1) supe cdots`.
  </span>
  定义映射
  <span class="formula">
    `varphi(x) := { f(x), if EE n ge 0, x in X_n - Y_n;
    x, otherwise :}`
  </span>
  则 `varphi` 是 `X` 到 `Y` 的双射.
  <div class="img lg">
    <img src="../img/cantor-bernstein.png">
  </div>
</div>

<p class="corollary">
  若 `A sube B sube C` 且 `|A| = |C|`, 则 `|A| = |B| = |C|`.
</p>

<h2>可数集</h2>

<h3>基数的定义</h3>

<p class="definition">
  <b>基数的定义</b>
  一个序数 `kappa` 称为<b>基数</b>, 如果它满足 `lambda lt kappa rArr |lambda| lt |kappa|`.
  换言之, 基数是一个等势类中的最小序数, 是等势类中的代表元.
</p>

<p class="remark">
  记号 `|X|` 有双重含义: 一是指等势类, 二是指基数.
  如果读者尚未掌握序数的概念, 也可以把基数理解为等势类本身.
  利用良序定理, 对任意集合 `X`, 可取最小序数 `theta` 使 `|X| = theta`, 从而等势类和基数是一一对应的.
  由于全体序数构成一个良序, 所以全体基数也构成良序: 对任意集合 `|X|, |Y|` 必有
  `|X| le |Y|` 或 `|Y| le |X|`.
</p>

<p class="corollary">
  无穷序数的后继不是基数, 换言之: 无穷基数必为极限序数.
</p>

<p class="proof">
  设 `kappa` 是无穷序数.
  由 `kappa + 1 := kappa uu {kappa}` 知道 `|kappa| = |kappa + 1|`, 因此 `kappa + 1` 不是基数.
</p>

<h3>有限集与可数集</h3>

<p class="definition">
  称一个集合 `X` 为<b>有限集</b>, 如果存在自然数 `n`, 使得
  `X` 与 `n := {0, 1, 2, cdots, n-1}` 等势, 此时记 `|X| = n`.
  否则称它为<b>无限集</b>.
  有限集也记为 `|X| lt oo`, 无限集记为 `|X| &#8814; oo`.
</p>

<p class="definition">
  <b>阿列夫·零</b>
  记 `aleph_0 := |NN| = omega`.
  称 `A` 为<b>可列集</b>, 如果 `A ~ NN`, 亦即 `|A| = aleph_0`.
  可列集与有限集合称<b>可数集</b>. 如果 `|A| gt aleph_0`, 则称 `A`
  为<b>不可数集</b>.
</p>

<ol class="corollary">
  <li>
    无限集中必含一个可列子集, 从而 `aleph_0` 是最小的无限基数:
    `|E| &#8814; oo rArr |E| ge aleph_0`.
  </li>
  <li>无限集并上一可数集后, 基数不变.</li>
  <li>一集合为无限集当且仅当它与自身的某个真子集等势.</li>
</ol>

<ol class="theorem">
  <b>对角线法</b>
  <li>设 `|X| = aleph_0`, 则 `|X xx X| = aleph_0`.</li>
  <li>设 `|X_n| = aleph_0`, `n = 0, 1, 2, cdots`, 则 `uuu_(n ge 0) X_n = aleph_0`.</li>
</ol>

<ol class="proof">
  <li>
    使用对角线法:
    注意每个 `Y_n = {(x_i, x_j) in X xx X: i + j = n}` 为有限集, 而 `X xx X = uuu_(n ge 0) Y_n`,
    显然后者为可列集.
  </li>
  <li>
    只需证 `|X| le |uuu_(n ge 0) X_n| le |X xx X|`, 然后由 Cantor-Bernstein 定理即得结论.
    第一个不等号是显然的, 为证第二个不等号, 由于每个 `X_n` 是可列集, 故存在双射 `f_n: X_n to NN`,
    利用选择公理将这些存在的双射固定下来, 于是存在 `uuu_(n ge 0) X_n` 到 `NN xx NN` 的单射:
    <span class="formula">
      `x mapsto (f_n(x), n)`, `quad n` 是使得 `x in X_n` 的最小自然数.
    </span>
  </li>
</ol>

<ol class="example">
  <li>`ZZ` 是可列集;</li>
  <li>`QQ = uuu_(k=1)^oo {n/k: n in ZZ}` 是可列集;</li>
  <li>`NN xx NN = uuu_(m in NN) {(m, n): n in NN}` 是可列集;</li>
  <li>`NN^n` 是可列集 (对 `n` 归纳).</li>
</ol>

<h3>分析学中的可数集</h3>

<ol class="example">
	<li>`RR` 中互不相交的开区间族是可数集.</li>
	<li>区间 `I` 上单调函数的不连续点集为可数集.</li>
	<li>区间 `I` 上的上凸 (下凸) 函数的不可微点为可数集.</li>
</ol>

<ol class="proof">
	<li>由有理数的稠密性, 从每个开区间中可以选出一有理数,
		从而这族开区间等势于 `QQ` 的子集.
	</li>
	<li>以递增函数 `f` 为例.  由函数极限的单调有界原理知,
		单调函数在每一点的单侧极限必存在.
		因此每个 `f` 的不连续点 `x` 都对应开区间
		`(f(x-0), f(x+0))`. 又对于不同的不连续点 `x_1, x_2`,
		其对应的开区间互不相交 (不妨设 `x_1 lt x_2`, 展开极限定义, 利用
		`f` 在 `(x_1, x_2)` 上的单调性反证, 可得 `f(x_1+0) le f(x_2-0)`),
		所以 `f` 的不连续点等势于一族互不相交的开区间, 后者是可数的.
	</li>
	<li>函数 `f` 在 `x_0` 处可微当且仅当函数
		`g(x) = (f(x) - f(x_0))/(x-x_0)` 在 `x_0` 处极限存在.
		由凹凸性, `g(x)` 是单调函数. 所以由 2 即得结论.
	</li>
</ol>

<p class="example">
	<b>在无理点处连续, 有理点处间断的递增函数</b>
	任取收敛级数
	<span class="formula">
		`sum_(n=1)^oo c_n lt +oo`, `quad c_n gt 0`, `quad n = 1, 2,
		cdots`,
	</span>
	记区间 `I` 上全体有理数为 `{r_n}`, 定义 `f(x)` 为所有使得 `r_n lt
	x` 的项 `c_n` 的和:
	<span class="formula">
		`f(x) = sum_(r_n lt x) c_n`,
	</span>
	易知 `f` 递增, 且 `f(r_n + 0) - f(r_n - 0) = c_n`, `n = 1, 2, cdots`.
</p>

<h2>连续基数</h2>

<ol class="example">
	<li>构造双射 `f: (-1, 1) to RR`, 其中 `f(x) = x/(1-x^2)`
		(也可以是 `("e"^x-"e"^-x)/("e"^x + "e"^-x)`).
	</li>
	<li>构造双射 `f: [-1, 1] to (1, -1)` 如下
		<span class="formula">`f(x) = {
				1/(n+1), if x = 1/n;
				-1/(n+1), if x = -1/n;
				x, if "else";
		:}` </span>
		这一做法可以推广到高维的单位球上.
	</li>
	结合以上两例可知, 任何 `RR` 上的区间 (开, 闭, 半开闭) 都与 `RR` 等势.
</ol>

<p class="theorem">
	`RR` 是不可数集.
</p>

<p class="proof">
	只需证明闭区间 `[a, d]` 是不可数集. 反设 `[a, d] = {r_n}` 可数,
	将 `[a, d]` 分成三等份 `[a = a_0, b_0]`,
	`[b_0, c_0]`, `[c_0, d_0 = d]`,
	至少有一区间不含 `r_1`, 记这个区间为 `[a_1, d_1]`, 并将它继续三等分,
	把其中不含 `r_2` 的区间记为 `[a_2, d_2]`. 重复以上步骤,
	得到长度趋于零的闭区间套
	<span class="formula">
		`[a_0, d_0] supe [a_1, d_1] supe [a_2, d_2] supe cdots`.
	</span>
	满足
	<span class="formula">
		`{r_n} nn uuu_(n=1)^oo [a_n, d_n] = O/`.
	</span>
	与闭区间套定理矛盾.
</p>

<ol class="proof">
	<li>采用二进制小数, 则 `(0, 1]` 中的任意实数 `x` 可以表示为
		<span class="formula">
			`x = sum_(n=1)^oo a_n 2^-n`,
		</span>
		其中 `a_n in {0, 1}`, 且上式中 `a_n = 1` 的项有无穷多项 (即,
		上式不是有限小数. 注意, 任意有限小数都可以写为无限小数, 如
		1.0 = 0.111111...). 由闭区间套定理可证,
		`(0, 1]` 中的实数与其二进制小数表示之间存在双射.
	</li>
	<li>记 `{a_n}` 为 `x` 的二进制小数表示.
		记 `k_1` 是数列 `{a_n}` 中第一个数字 1 的下标,
		`k_i` 表示数列 `a_n` 中第 `i` 个数字 1 与第 `i-1` 个数字
		1 的下标之差, `i = 2, 3, cdots`, 则 `{k_i}` 是正整数列
		(每一项都是正整数的数列).
		这就建立了 `{a_n}` 到全体正整数列之间的双射.
	</li>
	<li>下证全体正整数列不可数. 反设全体正整数列可以列出如下:
		<span class="formula">
			`k_(11), k_(12), cdots, k_(1i), cdots`<br/>
			`k_(21), k_(22), cdots, k_(2i), cdots`<br/>
			`cdots`<br/>
			`k_(i1), k_(i2), cdots, k_(ii), cdots`<br/>
			`cdots`
		</span>
		但数列 `k_(11)+1, k_(22)+1, cdots, k_(i i)+1` 没有被列出,
		这是因为对 `AA i in NN`, 它都与第 `i` 行不同.
		所以全体正整数列不可数.
	</li>
</ol>

<p class="definition">
  称 `RR` 的基数为<b>连续基数</b>, 记为 `2^(aleph_0)`.
  由上讨论, `RR` 和 `RR` 中任意长度大于 0 的区间、`[0, 1]` 上全体二进制小数、全体正整数列都是等势的.
</p>

<ol class="corollary">
  <li>设 `|X| = 2^(aleph_0)`, 则 `|X xx X| = 2^(aleph_0)`.</li>
  <li>设 `|X_n| = 2^(aleph_0)`, `n = 0, 1, 2, cdots`, 则 `|uuu_(n ge 0) X_n| = 2^(aleph_0)`.</li>
</ol>

<div class="proof p">
  和可列集的情形相同, 只需证 `|X| = |X xx X|`:
  <span class="formula">
    `|X xx X|`
    `= |P(QQ nn [0, 1)) xx P(QQ nn [1, 2))|`
    `= |P(QQ nn [0, 2))|`
    `= |X|`.
  </span>
  中间的等号成立是因为, 设 `A nn B = O/`, `A_1 sube A`, `B_1 sube B`, 则
  <span class="formula">
    `f: P(A) xx P(B) to P(A uu B)`<br>
    `f(A_1, B_1) mapsto A_1 uu B_1`
  </span>
  是一个双射.
  <hr>
  事实上, 对任意无穷集都有 `|X| = |uuu_(n ge 0) X_n| = |X xx X|`,
  参看下节 "基数的性质".
</div>

<ol class="example">
  <b>Cantor 集</b>
  记 `F_0 = [0, 1]`. 将其三等分, 移去中间部分的开区间 `(1//3, 2//3)`,
  剩下的部分记为 `F_1 = [0, 1//3] uu [2//3, 1]`.
  一般地, 将 `F_n` 中每个互不相交的闭区间三等分, 并移去中间部分的开区间,
  剩下的部分记为 `F_(n+1)`.
  定义 Cantor 集为
  <span class="formula">
      `C = nnn_(n=1)^oo F_n`.
  </span>
  Cantor 集的若干性质:
  <li>拓扑性质: `C` 是非空有界闭集, `C` 没有内点, `C` 是完全集 (即 `C' = C`);</li>
  <li>`C` 中每个数可以用三进制小数唯一表示:
    <span class="formula">
      `x = sum_(n ge 1) a_n 3^-n`, `quad a_n = 0 or 2`.
    </span>
    因此 `C` 的基数是 `2^(aleph_0)`.
  </li>
</ol>

<h2>基数的性质</h2>

<h3>如何得到更大的基数</h3>

<p class="theorem">
  <b>无最大基数定理 (Cantor)</b>
  对任意集合 `X` 有 `|X| lt |2^X|`. 但任一集合都存在幂集, 于是无最大基数.
</p>

<p class="proof">
  易知 `X ~ {{x}: x in X} sube 2^X`, 所以 `|X| le |2^X|`.
  下证 `X` 与其幂集不等势. 假设存在双射 (从而是满射) `f: X to 2^X`,
  令
  <span class="formula">
    `Y = {x in X: x !in f(x)} in 2^X`,
  </span>
  由 `f` 是满射, 存在 `y in X`, 使 `f(y) = Y`.
  然而类似罗素悖论, 不论 `y in Y` 还是 `y !in Y` 均引出矛盾.
</p>

<p class="theorem">
  若 `S` 的一个由基数构成的集合, 则 `"sup"S := uuu S` 也是基数.
</p>

<p class="proof">
  记 `alpha = "sup"S`.
  假定存在序数 `beta lt alpha` 使得 `|beta| = |alpha|`, 由上确界性质, 必存在 `kappa in S` 满足
  `beta lt kappa lt alpha`, 于是 `|beta| le |kappa| le |alpha|`.
  但 `|beta| = |alpha|`, 于是 `|beta| = |kappa|`, 这与 `kappa` 是基数矛盾.
</p>

<p class="remark">
  在序数中, 我们得到更大序数的方法有两种:
  (1) 对序数 `alpha` 取后继 `alpha^+`; (2) 对序数的集合 `S` 取上确界 `"sup"S`.
  在基数中, 同样有两种方法来得到更大的基数:
  (1) 对基数 `kappa` 取幂 `2^kappa`; (2) 对基数的集合 `S` 取上确界 `"sup"S`.
</p>

<ol class="definition">
  使用超穷递归, 定义全体无穷基数如下:
  <li>`aleph_0 := omega`, 这是最小的无穷基数;</li>
  <li>`aleph_(alpha+1) :=` 大于 `aleph_alpha` 的最小基数;</li>
  <li>若 `alpha` 是极限序数, `aleph_alpha := underset (beta lt alpha) "sup" aleph_beta`.</li>
  基数全体构成一个真类.
</ol>

<p class="remark">
  由上定义, `aleph_0` 是最小的无穷基数, `aleph_1` 是最小的不可数基数.
  我们知道 `2^(aleph_0) gt aleph_0`, 那么 `2^(aleph_0) = aleph_1` 吗? 这个命题被称为<b>连续统假设 (CH)</b>.
  现已证明连续统假设与 ZFC 公理系统的独立性: 它无法用 ZFC 公理来证明或证伪.
</p>

<h3>基数的运算</h3>

<ol class="definition">
  <b>基数的运算</b>
  <li>`|X| + |Y| := |X ⊔ Y|` (无交并);</li>
  <li>`|X| * |Y| := |X xx Y|`;</li>
  <li>`|X|^|Y| := |X^Y|`.</li>
  当 `|X|, |Y|` 均有限时, 基数的运算与自然数相同.
</ol>

<p class="lemma">
  `|A^(B xx C)| = |(A^B){::}^C|`.
</p>

<p class="proof">
  这是因为, 给定一个 `f: B xx C to A`,
  可以唯一确定一个函数 `g: C to (B to A)`, 满足
  <span class="formula">
    `f(b, c) = g(c)(b)`,
  </span>
  反之亦然. 因此 `A^(B xx C)` 与 `(A^B){::}^C` 之间存在双射.
</p>

<p class="theorem">
  若 `lambda` 是无穷基数, 则 `lambda = lambda * lambda`, 即 `|X| = |X xx X|`.
</p>

<div class="proof p">
  此证明是对角线法的一个推广.
  我们给出 `bb(On) xx bb(On)` 的一个良序 `-&lt;`: 设 `alpha, beta, alpha', beta'` 是序数,
  <ul>
    <li>若 `max{alpha, beta} lt max{alpha', beta'}`, 则 `(alpha, beta) -&lt; (alpha', beta')`;</li>
    <li>若 `max{alpha, beta} = max{alpha', beta'}`, 则以字典序比较大小, 即先比较第一个分量, 再比较第二个分量.</li>
  </ul>
  如下图, 对任意序数 `alpha`, `alpha xx alpha` 都是 `bb(On) xx bb(On)` 的一个前段,
  从而 `(alpha xx alpha, -&lt;)` 是良序集.
  <div class="img md">
    <img src="../img/set-diagnoal.svg">
  </div>
  反设 `alpha` 是使得 `aleph_alpha * aleph_alpha != aleph_alpha` 的最小序数.
  由于我们已证明 `aleph_0 * aleph_0 = aleph_0`, 所以 `alpha gt 0`.
  设良序集 `aleph_alpha xx aleph_alpha` 的序型为 `gamma`, 即存在保序同构
  `f: gamma to aleph_alpha xx aleph_alpha`.
  由基数定义,
  <span class="formula">
    `gamma ge |gamma|`
    `= |aleph_alpha xx aleph_alpha|`
    `= aleph_alpha * aleph_alpha`
    `gt aleph_alpha`.
  </span>
  由序数的性质, `aleph_alpha subne gamma`.  根据 `-&lt;` 的定义,
  存在无穷序数 `sigma lt aleph_alpha`, 使 `aleph_alpha` 的像 `f(aleph_alpha) sube sigma xx sigma`.
  (为什么存在??)
  现在考虑 `sigma` 的基数
  <span class="formula">
    `aleph_beta := |sigma|` `le sigma` `lt aleph_alpha`.
  </span>
  由假设有 `aleph_beta * aleph_beta = aleph_beta`, 于是
  <span class="formula">
    `aleph_alpha`
    `= |f(aleph_alpha)|`
    `le |sigma xx sigma|`
    `= aleph_beta * aleph_beta`
    `= aleph_beta`,
  </span>
  矛盾.
</div>

<ol class="corollary">
  设 `kappa`, `lambda` 是非零基数,
  <li>若 `kappa`, `lambda` 至少一个是无穷基数, 则 `kappa + lambda = kappa * lambda = max{lambda, kappa}`.</li>
  <li>若 `lambda` 是无穷基数, `2 le kappa le lambda`, 则 `kappa^lambda = 2^lambda`. 形象地说, 任意 `n` 进制小数等价于二进制小数.</li>
</ol>

<ol class="proof">
  <li>不妨设 `lambda` 无穷且 `0 lt kappa le lambda`.
    由基数运算的定义,
    <span class="formula">
      `lambda le kappa + lambda le kappa * lambda le lambda * lambda`.
    </span>
    但 `lambda = lambda * lambda`, 因此由 Cantor-Bernstein 定理知道上式取得等号.
  </li>
  <li>这是因为 `2^lambda le kappa^lambda`
    `le (2^lambda)^lambda`
    `= 2^lambda`.
  </li>
</ol>

<p class="remark">
  注意涉及到无穷时, 基数与序数的运算是很不相同的.
  例如对于序数有 `2^omega = omega`,
  但 Cantor 定理告诉我们, `2^(aleph_0) gt aleph_0`.
  基数还有一个 "奇怪" 性质是:
  <span class="formula">
    `beta lt alpha rArr beta^lambda le alpha^lambda`.
  </span>
  上述的等号是可能成立的. 例如 `beta = 2`, `alpha = 2^(aleph_0)`, `lambda = aleph_0`.
  我们有 `alpha^lambda = (2^(aleph_0)){::}^(aleph_0)`
  `= 2^(aleph_0 xx aleph_0)`
  `= 2^(aleph_0)`.
</p>

<h3>强不可达基数*</h3>

<p class="remark">
  我们已经提到, 得到更大基数的方法无非两种:
  (1) 对基数 `kappa` 取幂 `2^kappa`;
  (2) 对基数 (或序数) 的集合 `S` 取上确界 `"sup"S`.
  那么是否存在这样的基数, 不能通过上述两种方法构造得到呢? 这引出强不可达基数的问题.
</p>

<ol class="definition">
  称基数 `alpha` 称为<b>正则基数</b>, 如果
  <li>`alpha` 是无穷基数, 即 `alpha ge aleph_0`;</li>
  <li>
    不存在极限序数 `beta lt alpha`
    和严格增的序数列 `S := {a_xi: xi lt beta}` 使得 `alpha = "sup"S`.
  </li>
  直观来看, 正则基数不能由比它小的基数通过取上确界得到.
</ol>

<p class="example">
  设 `gamma` 是任意序数, 形如 `aleph_(gamma+omega)` 的基数均不是正则基数.
</p>

<p class="proof">
  事实上取 `S := {aleph_xi: xi lt gamma + omega}`,
  则 `"sup"S = "sup"{aleph_(gamma+n): n lt omega} = aleph_(gamma+omega)`.
  又显然 `gamma + omega lt aleph_(gamma+omega)`, 且为一极限序数.
</p>

<ol class="definition">
  称基数 `kappa` 为<b>强不可达基数</b>, 如果
  <li>`kappa` 不可数, 即 `kappa gt aleph_0`;</li>
  <li>`kappa` 是正则基数;</li>
  <li>对任意基数 `lambda lt kappa` 有 `2^lambda lt kappa`.</li>
  因此, 强不可达基数即不能通过取幂得到, 也不能通过上确界得到.
</ol>

<p class="remark">
  已知 ZFC 中无法证明强不可达基数的存在性.
  还有许多基数的存在性与 ZFC 相独立, 此事在【大基数理论】中亦有记载.
  前面的路, 以后再来探索吧!
</p>

<h2>Grothendieck 宇宙*</h2>

<h3>宇宙的定义</h3>

<p>
  粗略来看, 宇宙无非是一个足够大的集合, 在其中可以满足我们进行一切所需的操作,
  从而避免在 ZFC 中对真类进行讨论. 且看 "上帝" 是如何创造宇宙的:
</p>

<ol class="definition">
  <b>Grothendieck 宇宙</b> 定义为一个集合 `cc U`, 满足:
  <li>`O/ in cc U`.</li>
  <li>`cc U` 是传递集, 即 `u in cc U rArr u sube cc U`.</li>
  <li>`cc U` 中的集合可以配对, 即 `u, v in cc U rArr {u, v} in cc U`.</li>
  <li>`cc U` 中的集合可以取幂集, 即 `u in cc U rArr P(u) in cc U`.</li>
  <li>`cc U` 中的集合可以取并集, 即 `I in cc U`, `AA i, u_i in cc U` `rArr uuu_(i in I) u_i in cc U`.</li>
  称宇宙中的集合 `X in cc U` 为 `cc U`-集. 若集合 `Y` 与某个 `X in cc U` 等势, 称 `Y` 是 `cc U`-小集.
</ol>

<p class="remark">
  我们把 `cc U`-小集比喻成来自 "平行宇宙" 的集合.
</p>

<ol class="corollary">
  设 `cc U` 是宇宙, 则:
  <li>`NN in cc U`;</li>
  <li>`u sube v in cc U rArr u in cc U`;</li>
  <li>`u in cc U rArr uuu u = uuu_(x in u) x in cc U`;</li>
  <li>`u, v in cc U rArr u xx v in cc U`;</li>
  <li>`I in cc U`, `AA i, u_i in cc U` `rArr prod_(i in I) u_i in cc U`.</li>
</ol>

<ol class="proof">
  <li>由于 `cc U` 是传递集, 以及配对、并集操作的可行性, 立即推出 `NN in cc U`.</li>
  <li>由 `cc U` 是传递集知道 `u sube v sube cc U`, 于是对任意 `x in u` 也有 `x in cc U`.
    由配对性质知道 `{x} = {x, x} in cc U`.
    于是由并集性质 `u = uuu_(x in u) {x} in cc U`.
  </li>
  <li>`u` 自身也可以作为取并集的指标集. 注意到 `x in u in cc U` `rArr x in cc U` 即可.</li>
  <li>回顾 Descartes 积的定义, 它只涉及并集、幂集、配对和子集公理模式.</li>
  <li>无穷 Descartes 积比 Descartes 积多要求了选择公理, 其它是一样的.</li>
</ol>

<p>宇宙的概念在解决 ZFC 中棘手的真类问题的同时, 又引入了另外的问题: 满足上述定义的宇宙是否存在?
  它是否已经包含了我们感兴趣的全部集合? 为此引入下面这个力大砖飞的假设:
</p>

<p class="hypothesis">
  <b>(A. Grothendieck)</b>
  对任何集合 `X`, 存在宇宙 `cc U` 使得 `X in cc U`.
</p>

<h3>集合的层垒谱系</h3>

<ol class="definition">
  <b>集合的层垒谱系</b>
  对每个序数 `alpha`, 以超穷递归定义集合 `V_alpha` 如下:
  <li>`V_0 = O/`;</li>
  <li>`V_(alpha+1) := P(V_alpha)`;</li>
  <li>`V_alpha := uuu_(beta lt alpha) V_beta`, 若 `alpha` 为极限序数.</li>
</ol>

<ol class="example">
  <li>`V_1 = {0} = 1`, `V_2 = {0, 1} = 2`, `V_3 = {0, 1, {1}, 2}`, ...</li>
  <li>`V_omega` 是所有 `V_n` 之并, `n in omega`;
    它的元素称为遗传有限集, 这些集合皆有限, 因此 `omega !in V_omega`.
  </li>
</ol>

<ol class="theorem">
  关于层垒谱系, 可以证明:
  <li>每个 `V_alpha` 都是传递集, 且 `alpha sube V_alpha`;</li>
  <li>`alpha lt beta rArr V_alpha sube V_beta`;</li>
  <li>任意集合 `X` 都属于某个 `V_alpha`.</li>
  如此这些集合 `V_alpha` 便囊括了所有集合! 这启发我们在 `V_alpha` 中寻找可能的宇宙.
</ol>

<ol class="proof">
  ??
</ol>

<p class="remark">
  Bourbaki 学派已证明, 宇宙正是形如 `V_kappa` 的集合, 其中 `kappa` 为强不可达基数.
  因此 Grothendieck 假设等价于对任意基数 `lambda`, 存在强不可达基数 `kappa gt lambda`.
  对于大多数范畴论构造和数学论证, 我们只要求存在一个宇宙即可, 即存在一个强不可达基数.
  这称为<b>强不可达基数假设</b>.
</p>

<script src="../../js/note.js?type=math"></script>
</body>
</html>
