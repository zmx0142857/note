<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>自然数与序数</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<h2>Peano 公理 <i>——自然数最早的公理化定义</i></h2>

<ol class="axiom">
	(Peano, 1889) 设 `NN` 是一个非空集合, `0 in NN` 是其中某一特定的元.
  `+` 是 `NN` 上一变换 (即 `NN` 到自身的映射), `(NN, 0, +)` 满足:
  <li>`0 !in "ran"(+)`, 即不存在 `x in NN`, 使得 `0 = x^+`;</li>
  <li>`+` 是一单射, 即 `x^+ = y^+ rArr x = y`;</li>
  <li>归纳原理: `AA E sube NN`, 如果 (1) `0 in E`; (2) `n in E rArr n^+ in
    E`, 那么 `E = NN`.
	</li>
</ol>

<p class="corollary">
  <b>零的惟一性</b>
  设 `n in NN`,  则
  <span class="formula">
    `n != 0` `iff EE x in NN`, `n = x^+`.
  </span>
  即, `NN` 中仅有 0 满足 Peano 公理的性质 1.
</p>

<p class="proof">
  `lArr` 由公理可知, 下证 `rArr`.
  反设 `n in NN`, `n != 0`, 且 `AA x in NN`, `n != x^+`.
  用 `E` 表示与 `n` 不相等的所有自然数, 因此 `0 in E`.
  若 `x in E`, 即 `x != n`, 由假设 `n != x^+` 成立, 故 `x^+ in E`.
  由归纳原理知 `E = NN`, 即 `n` 不与任何自然数相等, 矛盾; 因此 `n = 0`.
</p>

<p class="theorem">
  <b>自然数的惟一性</b>
  满足 Peano 公理的系统都彼此同构; 因此在同构意义下, 自然数系统是惟一的.
  所谓 `(NN, 0, +)` 与 `(NN', 0', +')` 同构, 是指存在一个双射 `f: NN to
  NN'`, 使得
	<span class="formula">
		`f(0) = 0'`,
    `quad f(n^+) = f(n)^(+')`,
    `quad AA n in NN`.
	</span>
</p>

<ol class="proof">
  <li>由于 `0'` 是惟一的, 可以令 `f(0) = 0'`. 我们把 `f` 的定义域记为 `E`,
    因此 `0 in E`.
    对任意 `n in E`, 定义 `f(n^+) = f(n)^(+')`, 因此 `n^+` 也有定义, `n^+
    in E`.  由归纳原理, `E = NN`, `f` 在 `NN` 上有定义.
  </li>
  <li>下证 `f` 是满射, 即证 `AA n' in NN'`, `EE n in NN` 使 `n' = f(n)`.
    若 `n' = 0'`, 结论成立; 现在设结论在 `E sube NN'` 上成立,
    由已知 `0' in E`. 若 `n' = f(n)` 成立, 则 `{:n':}^(+') = f(n)^(+') =
    f(n^+)`, 结论也成立. 在 `NN'` 上应用归纳原理知结论成立.
  </li>
  <li>下证 `f` 是单射, 即证 `AA m, n in NN`, `f(m) = f(n) rArr m = n`.
    若 `m, n` 之中有一个为 `0`, 不妨设 `m = 0`, 则 `f(n) = f(0) = 0'`,
    若 `n != 0`, 则存在 `x in NN` 使 `x^+ = n`. 于是 `f(n) = f(x^+) =
    f(x)^(+') != 0`, 矛盾; 因此 `n = 0`.
    现在设 `f(m) = f(n) rArr m = n`, 则
    <span class="formula">
      `f(m^+) = f(n^+)`
      `iff f(m)^(+') = f(n)^(+')`
      `rArr f(m) = f(n)`
      `rArr m = n`.
    </span>
    在 `NN` 上应用归纳原理知结论成立.
  </li>
</ol>

<p>自然数集 `NN` 的惟一性已经得到保证.
  下面我们将在 ZFC 集合论中保证它的存在性.
</p>

<h2>在 ZFC 集合论体系内定义自然数</h2>

<h3>归纳集与归纳原理</h3>

<p class="definition">
	对任意集合 `x`, 定义 `x^+ := x uu {x}`, 称为 `x` 的<b>后继元
	(successor)</b>. 由配对公理, 并公理和外延公理, 后继元是存在惟一的.
  后继元就是把集合 `x` "放入自身" 所得到的集合, 如
  <span class="formula">
    `{a, b}^+ = {a, b, {a, b}}`.
  </span>
  显然有 `x in x^+`, `x sube x^+`.
</p>

<ol class="definition">
	称 `A` 是一个<b>归纳集 (inductive set)</b>, 如果
	<li>`O/ in A`;</li>
	<li>`x in A rArr x^+ in A`.</li>
</ol>

<p>	在集合论体系内引入下面的公理:</p>

<p class="axiom" id="axiom-inf">
  <b>无限公理</b> 归纳集是存在的.
</p>

<p class="corollary">
  设非空集合 `S` 的元素均为归纳集, 则 `uuu S` 是归纳集.
</p>

<p class="proof">
  `O/ in uuu S`; 若 `x in uuu S`, 则存在 `A in S` 使得 `x in A`.  于是 `x^+ in A sube uuu S`.
  因此 `uuu S` 是归纳集.
</p>

<p class="remark">
  归纳集的全体不构成集, 而是一个真类.
</p>

<p class="proof">
  [来自群友 幂零群]
  考虑全体归纳集 `S`. 若 `S` 是集合, 则定义 `S_0 := S`, `S_(n+1) := S_n^+`.
  应用替换公理模式, 将下文的自然数集 `omega` 替换为 `T := {S_n: n in omega}`,
  则 `omega uu T` 也是归纳集.
  有 `S in omega uu T in S`, 与正则公理矛盾.
</p>

<p class="definition">
  <b>自然数的定义</b>
  由无限公理, 归纳集存在. 将最小的归纳集记为 `omega`, 称为<b>自然数集</b>,
  它的元素称为<b>自然数</b>. 由归纳集定义,`O/ in omega`, 我们记 `0 := O/`,
  `1 := 0^+`, `2 := 1^+`, 等等:
  <span class="formula">
    `0 = O/`,<br>
    `1 = {0} = {O/}`,<br>
    `2 = {0, 1} = {O/, {O/}}`,<br>
    `3 = {0, 1, 2} = {O/, {O/}, {O/, {O/}}}`,<br>
    `cdots`
  </span>
  <br>
  但什么是 "最小" 的归纳集呢?  我们不能取 `omega` 为所有归纳集的交,
  因为归纳集的全体不构成集.  相对地, 取归纳集 `A`, 然后定义 `omega` 为 `A`
  的子集:
	<span class="formula">
		`omega := {x in A:` 对任意归纳集 `E` 有 `x in E}`
	</span>
  该集合的存在惟一性由子集公理和外延公理保证.
  下面证明, `omega` 确是一个归纳集, 并且是最小的归纳集.
</p>

<p class="proof">
	首先 `O/ in A`, 且对任意归纳集 `E` 有 `O/ in E`, 从而由 `omega`
	的定义, `O/ in omega`.<br/>
	其次, 若 `x in omega`, 则 `x in A`, 且对任意归纳集 `E` 有 `x in E`.
	于是分别由 `A, E` 是归纳集知, `x^+ in A`, 且对任意归纳集 `E` 有
	`x^+ in E`. 再由 `omega` 的定义知 `x^+ in omega`.<br/>
	由归纳集的定义, `omega` 是归纳集. 由 `omega` 的定义知对任意归纳集 `E`,
	`omega sube E`, 因此是最小的归纳集.
</p>

<p class="remark">
  这里使用记号 `omega` 而不是 `NN` 的理由是, 自然数有多种定义方式, `omega` 用来特指它的这一种定义.
</p>

<p class="remark">
  由自然数集的作法知道, "交" 的概念可以从集合的交推广到更一般情形: 真类的交.
  设 `cc C` 是一个真类 (其元素为集合, 而且非空, 毕竟空集不是真类), 先取 `A in cc C`, 然后令
  <span class="formula">
    `I := { x in A: AA E in cc C, x in E}`.
  </span>
  称 `I` 为真类 `cc C` 的交, 记为 `uuu cc C`.
</p>

<p>可以验证, 我们定义的自然数集 `omega` 适合 Peano 公理.
先证最有用的归纳原理:
</p>

<p class="corollary">
	<b>自然数归纳原理 (数学归纳法原理)</b>
	设 `T sube omega`, `0 in T` 且
	<span class="formula">
		`n in T rArr n^+ in T`,
	</span>
	则 `T = omega`. 于是 `omega` 满足 Peano 公理的 3.
</p>

<p class="proof">
	显然 `T` 是归纳集, 因此 `omega` 作为最小的归纳集, 有 `omega sube T`.
	但 `T sube omega`, 于是 `T = omega`.
</p>

<p class="remark">
	自然数归纳原理告诉我们, 要得到所有的自然数, 只需从 `0` 开始,
	每次按最近得到的数 `n`, 将 `n^+` 也加入到集合中来,
	这一过程无限地 (合法性由无限公理保证) 进行下去, 就得到全体自然数.
</p>

<p class="corollary">
	<b>`bm omega` 上的强归纳原理</b>
	设 `T sube omega`, 且
	<span class="formula">
		`n sube T rArr n in T`,
	</span>
	则 `T = omega`.
</p>

<p class="proof">
	令 `S = {n in omega: n sube T}`, 由定义 `S sube T sube omega`.<br/>
	首先 `0 in omega`, 且 `0 = O/ sube T`, 因此 `0 in S`.
	其次若 `n in S`, 则 `n sube T`, 于是 `n in T`,
	从而 `n^+ = n uu {n} sube T`. 又由定义 `omega` 是归纳集,
	所以由 `n in omega` 得到 `n^+ in omega`. 这推出 `n^+ in S`.
	于是由自然数归纳原理, `S = omega`, 从而只能 `T = omega`.
</p>

<h3>传递集与单调性</h3>

<p>	本小节证明 `n mapsto n^+` 是单射. 为此引入传递集的概念.</p>

<p class="definition">
	称 `A` 为一<b>传递集 (transitive set)</b>, 如果 "`in`" 的传递性在 `A` 上成立:
	<span class="formula">
		`EE x (t in x ^^ x in A) rArr t in A`.
	</span>
	由于 `x in O/` 是伪命题, 上式的前件为假, 因此对 `A = O/` 上式为真,
	即 `O/` 是传递集.
</p>

<p class="example">
  自然数 0, 1, 2... 均为传递集: `O/`, `{O/}`, `{O/, {O/}}`...
</p>

<p class="remark">
  传递集的全体也是一个真类. 我们将在序数一节中说明.
</p>

<ol class="theorem">
	`AA A`, 下列命题等价:
	<li>`A` 是传递集;</li>
	<li>`uuu A sube A`;</li>
	<li>`a in A rArr a sube A`; 即 `A` 的每个元素都是自身的子集.</li>
	<li>`A sube 2^A`.</li>
</ol>

<ol class="proof">
	<li>`rArr` 2. 设 `t in uuu A`, 则 `EE x in A`, `t in x`.
		由传递集的定义得 `t in A`.
	</li>
	<li>`rArr` 3. 设 `a in A`, 则 `a sube uuu A`. 由 2, `uuu A sube A`,
		所以 `a sube A`.
	</li>
	<li>`iff` 4. 显然.</li>
	<li>`rArr` 1. 设 `t in x`, `x in A`. 由 4, `x in 2^A`, 即 `x sube A`.
		再由 `t in x` 得 `t in A`.
	</li>
</ol>

<p class="theorem">
  <b>后继的逆运算</b>
  若 `x` 是传递集, 则 `uuu x^+ = x`.
</p>

<p class="proof">
	`x^+ = x uu {x}`, 显然 `x in x^+`, 故 `x sube uuu x^+`.
	<br/>
	设 `a in x^+ = x uu {x}`, 则 `a in x` 或 `a = x`. 由 `x` 是传递集知
	`a sube x` 或 `a = x`. 从而 `x^+` 的每一元素都是 `x` 的子集,
	有 `uuu x^+ sube x`.
</p>

<ol class="corollary">
  传递集的性质
  <li>传递集的后继也是传递集.</li>
  <li>若非空集合 `S` 的元素皆是传递集, 则 `nnn S`, `uuu S` 是传递集.</li>
</ol>

<ol class="proof">
  <li>设 `x` 是传递集, 则 `uuu x^+ = x sube x^+`, 所以 `x^+` 也是传递集.</li>
  <li>取 `x in nnn S`, 则 `AA y in S`, `x in y`.
    由 `y` 是传递集知 `x sube y`. 再由 `y` 的任意性知 `x sube nnn S`. 故 `nnn S` 是传递集.
    <br>
    `uuu S` 的证明类似.
  </li>
</ol>

<p class="corollary">
  由于 `0 = O/` 是传递集, 而每个传递集的后继仍是传递集, 根据归纳原理知, 每个自然数都是传递集.
</p>

<p>	平行于强归纳原理, 有:</p>

<p class="corollary">
	`omega` 本身也为一传递集.
</p>

<p class="proof">
	令 `T = {x in omega: x sube omega}`,<br/>
	首先 `0 in omega`, 且 `0 = O/ sube omega`, 所以 `0 in T`.
	其次若 `n in T`, 即 `n in omega`, `n sube omega`, 于是
	`n^+ = n uu {n} sube omega`. 又由 `omega` 是归纳集和 `n in omega` 推出
	`n^+ in omega`. 这推出 `n^+ in T`. 于是由自然数归纳原理 `T = omega`.
	但 `T` 是一传递集: `AA t in T`, `t sube omega = T`.
	所以 `omega` 也是传递集.
</p>

<p>	现在证明 Peano 公理的 2, 即变换 `n mapsto n^+` 是单射.</p>

<ol class="theorem">
	<li>`(AA m, n in omega)` `m = n iff m^+ = n^+`;</li>
	<li>`(AA n in omega)` `n != n^+`.</li>
</ol>

<ol class="proof">
	<li>只需证 `m^+ = n^+ rArr m = n`. 设 `m^+ = n^+`, 则
		`uuu m^+ = uuu n^+`, 但 `m, n` 为传递集, 所以 `uuu m^+ = m`,
		`uuu n^+ = n`, 从而 `m = n`.
	</li>
	<li>令 `T = {n in omega: n != n^+}`.
        首先因为
		<span class="formula">
          `0^+ = {O/} != O/ = 0`,
		</span>
		所以 `0 in T`.<br/>
		其次若 `n in T`, 则 `n != n^+`, 由 1 有 `n^+ != n^(+ +)`,
		从而 `n^+ in T`, 由归纳原理, `T = omega`.
	</li>
</ol>

<p>	最后, `AA n in omega`, `n^+ = n uu {n} != O/ = 0`.
	即 `omega` 满足 Peano 公理的 1, 从而 `omega` 是一个 Peano 系统.
</p>

<h2>序数</h2>

<p>[来自 李文威《代数学方法》]</p>

<h3>序数类</h3>

<ol class="definition">
  <b>(von Neumann)</b>
  称集合 `alpha` 是一个<b>序数</b>, 如果
  <li>`alpha` 是传递集. 即 `alpha` 的每个元素都是 `alpha` 的子集, 换言之 `alpha sube cc P(alpha)`.</li>
  <li>`alpha` 的元素按从属关系 "`in`" 构成良序, 即 `(alpha, in)` 是良序集.</li>
  每个自然数都是序数; `omega` 也是序数.
</ol>

<p class="remark">
  由正则公理知道, 不存在从属关系的无穷降链, 因此 `alpha` 的每个非空子集总是有极小元,
  从而条件 2 可以减弱为全序.
</p>

<p class="corollary">
  <b>序数中的极小元</b> [来自群友 幂零群]
  若 `alpha != O/` 是序数, 则 `alpha` 存在唯一极小元, 这个极小元就是 `O/`.
</p>

<p class="proof">
  由 `(alpha, in)` 是良序集知道 `alpha` 存在一个极小元 `m`.  假设 `m != O/`,
  取 `x in m`, 则由 `alpha` 的传递性和 `m in alpha` 知道 `x in alpha`.
  这与 `m` 的极小性矛盾, 因此 `m = O/`.
  再由空集的唯一性知 `alpha` 的极小元唯一.
</p>

<ol class="corollary">
  序数的性质
  <li>若 `alpha` 是序数, 则其后继 `alpha^+` 也是序数.</li>
  <li>若 `alpha` 是序数, 则它的元素 (如果存在) 也是序数.</li>
  <li>若 `alpha, beta` 是序数, 则 `alpha nn beta` 也是序数.</li>
</ol>

<ol class="proof">
  <li>这是因为传递集的后继也是传递集. 下证 `alpha^+ = alpha uu {alpha}` 是良序集.
    事实上和集合 `alpha` 相比, 集合 `alpha^+` 只多了一个元素 `alpha`,
    因此 `alpha^+` 中的其它元素皆是 `alpha` 的元素, 这指出 `alpha^+` 是全序, 且 `alpha` 是其中的最大元.
    添加一个最大元并不影响每个非空子集有极小元, 因此 `alpha^+` 是良序集.
  </li>
  <li>设 `beta in alpha`. 由 `alpha` 是传递集知 `beta sube alpha`. 因此 `beta`
    作为 `alpha` 的子集也是良序集.
    <br>
    又设 `x in tau in beta`,
    由 `alpha` 是传递集和 `tau in beta in alpha` 知道 `tau in alpha`.
    同理由 `x in tau in alpha` 知道 `x in alpha`.
    现在 `x, tau, beta` 皆是 `alpha` 的元素,
    由 `alpha` 上序关系的传递性知道 `x in beta`, 因此 `beta` 是传递集.
  </li>
  <li>
    首先由传递集的性质知道 `alpha nn beta` 是传递集,
    又良序集的子集也是良序集, 所以 `alpha nn beta` 是序数.
  </li>
</ol>

<ol class="corollary">
  序数之间的关系
  <li>若 `alpha, beta` 是序数, `alpha subne beta`, 则 `alpha in beta`.</li>
  <li>若 `alpha, beta` 是序数, 必有 `alpha sube beta` 或 `beta sube alpha`.</li>
  总之, 对任意两个序数 `alpha, beta`, 必有 `alpha in beta`, `beta in alpha`,
  `alpha = beta` 之一成立.
</ol>

<ol class="proof">
  <li>
    因为 `alpha` 真包含于 `beta`, 可令 `gamma` 为 `beta - alpha` 的极小元. 用 `lt` 表示 `in`,
    令 `X = {x in beta: x lt gamma}`, 下证 `X = alpha`.
    <br>
    事实上任取 `x in X`, 由 `x lt gamma` 知道 `x !in beta - alpha`, 即 `x in
    alpha`, 这证明了 `X sube alpha`.
    <br>
    另一方面任取 `y in alpha`, 由 `alpha` 的传递性有 `y sube alpha`, 因此
    `gamma !in y`, 即 `gamma` 不小于 `y`. `gamma` 也不等于 `y`, 这是因为 `gamma
    in beta - alpha` 而 `y in alpha`. 综上由于 `alpha` 是全序集, 只能 `y lt gamma`, 即 `y in X`.
    这证明了 `alpha sube X`.
    <br>
    把 `X` 定义中的 `lt` 换成 `in` 可知 `X = gamma`, 因此事实上我们证明了
    `alpha` 是 `beta - alpha` 的极小元.
  </li>
  <li>
    令 `gamma := alpha nn beta`, 则 `gamma` 也是序数, 我们证明必有 `gamma = alpha` 或 `gamma = beta`.
    否则, `gamma` 是 `alpha` 和 `beta` 的真子集. 由 1. 知道 `gamma in alpha`,
    `gamma in beta`, 从而 `gamma in gamma`, 与偏序的反称性矛盾 (或者说, 与正则公理矛盾).
  </li>
</ol>

<p class="definition">
  <b>序数类</b>
  我们把全体序数记为 `bb(On)`. 定义序数 `alpha lt beta` 当且仅当 `alpha in beta`,
  则 `(bb(On), lt)` 构成全序, 进而由正则公理知道它构成良序, 但不是良序集, 因为 `bb(On)` 不是一个集合!
</p>

<p class="lemma">
  若非空集合 `S` 的元素皆为序数, 则 `nnn S`, `uuu S` 是序数. 分别记作 `"inf"S` 和 `"sup"S`.
  特别有 `"inf"S in S`.
</p>

<div class="proof p">
  我们已经知道 `"inf" S`, `"sup" S` 是传递集.
  又 `(bb(On), lt)` 构成良序, 所以 `"inf" S`, `"sup" S` 都是良序集.
  <br>
  下证 `"inf"S in S`.
  因为 `"inf"S = nnn S`, 所以对任意序数 `alpha in S` 都有 `"inf"S sube alpha`.
  但 `"inf"S`, `alpha` 皆为序数, 所以必有 `"inf"S = alpha` 或 `"inf"S in alpha`.
  我们断言必存在 `alpha in S` 使得 `"inf"S = alpha`, 假如不然, 则对任意 `alpha in S` 都有 `"inf"S in alpha`, 于是 `"inf" S in nnn S = "inf"S`, 矛盾.
  <hr>
  注: 因为 `"inf"S in S`, 所以它实际是 `S` 中的最小序数. 我们还可以说明 `"sup"S` 是 `S` 的上确界.
  这是因为对任意 `alpha in S`, `alpha sube uuu S`, 从而 `alpha le S`, 说明它是上界.
  又任取 `beta lt "sup"S`, 则 `beta in uuu S`, 即存在 `S_0 in S` 使 `beta in
  S_0`, 即 `beta lt S_0`, 说明它是最小上界, 即上确界.
</div>

<ol class="remark">
  <li>我们已经学习过真类的交, 因此 `"inf" S` 定义中的 `S` 可以推广到真类.
    引理告诉我们, 任意一族序数都可以取其中的最小元.
  </li>
  <li>约定 `"sup" O/ = O/`.</li>
  <li>`"sup"S in S` 不一定成立, 比如 `"sup" omega = omega`.</li>
</ol>

<p class="theorem">
  <b>Burali-Forti 悖论 (1897)</b>
  全体序数 `bb(On)` 是一个真类.
  由于序数是特殊的传递集, 传递集的全体也是真类.
</p>

<p class="proof">
  假如 `bb(On)` 是一个集合, 则 `S := uuu bb(On)` 有定义, 且 `S` 也是一个序数.
  考虑 `S` 的后继 `S^+`, 它也是一个序数, 且严格大于全体序数.
  这是因为任取 `alpha in bb(On)`, 有 `alpha sube S`. 若 `alpha = S`, 则 `alpha = S in S^+`;
  若 `alpha != S`, 则 `alpha in S sube S^+`.
  但 `S^+` 自身也是一个序数, 这意味着 `S^+` 大于自身, 一个矛盾.
</p>

<p class="corollary">
  `bb(On)` 不能被嵌入到集合中.
  换言之, 对任意集合 `P`, 不存在单射 `bb(On) to P`.
</p>

<p class="proof">
  若存在这样的单射 `f`, 分离公理模式确保 `f(bb(On)) sube P` 是集合,
  而替换公理模式指出 `bb(On) = f^-1(f(bb(On)))` 亦是集合, 矛盾.
</p>


<h3>极限序数</h3>

<p class="definition">
  <b>极限序数</b>
  若序数 `alpha` 不是任何序数的后继, 则称 `alpha` 是极限序数.
  `O/`, `omega` 都是极限序数. 我们把小于 `omega` 的序数称为<b>有限序数</b>,
  而其它序数称为<b>无穷序数</b>.
  `omega` 是最小的无穷序数, 也是除了 `O/` 之外最小的极限序数.
</p>

<p class="remark">
  利用公式 `x = uuu x^+` 快速判断:
  如果 `alpha = uuu alpha`, 则它是极限序数; 否则不是.
</p>

<p class="lemma">
  <b>理解序数构造的钥匙</b> 设 `alpha` 是序数, 则
  <span class="formula">
    `alpha`
    `= {beta: beta in alpha}`
    `= {beta: beta lt alpha}`.
  </span>
  由此可知每个序数都是一个集合, 它恰好包含了小于它的所有序数.
  例如, `1 = {0}`, `2 = {0, 1}`, `omega = {0, 1, 2, ...}`
</p>

<ol class="corollary">
  <li>`alpha^+ = "inf"{beta: beta gt alpha}`, 因此 `alpha^+` 是大于 `alpha` 的最小序数.</li>
  <li>`beta lt alpha^+ iff beta le alpha`. 换言之不存在 `beta` 使得 `alpha lt beta lt alpha^+`.</li>
  <li>若 `alpha` 是极限序数, `beta lt alpha`, 则 `beta^+ lt alpha`.</li>
  <li>若 `alpha` 是极限序数, 则 `alpha = "sup" alpha` `= "sup"{beta: beta lt alpha}`.
    总之,
    <span class="formula">
      `"sup" alpha = { beta, if alpha = beta^+; alpha, otherwise :}`.
    </span>
  </li>
</ol>

<ol class="proof">
  <li>
    一方面, 显然 `alpha^+ gt alpha`, 所以 `alpha^+ supe nnn { beta: beta gt alpha }`,
    因为 `alpha^+` 是右边的交集的一员.
    <br>
    另一方面, 任取 `beta gt alpha`, 则有
    `alpha in beta`, `alpha sube beta`, 因此
    `alpha^+ = alpha uu {alpha} sube beta`.
    所以 `alpha^+ sube nnn {beta: beta gt alpha}`.
  </li>
  <li>
    这是上一条的推论.
  </li>
  <li>因为 `alpha` 是极限序数, 不可能有 `beta^+ = alpha`;
    另一方面, 因为 `beta^+` 是大于 `beta` 的最小序数, 也不可能有 `beta^+ gt alpha`.
    所以 `beta^+ lt alpha`.
  </li>
  <li>
    一方面, 对任意 `beta lt alpha`, 有 `beta sube alpha`, 因此 `alpha supe uuu {beta: beta lt alpha}`.
    另一方面, 由于 `alpha` 是极限序数, 对任意 `xi in alpha`, 取 `beta = xi^+`,
    由 3. 知 `xi in beta lt alpha`, 这证明了 `alpha sube uuu {beta: beta lt alpha}`.
  </li>
</ol>

<ol class="example">
  <b>构造非零极限序数的一种方法</b>
  设 `x` 是归纳集, 令
  <span class="formula">
    `alpha := { y in x: y sube x, y in bb(On) }`.
  </span>
  按定义验证以下性质:
  <li>`alpha` 非空.</li>
  <li>`alpha` 是序数.</li>
  <li>`y in alpha rArr y^+ in alpha`.</li>
  因此 `alpha` 是非零极限序数.
</ol>

<ol class="proof">
  <li>`O/ in alpha`.</li>
  <li>先证 `alpha` 是传递集.
    设 `y in alpha`, 则 `y` 是序数; 又设 `z in y`, 则 `z` 作为 `y` 的元素也是序数.
    于是 `z in y sube x`, `z sube y sube x`, 因此 `z in alpha`.
    又 `alpha` 的元素均为序数, 显然为一良序, 所以 `alpha` 是序数.
  </li>
  <li>设 `y in alpha`, 则 `y in x`. 但 `x` 是传递集, 所以 `y^+ in x`.
    又 `y in x`, `y sube x`, 所以 `y^+ = y uu {y} sube x`.
    因此 `y^+ in alpha`.
  </li>
</ol>

<h3>超穷递归 (超限归纳法)</h3>

<ol class="theorem">
  <b>超限归纳法</b>
  令 `C` 为一个由序数构成的类. 如果
  <li>`O/ in C`;</li>
  <li>`alpha in C rArr alpha^+ in C`;</li>
  <li>对于每个极限序数 `alpha`, 满足 `((AA beta lt alpha) beta in C) rArr alpha in C`.
  </li>
  那么 `C = bb(On)`. 如果仅考虑小于某 `theta` 的序数而非 `bb(On)` 整体, 断言依然成立.
</ol>

<p class="proof">
  反设 `C != bb(On)`. 取不在 `C` 中的最小序数 `alpha != O/`, 则无论它是后继或极限序数都导致矛盾.
</p>

<h3>序数的运算</h3>

<div class="definition p">
  设 `alpha, beta` 是序数, `gamma` 是极限序数,
  借助超穷递归原理定义序数的运算如下:
  <table>
    <tr>
      <th>加法</th>
      <td>`alpha + 0 := alpha`</td>
      <td>`alpha + beta^+ := (alpha + beta)^+`</td>
      <td>`alpha + gamma := "sup"{alpha + xi: xi lt gamma}`</td>
    </tr>
    <tr>
      <th>乘法</th>
      <td>`alpha * 0 := 0`</td>
      <td>`alpha * beta^+ := alpha * beta + alpha`</td>
      <td>`alpha * gamma := "sup"{alpha * xi: xi lt gamma}`</td>
    </tr>
    <tr>
      <th>指数</th>
      <td>`alpha^0 := 1`</td>
      <td>`alpha^(beta^+) := alpha^beta * alpha`</td>
      <td>`alpha^gamma := "sup"{alpha^xi: xi lt gamma}`</td>
    </tr>
  </table>
  在 `alpha, beta` 有限的情况下, 它们的运算与自然数相同.
</div>

<ol class="example">
  <b>序数 `omega` 的吸收律</b>
  <li>
    设 `alpha lt omega`, 则
    <span class="formula">
      `alpha + omega = omega`,
      `quad alpha gt 0 rArr alpha * omega = omega`,
      `quad alpha gt 1 rArr alpha^omega = omega`.
    </span>
  </li>
  <li>序数的加法和乘法满足结合律, 但交换律一般不成立, 例如
    `1 + omega = omega` 是一个极限序数, 但 `omega + 1` 是一个后继序数.
    乘法同理: `2 * omega = omega`, 但 `omega * 2 = omega + omega`.
    因此, 比 `omega` 小的序数, 无论加法、乘法, 一般都要写在 `omega` 的右边.
  </li>
</ol>

<ol class="corollary">
  <b>序数加法的性质</b> 对任意序数 `alpha`:
  <li>零元: `0 + alpha = alpha`.</li>
  <li>右不等式: `beta ge gamma rArr beta + alpha ge gamma + alpha`.</li>
  <li>左不等式: `beta gt gamma iff alpha + beta gt alpha + gamma`.</li>
  <li>左消去律: `beta = gamma iff alpha + beta = alpha + gamma`.</li>
</ol>

<ol class="proof enum">
  <li>
    <ol>
      使用超穷递归证明:
      <li>`alpha = 0` 时, 结论成立;</li>
      <li>若 `0 + alpha = alpha`, 则 `0 + alpha^+` `= (0 + alpha)^+` `= alpha^+`;</li>
      <li>若 `alpha` 为极限序数, 且对一切 `xi lt alpha` 有 `0 + xi = xi`,
        则 `0 + alpha` `= "sup"{0 + xi: xi lt alpha}` `= "sup"{xi: xi lt alpha}`
        `= alpha`.
      </li>
    </ol>
  </li>
  <li>
    <ol>`beta = gamma` 时结论显然. 下设 `beta gt gamma`, 对 `alpha` 归纳:
      <li>`alpha = 0` 时显然成立;</li>
      <li>设结论对 `alpha` 成立, 即 `beta + alpha ge gamma + alpha`,
        下证 `beta + alpha^+ ge gamma + alpha^+`.
        若 `beta + alpha = gamma + alpha`, 则结论已经成立. 若 `beta + alpha gt gamma + alpha`,
        则不可能有 `beta + alpha^+ lt gamma + alpha^+`, 否则两边取上确界得到
        `beta + alpha le gamma + alpha`, 矛盾.
      </li>
      <li>设 `alpha` 是极限序数, 且结论对一切 `xi lt alpha` 成立:
        `beta + xi ge gamma + xi`.
        两边取上确界就得到 `beta + alpha ge gamma + alpha`.
      </li>
    </ol>
  </li>
  <li>
    <ol>先证 `rArr`. 对 `beta` 归纳:
      <li>`beta = 1` 时, 必有 `gamma = 0`, 结论成立;</li>
      <li>假设 `beta gt gamma rArr alpha + beta gt alpha + gamma`, 考虑 `beta^+ gt gamma`,
        若 `gamma = beta`, 显然成立 `alpha + beta^+ gt alpha + gamma`;
        若 `gamma lt beta`, 由归纳假设 `alpha + beta^+ gt alpha + beta gt alpha + gamma`.
      </li>
      <li>假设 `beta` 为极限序数, 且结论对一切 `xi lt beta` 成立.
        任取 `gamma lt beta`,
        则由上确界性质 `alpha + beta` `= "sup"{alpha + xi: xi lt beta}` `ge alpha + gamma`.
        为了将上式加强为严格的不等式, 注意到 `beta` 为极限序数, 所以 `gamma^+
        lt beta`, 因此 `alpha + beta ge alpha + gamma^+ gt alpha + gamma`.
      </li>
    </ol>
    再证 `lArr`. 假设 `alpha + beta gt alpha + gamma`, 那么不能有 `beta = gamma`, 否则
    `alpha + beta = alpha + gamma`; 也不能有 `beta lt gamma`, 否则 `alpha + beta lt alpha + gamma`.
    所以 `beta gt gamma`.
  </li>
  <li>`rArr` 显然; 下证 `lArr`. 假设 `alpha + beta = alpha + gamma`, 那么不能有 `beta lt gamma`,
    否则 `alpha + beta lt alpha + gamma`; 同理不能有 `beta gt gamma`, 所以 `beta = gamma`.
  </li>
</ol>

<p class="remark">
  序数加法一般不满足右消去律, 比如 `1 + omega = 2 + omega = omega`.
</p>

<ol class="corollary">
  <b>序数加法和 sup 的性质</b> 设 `alpha` 是任意序数,
  <li>设集合 `S` 的元素都是序数, `"sup"S` 是后继序数, 则 `"sup"S in S`.</li>
  <li>若 `beta gt 0`, 则 `beta` 是极限序数当且仅当 `alpha + beta` 是极限序数.</li>
  <li>若 `beta gt 0`, 则 `alpha + "sup"beta = "sup"(alpha + beta)`.</li>
  <li>设非空集合 `S` 的元素都是序数, 则 `alpha + "sup"S = "sup"(alpha + S)`, 这里 `alpha + S := {alpha + beta: beta in S}`.</li>
</ol>

<ol class="proof enum">
  <li>设 `"sup"S = alpha^+`, 由上确界性质知存在 `beta in S` 使得 `alpha lt beta le alpha^+`,
    于是 `beta = alpha^+`.
    <br>
    逆命题不成立. 如 `S = {omega}`, `"sup"S = omega in S`, 但 `omega` 是极限序数.
  </li>
  <li>设 `beta = gamma^+` 是后继, 于是 `alpha + beta = (alpha + gamma)^+` 也是后继.
    现在设 `beta` 是极限序数,
    下证 `alpha + beta` 是极限序数.
    反设 `alpha + beta = "sup"{alpha + xi: xi lt beta}` 是后继序数,
    则由 1. 知 `alpha + beta in {alpha + xi: xi lt beta}`,
    即存在 `xi lt beta` 使得 `alpha + beta = alpha + xi`.
    由左消去律知道 `beta = xi`, 矛盾.
  </li>
  <li>
    <ol>
      <li>若 `beta = gamma^+`, 则 `"sup" beta = gamma`. 于是
        <span class="formula">
          `alpha + beta`
          `= alpha + gamma^+`
          `= (alpha + gamma)^+`
          `= (alpha + "sup"beta)^+`.
        </span>
        两边同时取上确界得到 `alpha + "sup"beta` `= "sup"(alpha + beta)`.
      </li>
      <li>
        若 `beta` 是极限序数, 则 `"sup"beta = beta`, 由定义
        `alpha + "sup" beta = alpha + beta`,
        又由 2. 知 `alpha + beta` 是极限序数, 故 `alpha + beta = "sup"(alpha + beta)`.
      </li>
    </ol>
  </li>
  <li>
    <ol>记 `gamma := "sup"S`.
      <li>若 `gamma in S`, 则对任意 `beta in S` 有 `beta le gamma`, 从而 `alpha
        + beta le alpha + gamma`, 即 `alpha + gamma = "sup"(alpha + S)`.
      </li>
      <li>若 `gamma !in S`, 由 1. 知道 `gamma` 是极限序数,
        由定义 `alpha + gamma = "sup"{alpha + beta: beta lt gamma}`.
        下证它等于 `"sup"(alpha + S)`.
      </li>
      <li>记 `左 := {alpha + beta: beta lt gamma}`, `右 := alpha + S`.
        对任意 `beta in S` 有 `beta lt gamma`, 所以右 `sube` 左, `"sup" 右 le "sup" 左`.
      </li>
      <li>对任意 `beta lt gamma`, 由上确界性质, 存在 `xi in S` 使得 `beta lt xi`,
        于是 `alpha + beta lt alpha + xi`, `"sup" 左 le "sup" 右`.
      </li>
    </ol>
  </li>
</ol>

<p class="theorem">
  <b>加法结合律</b> `(alpha + beta) + gamma = alpha + (beta + gamma)`.
</p>

<ol class="proof">
  对 `gamma` 归纳:
  <li>`gamma = 0` 时结论成立;</li>
  <li>设结论对 `gamma` 成立, 则对 `gamma^+` 有
    <span class="formula align">
      `(alpha + beta) + gamma^+`<br>
      `= ((alpha + beta) + gamma)^+`<br>
      `= (alpha + (beta + gamma))^+`<br>
      `= alpha + (beta + gamma)^+`<br>
      `= alpha + (beta + gamma^+)`.
    </span>
  </li>
  <li>若 `gamma` 是极限序数, 且对一切 `xi lt gamma` 结论成立, 则
    <span class="formula align">
      `(alpha + beta) + gamma`<br>
      `= "sup"{(alpha+beta) + xi: xi lt gamma}`<br>
      `= "sup"{alpha + (beta+xi): xi lt gamma}`<br>
      `= alpha + "sup"{beta + xi: xi lt gamma}`<br>
      `= alpha + (beta + gamma)`.
    </span>
  </li>
</ol>

<p class="theorem">
  <b>序数的减法</b>
  设序数 `beta le alpha`, 则存在唯一序数 `gamma` 使得 `beta + gamma = alpha`.
  于是可记 `alpha - beta := gamma`.
</p>

<ol class="proof enum">
  <li>
    存在性.
    `beta = alpha` 时取 `gamma = 0` 即可. 下设 `alpha gt beta ge 0`, 对 `alpha` 使用超穷递归:
    <ol>
      <li>若对序数 `alpha` 结论成立, 则对序数 `alpha^+` 和任意 `beta lt alpha^+`
        (即 `beta le alpha`) 有
        <span class="formula">
          `beta + gamma^+` `= (beta + gamma)^+` `= alpha^+`.
        </span>
      </li>
      <li>若 `alpha` 是极限序数, 且对一切 `xi lt alpha` 结论成立, 则对任意 `beta lt alpha`,
        <span class="formula">
          `beta + "sup"{gamma: beta + gamma = xi, xi lt alpha}`
          `= "sup"{beta + gamma: beta + gamma = xi, xi lt alpha}`
          `= "sup"{xi: xi lt alpha}`
          `= alpha`.
        </span>
      </li>
    </ol>
  </li>
  <li>唯一性. 这等价于序数加法的左消去律.</li>
</ol>

<ol class="definition">
  <b>规范序列</b>
  以极限序数 `alpha` 为极限的序列可以有多个, 我们规定其中一个是规范的, 记作 `[alpha]_n`. 它满足
  <li>`[omega^alpha + beta]_n`
    `= omega^alpha + [beta]_n`, `beta lt omega^(alpha+1)`.
    于是 `omega^alpha * (k+1) = omega^alpha * k + [omega^alpha]_n`, `k` 是自然数;
  </li>
  <li>`[omega^(alpha+1)]_n = omega^alpha * n`;</li>
  <li>`[omega^alpha]_n = omega^([alpha]_n)`, `alpha` 为极限序数.</li>
</ol>

<ol class="example">
  <li>`[omega]_n = n`, `[omega * 2] = omega + n`, `[omega^2]_n = omega * n`, `[omega^omega] = omega^n`.</li>
  <li>`[omega^(omega^2 * 2 + omega * 3) * 5]_n`
    `= omega^(omega^2 * 2 + omega * 3) * 4 + omega^(omega^2 * 2 + omega * 2 + n)`.
  </li>
</ol>

<h3>燃烧数与伪燃烧函数*</h3>

<p>[来自 <a href="https://arxiv.org/abs/2003.14342" target="_blank">arxiv</a>,
<a href="https://www.zhihu.com/question/36464952/answer/2912411355" target="_blank">知乎: 伪燃烧函数</a>,
<a href="https://zhuanlan.zhihu.com/p/1897263349986726061" target="_blank">知乎: 燃烧数 (续)</a>]</p>

<p class="example">
  <b>伪燃烧函数</b>
  设 `f(x) = {-x, x lt 0; f(x-f(x-1))//2, x ge 0:}`, 求 `f(3)`.
</p>

<ol class="solution">
  第一部分, 目标是求出 `f(2)`.
  <li>`a in [0, 1)` 时,
    <span class="formula">
      `f(a) = f(a-f(a-1))//2` `= f(2a-1)//2`.
    </span>
    于是 `a in [0, 1//2)` 时, `f(a) = 1//2-a`. 这是从点 `(0, 1//2)` 到点 `(1//2, 0)` 的一条 -45 度直线.
    `a in [1//2, 3//4)` 时, 只需一步变换 `a mapsto 2a-1` 就可将自变量映到之前的 `[0, 1//2)` 区间内,
    但函数值减半. 这说明函数在 `[1//2, 3//4)` 的图象与 `[0, 1//2)` 的图象相似, 但大小减半.
    同理 `a in [3//4, 7//8)` 时函数图象与 `[1//2, 3//4)` 的图象相似, 但大小再减半...
    同样的相似图形就这样填满了 `[0, 1)` 区间.
    特别地, 函数值的突变点是
    <span class="formula">
      `f(1 - 2^(1-n)) = 2^-n`, `quad n ge 1`.
    </span>
    因此 `f(0) = 2^-1`, `f(1//2) = 2^-2`, `f(3//4) = 2^-3`...
  </li>
  <li>`a in [1, 3//2)` 时
    <span class="formula">
      `f(a) = f(a - f(a-1))//2`
      `= f(a - f(2a-3)//2)//2`
      `= f(2a-3//2)//2`.
    </span>
    `a in [1, 5//4)` 时, 只需一步变换 `a mapsto 2a-3//2` 就可将自变量映到 `[1//2, 1)`, 但函数值减半.
    这说明函数在 `[1, 5//4)` 的图象与 `[1//2, 1)` 的图象相似, 但大小减半.
    或者说, 它与 `[0, 1)` 相似, 但大小为 `1//4`.
    同理 `[5//4, 11//8)` 的图象与 `[1, 5//4)` 相似, 但大小减半.
    相似图形就这样填满了 `[1, 3//2)` 区间.
    <br>
    `a in [3//2, 7//4)` 时,
    <span class="formula">
      `f(a) = f(a - f(a-1))//2`
      `= f(a - f(2a-3)//2)//2`
      `= f(a - f(4a-7)//4)//2`
      `= f(2a-7//4)//2`.
    </span>
    `a in [3//2, 13//8)` 时, 只需一步变换 `a mapsto 2a-7//4` 就可将自变量映到
    `[5//4, 3//2)`, 但函数值减半. 或者说它与 `[1, 3//2)` 相似, 但大小为 `1//4`.
    继续推理下去,
    <span class="formula">
      `f(1) = f(0)//4 = 2^-3`,
      `quad f(3//2) = f(1)//4 = 2^-5`,<br>
      `f(7//4) = f(3//2)//4 = 2^-7`,
      `quad f(15//8) = f(7//4)//4 = 2^-9`.
    </span>
    我们现在可以求 `f(2)`:
    <span class="formula">
      `f(2)`
      `= f(2-f(1))//2`
      `= f(15//8)//2`
      `= 2^-10`.
    </span>
  </li>
</ol>

<ol class="solution enum">
  第二部分, 引入序数.
  <li>
    函数 `f` 的突变点是问题的关键, 称为<b>燃烧数</b>. 按从小到大的顺序,
    每个燃烧数 `x` 可赋予一个序数 `alpha = "ord"(x)`, 称为第 `alpha` 个燃烧数.
    于是
    <span class="formula">
      `"ord"(0) = 1`,
      `"ord"(1//2) = 2`,
      `cdots`,
      `"ord"(1) = omega`.
    </span>
    区间 `[1, 5//4)` 是 `[0, 1)` 的拷贝, 在 `[1, 3//2)` 上又有 `omega` 个这样的拷贝, 于是
    <span class="formula">
      `"ord"(5//4) = omega * 2`,
      `"ord"(11//8) = omega * 3`,
      `cdots`,
      `"ord"(3//2) = omega^2`.
    </span>
    继续下去,
    <span class="formula">
      `"ord"(7//4) = omega^3`,
      `"ord"(15//8) = omega^4`,
      `cdots`,
      `"ord"(2) = omega^omega`.
    </span>
  </li>
  <li>
    <ol>
      观察发现:
      <li>
        若 `x` 是燃烧数, 则 `x+1` 也是燃烧数, 且
        <span class="formula">
          `"ord"(x+1) = omega^("ord"(x))`.
        </span>
      </li>
      <li>设 `alpha` 为极限序数,
        则对任意 `n`, 规范序列的 `n+1` 项 `[alpha]_(n+1)`
        对应的燃烧数恰好是 `[alpha]_n` 与 `alpha` 对应燃烧数的中点.
      </li>
      <li>`f` 在每个燃烧数处的取值都是 2 的负整数次方, 如果记
        <span class="formula">
          `d(alpha) = -log_2 f(x)`, `quad if alpha = "ord"(x)`.
        </span>
        于是对每个序数 `alpha`, `d(alpha)` 都取非负整数值, 我们的目标是求
        `d("ord"(3)) = d(omega^(omega^omega))`.
      </li>
      <li>对任意序数 `alpha`, `f` 在 `alpha+1` 处的取值是 `alpha` 处取值的一半,
        换言之 `d(alpha+1) = d(alpha) + 1`.
      </li>
      <li>`n` 为自然数时, 显然 `d(n) = n`.
        又由 `f(2) = 2^-10` 知道 `d(omega^omega) = 10`.
      </li>
      <li>`omega` 的系数每增加 1, `d` 值就增加 1, 换言之
        `d(omega^alpha * (k+1) + beta) = d(omega^alpha + beta) + k`,
        `beta lt omega^(alpha)`, `k` 是自然数.
        例如:
        <span class="formula">
          `d(omega) = 3`, `quad d(omega * 2) = 4`, `quad d(omega * n) = n+2`.
        </span>
      </li>
      <li>`omega` 的次数每增加 1, `d` 值就增加 2, 换言之
        `d(omega^(alpha+k) + beta) = d(omega^alpha + beta) + 2 k`,
        `beta lt omega^(alpha+1)`, `k` 是自然数.
        例如:
        <span class="formula">
          `d(omega) = 3`, `quad d(omega^2) = 5`, `quad d(omega^n) = 2n+1`.
        </span>
      </li>
    </ol>
  </li>
  <li>最后, 若 `alpha` 是极限序数, 则由递推关系 `f(x) = f(x-f(x-1))//2` 得
    <span class="formula">
      `d(omega^alpha) = d(gamma) + 1`,
    </span>
    `gamma` 是某个小于 `omega^alpha` 的序数, 且满足
    <span class="formula">
      `"fus"(gamma) + 2^(-d(alpha)) = "fus"(omega^alpha)`,
    </span>
    其中 `"fus"(alpha)` 表示 `alpha` 对应的燃烧数.
    根据观察 2, `gamma` 属于 `omega^alpha` 的规范序列.
    但它具体是哪一项? 设 `"fus"(omega^alpha) - "fus"([omega^alpha]_1) = 2^-s`,
    那么 `gamma` 是 `d(alpha) - s + 1` 项. 记作
    <span class="formula">
      `chi(alpha) = d(alpha) - s + 1`.
    </span>
    例如 `alpha = omega^n` 时,
    <span class="formula">
      `"fus"(omega^alpha) = 3 - 2^(1-n)`,<br>
      `[omega^alpha]_k = [omega^(omega^n)]_k`
      `= omega^(omega^(n-1) * k)`,<br>
      `"fus"([omega^alpha]_1) = 3 - 2^(2-n)`,<br>
      `s = n-1`,<br>
      `chi(alpha) = chi(omega^n)`
      `= d(omega^n) - (n-1) + 1`
      `= n+3`.
    </span>
    又如 `alpha = omega^omega` 时,
    <span class="formula">
      `"fus"(omega^alpha) = 3`,<br>
      `[omega^alpha]_k = omega^(omega^k)`,<br>
      `"fus"([omega^alpha]_1) = 2`,<br>
      `s = 0`,<br>
      `chi(alpha) = chi(omega^omega)`
      `= d(omega^omega) - s + 1`
      `= 11`.
    </span>
    一般情况, 我们的公式是
    <span class="formula">
      `d(omega^alpha) = d(omega^([alpha]_(chi(alpha)))) + 1`.
    </span>
  </li>
</ol>

<ol class="solution">
  第三部分, `f(3)` 的计算. 由上一部分知道, 只需求出 `d(omega^(omega^omega))`.
  <li>`d(omega^(omega^omega))`
    `= d(omega^(omega^(chi(omega^omega)))) + 1`
    `= d(omega^(omega^11))+1`.
  </li>
  <li>令 `n` 为自然数,
    `d(omega^(omega^n))`
    `= d(omega^(omega^(n-1) * chi(omega^n))) + 1`
    `= d(omega^(omega^(n-1) * (n+3))) + 1`.
  </li>
  <li>使用更简单的记号, 只将 `omega` 的指数写出, 上面两式可以写成:
    <span class="formula">
      `omega^omega overset(+1)to omega^11`,<br>
      `omega^n overset(+1)to omega^(n-1) * (n+3)`.
    </span>
  </li>
  <li>继续计算, `chi(omega^(n-1) * (n+3)) = omega^(n-2) * n`, 于是
    <span class="formula">
      `omega^(n-1) * (n+3) overset(+1)to omega^(n-1) * (n+2) + omega^(n-2) * n`.
    </span>
    如果设 `omega^n` 的系数每减小 1, `d` 值就增长 `c_n`, 那么
    <span class="formula">
      `omega^(n-1) * (n+3) overset(+1)to`
      `omega^(n-1) * (n+2) + omega^(n-2) * n`
      `overset(+n * c_(n-2))to omega^(n-1) * (n+2)`.
    </span>
    由此推出
    <span class="formula">
      `c_(n-1) = 1 + n * c_(n-2)`, `quad c_0 = 2`.
    </span>
  </li>
  <li>于是
    <span class="formula">
      `omega^n overset(+1)to omega^(n-1) * (n+3)`
      `overset(+ (n+2) c_(n-1))to omega^(n-1)`.
    </span>
    即, `omega` 的次数每减小 1, `d` 值就增长 `1 + (n+2) c_(n-1) = c_n + c_(n-1)`.
    记 `a_n = d(omega^(omega^n))`, 则
    <span class="formula">
      `a_n = c_n + c_(n-1) + a_(n-1)`,
      `quad a_0 = 3`.
    </span>
    这个数列的首项及递推关系已经完全确定, 编程
<pre>
c = [2], a = [3]
for (let i = 1; i &lt;= 11; ++i) {
  c[i] = 1 + (i+1)*c[i-1]
  a[i] = c[i] + c[i-1] + a[i-1]
}
</pre>
    得到 `a_11 = 1541023936`,
    从而 `d(omega^(omega^omega)) = a_11 + 1` `= 1541023937`,
    <span class="formula">
      `f(3) = 2^-1541023937`.
    </span>
  </li>
</ol>

<h3>大序数初探*</h3>

<p>[来自：<a href="https://zhuanlan.zhihu.com/p/295674553" target="_blank">core.exe@知乎</a>]</p>

<ol class="example">
  <b>序数 `epsi_alpha` 和 `zeta_alpha`</b>
  <li>我们知道,
    <span class="formula">
      `omega^2 = omega * omega = "sup"{omega * n: n lt omega}`.<br>
      `omega^n = omega^(n-1) * omega = "sup"{omega^(n-1) * k: k lt omega}`.<br>
    </span>
    如果对映射 `alpha mapsto omega^alpha` 进行迭代:
    <span class="formula">
      `omega^omega = "sup"{omega^n: n lt omega}.<br>
      `omega^(omega^omega) = "sup"{omega^(omega^n): n lt omega}`.
    </span>
    最终 `epsi_0 := "sup"{1, omega, omega^omega, omega^(omega^omega), cdots}`.
    它是满足等式 `omega^alpha = alpha` 的第一个序数.
  </li>
  <li>
    `epsi_0+1` 并不是 `alpha mapsto omega^alpha` 的不动点, 依然可以取指数使它增大:
    <span class="formula">
      `epsi_1 := "sup"{epsi_0+1, omega^(epsi_0+1), omega^(omega^(epsi_0+1)), cdots}`.
    </span>
    `epsi_1` 是继 `epsi_0` 后满足等式 `omega^alpha = alpha` 的下一个序数. 现在对一切序数 `alpha`, 定义
    <span class="formula">
      `epsi_alpha := {
        "sup"{epsi_beta+1, omega^(epsi_beta+1), omega^(omega^(epsi_beta+1)), cdots}, if alpha = beta+1;
        "sup"{epsi_beta: beta lt alpha}, if alpha 是极限序数;
      :}
    </span>
    一些例子:
    <span class="formula">
      `epsi_omega = "sup"{epsi_0, epsi_1, epsi_2, cdots}`,<br>
      `epsi_(omega^omega) = "sup"{epsi_omega, epsi_(omega^2), epsi_(omega^3), cdots}`,<br>
      `epsi_(epsi_0) = "sup"{epsi_omega, epsi_(omega^omega), epsi_(omega^(omega^omega)), cdots }`.
    </span>
  </li>
  <li>
    我们知 `epsi_alpha` 是比指数 `omega^alpha` 增长更快的一种运算. 对下标 `alpha` 进行迭代就得到
    <span class="formula">
      `zeta_0 := "sup"{epsi_0, epsi_(epsi_0), epsi_(epsi_(epsi_0)), cdots }`.
    </span>
    这不仅是 `alpha mapsto omega^alpha` 的不动点, 也是 `alpha mapsto epsi_alpha` 的不动点.
  </li>
  <li>还存在比 `zeta_alpha` 更高的层级, 其思路是使用后继跳出不动点,
    然后不断迭代达到下一个不动点. `zeta` 层级之后分别是 `eta`, `xi`... 等等, 但希腊字母是有限个的,
    这促使我们寻找一个统一的定义.
    注意到 `epsi_alpha` 是迭代 `alpha mapsto omega^alpha` 的第 `alpha` 个不动点,
    `zeta_alpha` 是迭代 `alpha mapsto epsi_alpha` 的第 `alpha` 个不动点.
    因此我们寻求一列函数 `f_n(alpha)`, 其中 `f_(n+1)(alpha)` 是 `f_n` 的第 `alpha` 个不动点:
  </li>
</ol>

<ol class="definition">
  <b>Veblen 函数</b> 定义为二元函数 `varphi(x, y)`, `x, y` 为序数. 它满足:
  <li>`varphi(0, alpha) := omega^alpha`, `varphi(1, alpha) := epsi_alpha`, `varphi(2, alpha) := zeta_alpha`.
  </li>
  <li>考虑第 `alpha` 层的迭代 `varphi_alpha := beta mapsto varphi(alpha, beta)`.
    `varphi(alpha+1, 0)` 定义为 `varphi_alpha` 的第 0 个不动点.
    `varphi(alpha+1, beta+1)` 定义为 `varphi(alpha+1, beta)` 之后, `varphi_alpha` 的下一个不动点.
    写为公式就是
    <span class="formula align">
      `varphi(alpha+1, 0) := "sup"{varphi(alpha, 0)+1, varphi(alpha, varphi(alpha, 0)+1), cdots}`,<br class="noindent">
      `varphi(alpha+1, beta+1) := "sup"{varphi(alpha+1, beta)+1, varphi(alpha, varphi(alpha+1, beta)+1), cdots}`,<br class="noindent">
      `varphi(alpha, beta) := "sup"{varphi(alpha, gamma): gamma lt beta}`, 如果 `beta` 为极限序数.
    </span>
  </li>
  <li>对于第一个变元 `alpha` 是极限序数的情形, 定义
    <span class="formula align">
      `varphi(alpha, 0) := "sup"{varphi(gamma, 0): gamma lt alpha}`,<br class="noindent">
      `varphi(alpha, beta+1) := "sup"{varphi(gamma, varphi(alpha, beta)+1), gamma lt alpha}`.
    </span>
  </li>
  <li>最后, 还可以考虑第一个变元的迭代 `alpha mapsto varphi(alpha, 0)`, 它的第 0 个不动点是
    <span class="formula">
      `Gamma_0 := "sup"{0, varphi(0, 0), varphi(varphi(0, 0), 0), cdots}`.
    </span>
    这也是 Veblen 函数的极限.
  </li>
</ol>

<h2>选择公理</h2>

<p>[来自李文威《代数学方法》]
[参考 <a href="https://zhuanlan.zhihu.com/p/482203007" target="_blank">芷雨Chira@知乎</a>]
</p>

<p class="remark">
  在定义自然数集时, 我们用公理规定 "存在归纳集", 然后从中取出了一个归纳集
  `A`. 一般地, 给定有限个非空集合, 我们可以分别从中取出一个元素,
  作为它所在集合的代表. 然而, 当这样的非空集合有无限个时, 以上做法失效:
  因为公理和推理规则只能应用有限次. 一个自然的想法是, 对于无限个非空集合,
  也应能取出它们的代表元, 这就是选择公理.
</p>

<p class="axiom" id="axiom-choice">
  <b>选择公理</b>
  设集合 `X` 的每个元素皆非空, 则存在函数 `g: X to uuu X` 使得
  `AA x in X`, `g(x) in x`.
  这个函数称为选择函数.
</p>

<p class="theorem">
  对任意良序集 `P`, 存在唯一的序数 `alpha` 与它同构.
</p>

<p class="proof">
  不妨设 `P != O/`, 因为 `P` 是集合, 然而不存在无所不包的集合, 故可选取 `u !in P`.
  下面利用超穷递归定义一族元素 `A_alpha`, 其中 `alpha in bb(On)`:
  <br>
  首先由于 `P` 是良序集, 可以令 `A_0 := min(P)`, 这里 `min` 表示取出一个极小元.
  对任意序数 `alpha`, 记 `P_alpha := { A_beta: beta lt alpha }`, 对应于 `alpha` 的前段.
  递归定义
  <span class="formula">
    `A_alpha := {
        min(P - P_alpha), if P_alpha subne P;
        u, if P_alpha = P;
    :}`
  </span>
  由于 `P` 是集合, 必存在最小序数 `theta` 使得 `A_theta = u`, 否则 `bb(On)` 可以嵌入 `P`, 引起矛盾.
  于是 `A_alpha mapsto alpha` 是 `P` 到 `{beta: beta lt theta} = theta` 之间的同构.
</p>

<p class="remark">
  我们称 `P` 的<b>序型</b>是 `alpha`.
  因此序数是良序集的代表, 借助序数我们可以了解良序集的结构.
</p>

<p>下面的良序定理和 Zorn 引理是选择公理的等价命题:</p>

<p class="theorem">
  <b>Zermelo 良序定理 (1904)</b>
  对任意集合 `S`, 都存在 `S` 上的二元关系 `R`, 使得 `R` 是 `S` 上的良序.
</p>

<p class="proof">
  事实上, 只要把证明良序集与某个序数同构时的函数 `min`
  换成选择公理赋予我们的选择函数 `g`, 就得到 `S` 与某个序数 `theta` 之间的双射,
  从而导出 `S` 上的良序.
</p>

<ol class="theorem">
  <b>Zorn 引理</b>
  设 `P` 为非空偏序集, 它的全序子集称为<b>链</b>. 我们有:
  <li>若 `P` 中每个链都有上界, 则 `P` 有极大元;</li>
  <li>若 `P` 中每个链都有下界, 则 `P` 有极小元.</li>
</ol>

<ol class="proof">
  只证 1. 反设 `P` 不含极大元. 取 `A_0 in P`, 运用超穷递归定义 `A_alpha` 如下:
  设 `P_alpha := {A_beta: beta lt alpha}` 已经被定义, 且满足 `gamma lt beta rArr A_gamma lt A_beta`.
  于是 `P_alpha` 是 `P` 的一条链.
  <li>若 `alpha = gamma + 1`, 由于 `P` 无极大元, 故可以选取 `A_alpha in P` 使得 `A_alpha gt A_gamma`.
  </li>
  <li>若 `alpha` 为极限序数, 由题设, 链 `P_alpha` 有上界, 故可以选取一个上界 `A_alpha`.
    我们证明对任意 `beta lt alpha` 有 `A_beta lt A_alpha`.
    事实上若存在一个 `A_beta = A_alpha`,
    则其后继 `A_(beta^+) gt A_beta = A_alpha`, 与 `A_alpha` 是 `P_alpha` 的上界矛盾.
  </li>
  上述步骤中发生了无数次选取的操作, 这由选择公理保证.
  由上述构造知真类 `bb(On)` 可以嵌入 `P`, 从而矛盾.
</ol>

<h2>超现实数</h2>

<p>[来自 <a href="https://www.bananaspace.org/wiki/%E8%B6%85%E7%8E%B0%E5%AE%9E%E6%95%B0" target="_blank">香蕉空间</a>]
</p>

<p>
  超现实数源于博弈论, 它包含实数, 也包含无穷大、无穷小的数.
  不严谨地说, 全体超现实数构成有序域; 但由于超现实数过多, 因此不构成集合.
</p>

<ol class="definition">
  <b>超现实数 (surreal number)</b> 由左集和右集组成, 记为 `{L | R}`. 它的递归定义如下:
  <li><b>超现实数的判定</b>
    `{L | R}` 是超现实数当且仅当 `L, R` 是超现实数的两个集合, 且
    <span class="formula">
      `l lt r`, `quad AA l in L, r in R`.
    </span>
    因此, 当 `L`, `R` 其一为空时, `{L | R}` 就是超现实数.
    特别 `{O/ | O/}` 是超现实数, 简记为 `{|}` 或者 `0`.
    我们常常省略左右集的花括号, 比如将 `{{0}|{1}}` 简记为 `{0|1}`.
  </li>
  <li>
    <b>超现实数的序</b>
    对于 `x = {X_L|X_R}` 和 `y = {Y_L|Y_R}`, 定义 `x le y` 当且仅当下面两个条件同时成立:
    <span class="formula">
      `(AA x_L in X_L)` `x_L lt y`,<br>
      `(AA y_R in Y_R)` `x lt y_R`.
    </span>
    这里 `lt` 意为 `ge` 的否定.
    可以验证 `le` 满足自反性和传递性. 如果两个超现实数同时满足 `x le y` 和 `y le x`, 则视它们相等.
    因此全体超现实数关于 `le` 是全序.
  </li>
  <li>
    <b>超现实数的加法</b> 定义
    <span class="formula">
      `x + y = { {x_L+y}uu{x+y_L} | {x_R+y}uu{x+y_R} }`,
    </span>
    其中 `x_L, x_R, y_L, y_R` 分别取遍 `x, y` 的左右集.<br>
    加法零元为 `0`; 逆元为
    <span class="formula">
      `-x = { {-x_R} | {-x_L} }`,
    </span>
    `x_L, x_R` 分别取遍 `x` 的左右集.
  </li>
  <li>
    <b>超现实数的乘法</b>
    定义 `x * y = {L|R}`, 其中
    <span class="formula">
      `L = {x_L * y + x * y_(color(red)(L)) - x_L * y_(color(red)(L))}`
      `uu {x_R * y + x * y_(color(red)(R)) - x_R * y_(color(red)(R))}`,<br>
      `R = {x_L * y + x * y_(color(red)(R)) - x_L * y_(color(red)(R))}`
      `uu {x_R * y + x * y_(color(red)(L)) - x_R * y_(color(red)(L))}`,
    </span>
    `x_L, x_R, y_L, y_R` 分别取遍 `x, y` 的左右集.<br>
    乘法单位元是 `1 := {0|}`; 乘法逆元比较复杂, 稍后讨论.
  </li>
</ol>

<p class="remark">
  序数的加法与乘法没有交换律, 但超现实数有.
</p>

<ol class="example">
  <b>超现实数的运算规律</b>
  <li>对任意自然数 `n` 有 `n+1 = {n|}`, `-n-1 = {|-n}`.</li>
  <li>哪些超现实数是等价的?</li>
  <li>交换左右集的效果是什么?</li>
  <li>有理数如何嵌入超现实数?</li>
</ol>

<ul class="example">
  对每个序数 `alpha`, 把“第 `alpha` 天造出的超现实数”记为
  <span class="formula">
    `S_alpha := { {L|R}: L, R sube uuu_(beta lt alpha) S_beta }`.
  </span>
  换言之 `AA x in L uu R`, `EE beta lt alpha`, `x in S_beta`;
  即左右集的元素都是在前面某一天造出来的.
  <li>第 `0` 天的超现实数只能是 `0`.</li>
  <li>第 `1` 天的超现实数除了 `0` 还有 `1 = {0|}` 与 `-1 = {|0}`.
    但 `{0|0}` 不是超现实数, 它违背了超现实数的判定.
  </li>
  <li>第 `2` 天新造出的超现实数有 `2 = {1|}`, `-2 = {|-1}`, `1/2 = {0|1}` 和 `-1/2 = {-1|0}`.</li>
  <li>第 `3` 天新造出的超现实数有 `1/4 = {0|1/2}`, `3/4 = {1/2|1}`, `3/2`, `3` 和它们的相反数.</li>
  <li>任意分母为 2 的幂的有理数都可以在有限天内造出.</li>
  <li>第 `omega` 天可以造出的数包括但不限于所有实数 (通过 Dedekind 分割), 以及
    <span class="formula">
      无穷大 `omega = {0, 1, 2, ... |}`,<br>
      无穷小 `epsi = {0|1,1/2,1/4,...}`.
    </span>
    事实上 `epsi = 1//omega`.
  </li>
</ul>

<script src="../../js/note.js?type=math"></script>
</body>
</html>
