<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8" />
  <title>复变函数的展开</title>
  <link rel="stylesheet" href="../../css/note.css"/>
</head>

<body>

<h2>Taylor 级数</h2>

<h3>Weierstrass 内闭一致收敛定理</h3>

<p>复变函数中, 连续函数的相关级数理论与数学分析的类似、平行, 甚至连证明方法都是一样的. 然而一旦涉及复变函数的导数, 就会产生一些本质不同的结果, 比如下面的 Weierstrass 定理.
</p>

<p class="definition">
  设 `f_n(z)` 是定义在点集 `E` 上的一列函数. 若对任意 `epsi gt 0`,
  存在正整数 `N`, 使 `n gt N` 时
  <span class="formula">
    `|sum_(k=1)^n f_k(z) - f(z)| lt epsi`, `quad AA z in E`,
  </span>
  因为级数对于各个 `z in E` 收敛的速度是一致的,
  我们称级数 `sum_(n ge 1) f_n(z)` 在 `E` 上<b>一致收敛</b>到 `f(z)`.<br>
  一致收敛的要求可能过高了, 因此引入内闭一致收敛的概念:
  若 `sum_(n ge 1) f_n(z)` 在域 `D` 的任意紧子集上一致收敛, 则称它在
  `D` 上<b>内闭一致收敛</b>.
</p>

<p class="example">
  级数 `1 + (- 1 + z) + (- z + z^2) + cdots` 的部分和等于 `z^n`.
  它在单位圆盘中内闭一致收敛到零, 但不一致收敛: 事实上对任意正整数 `n`,
  存在 `z_0 in B(0, 1)`, 使得 `|z_0^n| ge 1//2`, 和 `0` 尚有距离.
  `z_0` 在 `B(0, 1)` 上起到“拖后腿”的作用, 使得级数无法以一致的速度收敛.
</p>

<p class="theorem">
  <b>(Weierstrass)</b> 设 `f_n(z)` 是域 `D` 上的一列全纯函数, 级数
  `sum_(n ge 1) f_n(z)` 在 `D` 上内闭一致收敛到 `f(z)`, 则 `f(z)` 也是 `D`
  上的全纯函数, 且可以逐项求任意阶导数:
  <span class="formula">
    `f^((k))(z) = sum_(n ge 1) f^((k))_n(z)`, `quad k in ZZ^+`,
  </span>
  上式也是内闭一致收敛的.
</p>

<ol class="proof">
  <li>先证 `f in H(D)`. 任取 `a in D`, 则存在 `r gt 0` 使得 `bar(B(a, r))
    sube D`. 由于级数在 `bar(B(a, r))` 上一致收敛, 且级数的各项是连续函数,
    所以 `f` 也在 `bar(B(a, r))` 上连续.<br>
    在 `B(a, r)` 中取一条可求长闭曲线 `gamma`, 则级数也在 `gamma`
    上一致收敛, 因而可在 `gamma` 上逐项积分. 由 Cauchy 积分定理:
    <span class="formula">
      `int_gamma f(z) dz`
      `= sum_(n ge 1) int_gamma f_n(z) dz`
      `= sum_(n ge 1) 0 = 0`.
    </span>
    现在由 Morera 定理知 `f in H(B(a, r))`; 由 `a` 的任意性知 `f in H(D)`.
  </li>
  <li>下证 `f` 可逐项求导, 为此我们利用上一章的 Cauchy 不等式对 `k`
    阶导数作出估计.
    取紧子集 `K sube D`, 记 `rho = d(K, del D) gt 0`. 以 `K`
    中任意点为心, `rho//2` 为半径的开圆盘都含于 `D`, 因此
    <span class="formula">
      `G := uuu_(z in K) B(z, rho//2) sube D`.
    </span>
    注意到 `bar G` 是紧集, 所以级数在 `bar G` 上一致收敛: `AA epsi gt 0`,
    存在正整数 `N`, 当 `n gt N` 时,
    <span class="formula">
      `underset(z in bar G)"sup"|S_n(z) - f(z)| lt epsi`,
    </span>
    这里 `S_n(z) = sum_(j=1)^n f_j(z)`.  从而由 Cauchy 不等式得
    <span class="formula">
      `underset(z in K)"sup"|S_n^((k))(z) - f^((k))(z)|`
      `le C underset(z in G)"sup"|S_n(z) - f(z)|`
      `le C epsi`.
    </span>
    由 `K` 的任意性知 `S_n^((k))(z)` 在 `D` 上内闭一致收敛到 `f^((k))(z)`.
  </li>
</ol>

<p class="example">
  考虑 Riemann zeta 函数 `zeta(s) = sum_(n ge 1) 1/n^s`,
  由于 `|n^s| = n^("Re"s)`, 因此当 `"Re"s ge sigma gt 1` 时,
  `|1/n^s| le 1/n^sigma`, 级数在 `"Re"s gt 1` 上内闭一致收敛.
  由 Weierstrass 定理, `zeta(s)` 是 `"Re"s gt 1` 上的全纯函数.
</p>

<h3>幂级数</h3>

<h3>辐角原理</h3>

<canvas id="arg-principle" width="400" height="400"></canvas>
<span class="formula">
  `z = 3 "e"^("i"t)`,<br>
  `w = (z^2+1)(z-1)^5`.
</span>

<h2>Laurent 级数</h2>

关于 Laurent 级数的一个精彩应用是 <a href="../analysis/9.html#def-bessel-function">Bessel 函数</a>.

<h3>孤立奇点的分类</h3>

<p class="remark">
  [来自 。。。。。。] xs，我刚刚在想奇点分类，可去奇点是守序善良，`m` 阶极点是绝对中立，本性奇点是混沌邪恶。
</p>

<h2>留数及其应用</h2>

<p class="example">
  <b>全纯函数零点的留数表示</b> [来自 レイ]
  设 `f` 在域 `D` 上全纯, `a` 是其一阶零点, 设 `1//f(z)` 在 `a` 处的留数为
  `c_(-1)`, 考虑 `z/f(z) = (z-a)/f(z) + a/f(z)` 的留数,
  第一项的留数是零 (因为 `a` 是可去奇点), 第二项的留数是 `a c_(-1)`.
  综上
  <span class="formula">
    `a = ("Res"(z//f(z), a))/("Res"(1//f(z), a))`
    `= (int_gamma (z dz)/f(z))/(int_gamma dz/(f(z)))`,
  </span>
  `gamma` 是绕 `a` 一周的简单闭曲线.
</p>

<h3>用留数计算广义积分</h3>

<p class="proposition">
  `int_(-oo)^oo R(x) dx = 2pi"i"sum_("Im" z gt 0) "Res"(z)`.
</p>

<p class="example">
  [群友 我是与数学陷入爱河的人]
  求 `I = int_0^oo (sqrt x)/(x^2+2x+5) dx`.
</p>

<p class="solution">
  `I = int_(-oo)^oo z^2/(z^4+2z^2+5) dz`
  `= 2pi"i"sum_("Im" z gt 0) "Res"(z)`.
  被积函数的奇点即为分母的零点, 它们都是一重的, 且关于坐标轴对称.
  设第一象限中的零点为
  <span class="formula">
    `z_1 = a + b"i"` `= sqrt(-1+2"i")`.
  </span>
  则 `z_2 = -bar z_1`, `z_3 = - z_1`, `z_4 = bar z_1`.
  计算上半平面奇点的留数:
  <span class="formula">
    `"Res" z_1 = (z_1^2)/((z_1-z_2)(z_1-z_3)(z_1-z_4))`
    `= (-1+2"i")/(8a b"i"(a+b"i"))`,<br/>
    `"Res" z_2 = (z_2^2)/((z_2-z_1)(z_2-z_3)(z_2-z_4))`
    `= (-1-2"i")/(8a b"i"(a-b"i"))`.
  </span>
  又由 `(a+b"i")^2 = -1+2"i"` 知
  <span class="formula">
    `a^2+b^2 = sqrt 5`, `quad a^2-b^2 = -1`, `quad a b = 1`.
  </span>
  于是
  <span class="formula">
    `I = (2pi"i")/(8a b"i") (2"Re"(-1+2"i")(a-b"i"))/(a^2+b^2)`
    `= pi/(2sqrt 5) (2b-a)`
    `= pi/(2sqrt 5) sqrt(a^2-4a b+b^2)`
    `= pi/(2sqrt 5) sqrt(5/2 (sqrt 5-1))`
    `= pi/sqrt(2sqrt5+2)`.
  </span>
</p>

<p class="solution">
  [群友 我是薛定谔的猪]
  <span class="formula">
    `I = int_0^oo (t^2+sqrt 5)/(t^4+2t^2+5) dt`
    `+ int_0^oo (t^2-sqrt 5)/(t^4+2t^2+5) dt`.
  </span>
  第一项等于
  <span class="formula">
    `int_0^oo ("d"(t - sqrt 5/t))/((t-sqrt 5/t)^2+(2+2sqrt 5))`
    `= {:1/sqrt(2sqrt 5+2) arctan{:(t-sqrt 5/t)/sqrt(2sqrt 5 + 2):}|_0^oo`
    `= pi/sqrt(2sqrt 5+2)`.
  </span>
  类似地, 第二项等于 0.
</p>

<script src="../../js/note.js?type=math"></script>
<script src="../../js/plot.js"></script>
<script src="../../code/complex.js"></script>
<script>
const { sin, cos, PI } = Math
const f = t => {
  const z = Complex.i.mul(t).exp().mul(3)
  const left = z.pow(2).add(1)
  const right = z.sub(1).pow(5)
  return left.mul(right)
}
new Plot('arg-principle')
  .geometry({xmin: -10000, xmax: 10000, ymin: -10000, ymax: 10000}).clear().axis()
  .plot(t => f(t).real, t => f(t).imag, {min: 0, max: PI*2, continuity: Infinity})
</script>
</body>
</html>
