<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8" />
  <title>复变函数的展开</title>
  <link rel="stylesheet" href="../../css/note.css"/>
</head>

<body>

<h2>Taylor 级数</h2>

<h3>Weierstrass 内闭一致收敛定理</h3>

<p>复变函数中, 连续函数的相关级数理论与数学分析的类似、平行, 甚至连证明方法都是一样的. 然而一旦涉及复变函数的导数, 就会产生一些本质不同的结果, 比如下面的 Weierstrass 定理.
</p>

<p class="definition">
  设 `f_n(z)` 是定义在点集 `E` 上的一列函数. 若对任意 `epsi gt 0`,
  存在正整数 `N`, 使 `n gt N` 时
  <span class="formula">
    `|sum_(k=1)^n f_k(z) - f(z)| lt epsi`, `quad AA z in E`,
  </span>
  因为级数对于各个 `z in E` 收敛的速度是一致的,
  我们称级数 `sum_(n ge 1) f_n(z)` 在 `E` 上<b>一致收敛</b>到 `f(z)`.<br>
  一致收敛的要求可能过高了, 因此引入内闭一致收敛的概念:
  若 `sum_(n ge 1) f_n(z)` 在域 `D` 的任意紧子集上一致收敛, 则称它在
  `D` 上<b>内闭一致收敛</b>.
</p>

<p class="example">
  级数 `1 + (- 1 + z) + (- z + z^2) + cdots` 的部分和等于 `z^n`.
  它在单位圆盘中内闭一致收敛到零, 但不一致收敛: 事实上对任意正整数 `n`,
  存在 `z_0 in B(0, 1)`, 使得 `|z_0^n| ge 1//2`, 和 `0` 尚有距离.
  `z_0` 在 `B(0, 1)` 上起到“拖后腿”的作用, 使得级数无法以一致的速度收敛.
</p>

<p class="theorem">
  <b>(Weierstrass)</b> 设 `f_n(z)` 是域 `D` 上的一列全纯函数, 级数
  `sum_(n ge 1) f_n(z)` 在 `D` 上内闭一致收敛到 `f(z)`, 则 `f(z)` 也是 `D`
  上的全纯函数, 且可以逐项求任意阶导数:
  <span class="formula">
    `f^((k))(z) = sum_(n ge 1) f^((k))_n(z)`, `quad k in ZZ^+`,
  </span>
  上式也是内闭一致收敛的.
</p>

<ol class="proof">
  <li>先证 `f in H(D)`. 任取 `a in D`, 则存在 `r gt 0` 使得 `bar(B(a, r))
    sube D`. 由于级数在 `bar(B(a, r))` 上一致收敛, 且级数的各项是连续函数,
    所以 `f` 也在 `bar(B(a, r))` 上连续.<br>
    在 `B(a, r)` 中取一条可求长闭曲线 `gamma`, 则级数也在 `gamma`
    上一致收敛, 因而可在 `gamma` 上逐项积分. 由 Cauchy 积分定理:
    <span class="formula">
      `int_gamma f(z) dz`
      `= sum_(n ge 1) int_gamma f_n(z) dz`
      `= sum_(n ge 1) 0 = 0`.
    </span>
    现在由 Morera 定理知 `f in H(B(a, r))`; 由 `a` 的任意性知 `f in H(D)`.
  </li>
  <li>下证 `f` 可逐项求导, 为此我们利用上一章的 Cauchy 不等式对 `k`
    阶导数作出估计.
    取紧子集 `K sube D`, 记 `rho = d(K, del D) gt 0`. 以 `K`
    中任意点为心, `rho//2` 为半径的开圆盘都含于 `D`, 因此
    <span class="formula">
      `G := uuu_(z in K) B(z, rho//2) sube D`.
    </span>
    注意到 `bar G` 是紧集, 所以级数在 `bar G` 上一致收敛: `AA epsi gt 0`,
    存在正整数 `N`, 当 `n gt N` 时,
    <span class="formula">
      `underset(z in bar G)"sup"|S_n(z) - f(z)| lt epsi`,
    </span>
    这里 `S_n(z) = sum_(j=1)^n f_j(z)`.  从而由 Cauchy 不等式得
    <span class="formula">
      `underset(z in K)"sup"|S_n^((k))(z) - f^((k))(z)|`
      `le C underset(z in G)"sup"|S_n(z) - f(z)|`
      `le C epsi`.
    </span>
    由 `K` 的任意性知 `S_n^((k))(z)` 在 `D` 上内闭一致收敛到 `f^((k))(z)`.
  </li>
</ol>

<p class="example">
  考虑 Riemann zeta 函数 `zeta(s) = sum_(n ge 1) 1/n^s`,
  由于 `|n^s| = n^("Re"s)`, 因此当 `"Re"s ge sigma gt 1` 时,
  `|1/n^s| le 1/n^sigma`, 级数在 `"Re"s gt 1` 上内闭一致收敛.
  由 Weierstrass 定理, `zeta(s)` 是 `"Re"s gt 1` 上的全纯函数.
</p>

<h3>幂级数</h3>

<h3>辐角原理</h3>

<canvas id="arg-principle" width="550" height="400"></canvas>

<h2>Laurent 级数</h2>

<p class="example">
  <b>Bessel 函数</b>
  将 `exp(z/2(zeta-1/zeta))` 在 `CC\\{0}` 中展开为 Laurent 级数
  <span class="formula">
    `sum_(n=-oo)^oo J_n(z) zeta^n`,
  </span>
  `n ge 0` 时, `J_n(z)` 称为 (第一类) Bessel 函数, 可以证明
  <span class="formula">
    `J_n(z) = 1/pi int_0^pi cos(n theta - z sin theta) "d"theta`
    `= sum_(k ge 0) (-1)^k/(k!(n+k)!) (z/2)^(n+2k)`,
  </span>
  `J_n(z)` 是下面 Bessel 方程的解:
  <span class="formula">
    `x^2 y'' + x y' + (x^2-n^2) y = 0`.
  </span>
</p>

<ol class="proof">
  <li>使用定义计算 Laurent 级数的系数, 在单位圆上积分:
    <span class="formula">
      `J_n(z) = 1/(2pi"i") int_C f(zeta)/zeta^(n+1) "d"zeta`
      `= 1/(2pi"i") int_0^(2pi) "e"^(("e"^("i"theta)
      - "e"^(-"i"theta))z//2)/"e"^((n+1)"i"theta) "i" "e"^("i"theta)
      "d"theta`
      `= 1/(2pi) int_0^(2pi) "e"^("i"(z sin theta - n theta)) "d"theta`.
    </span>
    区间再现, 得
    <span class="formula">
      `1/(2pi) int_0^pi "e"^("i"(z sin theta - n theta)) + "e"^("i"(z
      sin(2pi-theta) - n(2pi-theta))) "d"theta`
      `= 1/pi int_0^pi cos(z sin theta - n theta) "d"theta`.
    </span>
  </li>
  <li>另一方面, 利用指数函数的幂级数展开, 令 `n = t - k` 得
    <span class="formula">
      `exp((z zeta)/2) exp(-z/(2zeta))`
      `= sum_(t ge 0) ((z zeta)/2)^t/(t!) sum_(k ge 0) (-z/(2zeta))^k`
      `= sum_(n=-oo)^oo zeta^n sum_(k ge 0) (-1)^k/(k!(n+k)!) (z/2)^(n+2k)`.
    </span>
  </li>
  <li>将 `J_n(z)` 的级数形式代入微分方程, 可以验证等式成立, 过程从略.</li>
</ol>

<h2>留数及其应用</h2>

<p class="example">
  <b>全纯函数零点的留数表示</b> [来自 レイ]
  设 `f` 在域 `D` 上全纯, `a` 是其一阶零点, 设 `1//f(z)` 在 `a` 处的留数为
  `c_(-1)`, 考虑 `z/f(z) = (z-a)/f(z) + a/f(z)` 的留数,
  第一项的留数是零 (因为 `a` 是可去奇点), 第二项的留数是 `a c_(-1)`.
  综上
  <span class="formula">
    `a = ("Res"(z//f(z), a))/("Res"(1//f(z), a))`
    `= (int_gamma (z dz)/f(z))/(int_gamma dz/(f(z)))`,
  </span>
  `gamma` 是绕 `a` 一周的简单闭曲线.
</p>

<h3>用留数计算广义积分</h3>

<p class="proposition">
  `int_(-oo)^oo R(x) dx = 2pi"i"sum_("Im" z gt 0) "Res"(z)`.
</p>

<p class="example">
  [群友 我是与数学陷入爱河的人]
  求 `I = int_0^oo (sqrt x)/(x^2+2x+5) dx`.
</p>

<p class="solution">
  `I = int_(-oo)^oo z^2/(z^4+2z^2+5) dz`
  `= 2pi"i"sum_("Im" z gt 0) "Res"(z)`.
  被积函数的奇点即为分母的零点, 它们都是一重的, 且关于坐标轴对称.
  设第一象限中的零点为
  <span class="formula">
    `z_1 = a + b"i"` `= sqrt(-1+2"i")`.
  </span>
  则 `z_2 = -bar z_1`, `z_3 = - z_1`, `z_4 = bar z_1`.
  计算上半平面奇点的留数:
  <span class="formula">
    `"Res" z_1 = (z_1^2)/((z_1-z_2)(z_1-z_3)(z_1-z_4))`
    `= (-1+2"i")/(8a b"i"(a+b"i"))`,<br/>
    `"Res" z_2 = (z_2^2)/((z_2-z_1)(z_2-z_3)(z_2-z_4))`
    `= (-1-2"i")/(8a b"i"(a-b"i"))`.
  </span>
  又由 `(a+b"i")^2 = -1+2"i"` 知
  <span class="formula">
    `a^2+b^2 = sqrt 5`, `quad a^2-b^2 = -1`, `quad a b = 1`.
  </span>
  于是
  <span class="formula">
    `I = (2pi"i")/(8a b"i") (2"Re"(-1+2"i")(a-b"i"))/(a^2+b^2)`
    `= pi/(2sqrt 5) (2b-a)`
    `= pi/(2sqrt 5) sqrt(a^2-4a b+b^2)`
    `= pi/(2sqrt 5) sqrt(5/2 (sqrt 5-1))`
    `= pi/sqrt(2sqrt5+2)`.
  </span>
</p>

<p class="solution">
  [群友 我是薛定谔的猪]
  <span class="formula">
    `I = int_0^oo (t^2+sqrt 5)/(t^4+2t^2+5) dt`
    `+ int_0^oo (t^2-sqrt 5)/(t^4+2t^2+5) dt`.
  </span>
  第一项等于
  <span class="formula">
    `int_0^oo ("d"(t - sqrt 5/t))/((t-sqrt 5/t)^2+(2+2sqrt 5))`
    `= {:1/sqrt(2sqrt 5+2) arctan{:(t-sqrt 5/t)/sqrt(2sqrt 5 + 2):}|_0^oo`
    `= pi/sqrt(2sqrt 5+2)`.
  </span>
  类似地, 第二项等于 0.
</p>

<script src="../../js/note.js?type=math"></script>
<script src="../../js/plot.js"></script>
<script src="../../code/complex.js"></script>
<script>
const { sin, cos, PI } = Math
const f = t => {
  const z = Complex.i.mul(t).exp().mul(3)
  return Complex.mul(z.pow(2).add(1), z.sub(1).pow(5))
}
new Plot('arg-principle')
  .geometry({xmin: -15000, xmax: 15000, ymin: -10000, ymax: 10000}).clear().axis()
  .plot(t => f(t).real, t => f(t).imag, {min: 0, max: PI*2, continuity: Infinity})
</script>
</body>
</html>
