<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>初等代数</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<h2>根式运算</h2>

<p class="example">
	<b>化简二重根式</b>
	记 `sqrt(u^2-v) = n`, 则
	<span class="formula">
		`sqrt(u+-sqrt v) = sqrt((u+n)/2) +- sqrt((u-n)/2)`.
	</span>
	如 `sqrt((3-sqrt 5)/2) = (sqrt 5 - 1)/2`, `sqrt(2+sqrt 3)
	+ sqrt(2-sqrt 3) = sqrt 6`, `sqrt(-1+2"i") + sqrt(-1-2"i")
  = sqrt(2sqrt5-2)` 等等.
</p>

<p class="proof">
	记 `a = u + sqrt v`, `b = u - sqrt v`, 则
	<span class="formula">
		`sqrt a +- sqrt b`
		`= sqrt(a + b +- 2 sqrt(a b))`
		`= sqrt(2(u +- n))`.
	</span>
	解出 `sqrt a`, `sqrt b` 即得结论.
</p>

<p class="remark">
  等号右边可以有超过两项吗? 我们考虑
  <span class="formula">
    `(sqrt a + sqrt b + sqrt c)^2`
    `= a+b+c+2(sqrt(ab) + sqrt(bc) + sqrt(ca))`,
  </span>
  其中 `a b, b c, c a` 至少两个数有相同的非平方因子.
  这里的非平方因子是指从一个数中约去最大的平方因子的结果.
  不妨设 `a b, b c` 有相同的非平方因子 `d`, 那么 `a b * b c // d^2`
  是平方数, 即 `a c` 是平方数.
  反设 `a, b, c` 的非平方因子均不相同, 特别 `a, c` 有不同的非平方因子,
  那么 `a c` 不可能为平方数.  因此, `a, b, c`
  中至少两个数有相同的非平方因子.  换言之等号右边最多只有两项.
</p>

<h2>一元多项式方程</h2>

<h3>二次方程</h3>

<p class="example">
	熟知一元二次方程 `a x^2 + b x + c = 0`, `a, b, c in RR`, `a != 0`
	的求根公式为
	<span class="formula">
		`x_(1,2) = (-b +- sqrt(b^2-4 a c))/(2 a)`.
	</span>
	于是, 方程在 `Delta = b^2 - 4 a c gt 0` 时有两个不同实根,
	`Delta = 0` 时有一对实二重根, `Delta lt 0` 时有一对共轭复根.<br/>
	一元二次方程的 Vieta 定理是说,
	<span class="formula">
		`x_1 + x_2 = -b/a`, `quad x_1 x_2 = c/a`.
	</span>
	最后, 如果 `c != 0`, 则方程 `a + b y + c y^2 = 0` 的根存在, 且满足
	`y_1 = x_2^-1, y_2 = x_1^-1`, 其中
	<span class="formula">
		`y_(1,2) = (-b +- sqrt(b^2-4 a c))/(2 c)`
		`= (2 a)/(-b &mp; sqrt(b^2-4 a c))`.
	</span>
</p>

<p class="remark">
    也可以由 Vieta 定理得到一元二次方程的求根公式: 设 `a x^2+b x + c = 0`
    的两根为 `A+B`, `A-B`, 则
    <span class="formula">
        `(A+B) + (A-B) = -b/a`, `quad (A+B)(A-B) = c/a`.
    </span>
    解得 `A = -b/(2a)`, `B = +-sqrt(b^2-4a c)/(2a)`.
</p>

<p> 一般的一元 `n` 次方程形如
	<span class="formula">
		`a_n x^n + a_(n-1) x^(n-1) + cdots + a_1 x + a_0 = 0`,
		`quad a_n != 0`.
	</span>
	两边同除以 `a_n`, 就可将方程左边化为首一 (最高次项系数为 1) 的多项式:
	<span class="formula">
		`x^n + b_(n-1) x^(n-1) + cdots + b_1 x + b_0 = 0`.
	</span>
	再作变元替换 `x = y - b_(n-1)/n` (即配 `n` 次方),
	可将 `n-1` 次项系数化为零:
	<span class="formula">
		`y^n + c_(n-2) y^(n-2) + cdots + c_1 y + c_0 = 0`.
	</span>
	下面我们就从首一的, `n-1` 次项系数为零的方程入手,
	讨论三次和四次方程的解法.
</p>

<h3>三次方程</h3>

<p class="example">
	<b>解三次方程</b> `x^3 + p x + q = 0`.
</p>

<p class="solution">
	(Cardano 公式)
	令 `x = u + v`, 代入方程有
	<span class="formula">
		`u^3 + v^3 + (3 u v + p)(u+v) + q = 0`.
	</span>
	可见 `x` 是方程的解的一个充分条件是
	<span class="formula">`{
		u^3 + v^3 = -q;
		3 u v = -p;
		:}`</span>
	令 `alpha = u^3`, `beta = v^3`, 则 `alpha`, `beta` 应当满足
	<span class="formula">`{
		alpha + beta = -q;
		alpha beta = -p^3/27;
		:}`</span>
	从而由一元二次方程根与系数的关系 (Vieta 定理), `alpha`, `beta` 是
	关于 `z` 的方程
	<span class="formula">
		`z^2 + q z -p^3/27 = 0`
	</span>
	的两根, 即
	<span class="formula">
		`alpha, beta = -q/2 +- sqrt((q/2)^2 + (p/3)^3)`.
	</span>
	以 `omega = -1/2 + (sqrt 3)/2 "i"` 记三次方程 `x^3 = 1` 的一个根,
	又记 `root 3 alpha`, `root 3 beta` 分别为三次方程 `u^3 = alpha`,
	`v^3 = beta` 的一个根, 且满足 `root 3 alpha root 3 beta = -p//3`
	(在 `p` 为实数时, 将 `root 3 alpha` 和 `root 3 beta` 取为实数,
	或一对共轭复数即可).
	容易验证, `u^3 = alpha` 的全部根和 `v^3 = beta`
	的全部根为 (注意, `n` 次多项式最多只有 `n` 个根)
	<span class="formula">
		`u = root 3 alpha, omega root 3 alpha, omega^2 root 3 alpha`,
		<br/>
		`v = root 3 beta, omega root 3 beta, omega^2 root 3 beta`.
	</span>
	再利用 `u v = -p//3`, 原方程的三个根为:
	<span class="formula">
		`root 3 alpha + root 3 beta`,
		`omega root 3 alpha + omega^2 root 3 beta`,
		`omega^2 root 3 alpha + omega root 3 beta`.
	</span>
</p>

<ol class="solution">
	(三角解法, <a href="https://www.spaces.ac.cn/archives/831" target="_blank">苏剑林. (2010, Aug 08). 《三次方程的三角函数解法 》[Blog post].</a>)
	假设 `p, q in RR`.
	引理: 三角恒等式 (前两个是万能代换的变形, 后一个是三倍角公式)
	<span class="formula">
		`2/(tan 2A) = 1/(tan A) - tan A`,<br/>
		`2/(sin 2A) = 1/(tan A) + tan A`,<br/>
		`cos 3A = 4cos^3 A - 3 cos A`.
	</span>
	`p = 0` 时, 容易得到惟一实根 `x = root 3 (-q)`.
	`p != 0` 时, 设 `r = -q |3/p|^(3/2)`, 下面分三种情形讨论方程的解法.
	<li>
		`p gt 0` 时, 令 `x = sqrt(p/3) z` 得
		<span class="formula">
			`z^3 + 3 z = r`.
		</span>
		再令 `z = w^-1 - w`, 有
		<span class="formula">
			`w^-3 - w^3 = (w^-1 - w)(w^-2 + 1 + w^2)` `= z(z^2 + 3) = r`.
		</span>
		令 `w^3 = tan A`, 由引理,
		<span class="formula">
			`2/(tan 2A) = r`,
			`quad A = 1/2 arctan{:2/r:}`,
			`quad w = root 3(tan A)`.
		</span>
		由于 `"d"/(dz) (z^3 + 3 z) = 3 z^2 + 3 gt 0`, 函数 `z^3 + 3 z`
		在 `(-oo, +oo)` 上单调增, 且取遍一切实数值, 所以 `z^3 + 3 z = r`
		恒有一个实根.
	</li>
	<li>
		`p lt 0`, `|r| ge 2` 时, 令 `x = sqrt(|p|/3) z` 得
		<span class="formula">
			`z^3 - 3 z = r`.
		</span>
		再令 `z = w^-1 + w`, 有
		<span class="formula">
			`w^-3 + w^3 = (w^-1 + w)(w^-2 - 1 + w^2)` `= z(z^2 - 3) = r`.
		</span>
		令 `w^3 = tan A`, 由引理,
		<span class="formula">
			`2/(sin 2A) = r`,
			`quad A = 1/2 arcsin{:2/r:}`,
			`quad w = root 3(tan A)`.
		</span>
		由反正弦函数的定义域知, 上述公式只对 `|r| ge 2` 有效.
		事实上, 由 `"d"/(dz) (z^3 - 3 z) =
		3 z^2 - 3` 知, 函数有两个极值点 `z = +- 1`, 因而容易推出
		`z^3 - 3 z = r` 在
		`|r| gt 2` 时只有一实根, `|r| = 2` 时有一对实的重根和另一实根,
		而 `|r| lt 2` 时, 有三个不同实根.
	</li>
	<li>`p lt 0`, `|r| lt 2` 时, 令 `z = 2 cos A`, 利用引理,
		<span class="formula">
			`r = z^3 - 3 z = 2 (4 cos^3 A - 3 cos A) = 2 cos 3A`,<br/>
			`A = 1/3 (arccos{:r/2:} + 2 k pi)`, `quad k = 0, 1, 2`.
		</span>
	</li>
</ol>

<ol class="solution">
	(盛金公式) 方程
	<span class="formula">
		`a x^3 + b x^2 + c x + d = 0`, `quad a, b, c, d in RR`.
	</span>
	计算三个重根判别式:
	<span class="formula">
		`A = b^2 - 3 a c`,<br/>
		`B = b c - 9 a d`,<br/>
		`C = c^2 - 3 b d`
	</span>
	和总判别式 `Delta = B^2 - 4 A C`, 有:
	<li>`A = B = 0` 时, 有三重实根
		<span class="formula">
			`x_(1, 2, 3) = -b/(3a) = -c/b = -(3d)/c`.
		</span>
	</li>
	<li>`Delta = 0`, 且 `A != 0` 时, 有一实单根和一实二重根
		<span class="formula">
			`x_1 = B/A - b/a`, `quad x_(2,3) = -B/(2A)`.
		</span>
	</li>
	<li>`Delta gt 0` 时, 有一实根, 一对共轭复根
		<span class="formula">
			`x_1 = (-b - (root 3 y_1 + root 3 y_2))/(3a)`,<br/>
			`x_(2, 3) = (-b + 1/2(root 3 y_1 + root 3 y_2) +- (sqrt
			3)/2(root 3 y_1 - root 3 y_2)"i")/(3 a)`.
		</span>
		其中 `y_(1, 2) = A b + 3 a((-B+-sqrt Delta)/2)`.
	</li>
	<li>`Delta lt 0`, `A gt 0`, 且
		<span class="formula">
			`T = (2 A b - 3 a B)/(2 sqrt (A^3)) in [-1, 1]`
		</span>
		时, 有三个不同实根
		<span class="formula">
			`x_1 = (-b - 2 sqrt A cos{:theta/3:})/(3 a)`,<br/>
			`x_(2, 3) = (-b + sqrt A(cos{:theta/3:} +- sqrt 3
			sin{:theta/3:}))/(3 a)`.
		</span>
		其中 `theta = arccos T`.
	</li>
</ol>

<ol class="remark">
	三次方程 `x^3 + p x + q = 0` (`p, q in RR`)
	的判别式记为 `Delta = (q//2)^2 + (p//3)^3`.
	<li>`Delta gt 0` 时, 方程有一实根, 一对共轭复根;</li>
	<li>`Delta lt 0` 时, 方程有三个不同的实根; 记 Cardano 公式中的
		`alpha, beta = r "e"^(+-"i"theta)`, 则三个根是
		<span class="formula">
			`2 * root 3 r cos(theta/3 + varphi)`,
			`quad varphi = 0, (2pi)/3, (4pi)/3`.
		</span>
	</li>
	<li>`Delta = 0` 时, 方程有一个一重实根 `-2 root 3(q//2)`,
		一个两重实根 `root 3(q//2)`.
	</li>
</ol>

<p class="example">
	解方程 `27 x^3 + 54 x^2 - 369 x - 370 = 0`.
</p>

<p class="solution">
	最高次项系数化为 1,
	<span class="formula">
		`x^3 + 2 x^2 - 41/3 x -370/27 = 0`.
	</span>
	令 `x = y - 2/3`,
	<span class="formula">
		`y^3 - 15 y - 4 = 0`.
	</span>
	故 `q/2 = -2`, `p/3 = -5`, `Delta = (q/2)^2 + (p/3)^3 lt 0`, 有三个不
	同实根. 解得
	<span class="formula">
		`alpha = 2 + 11"i" = (2+"i")^3`,
		`quad beta = 2 - 11"i" = (2-"i")^3`.
	</span>
	所以三个实根为 `4, -2-sqrt3, -2+sqrt3`.
	而原方程的根为 `10/3, -8/3-sqrt3, -8/3+sqrt3`.
</p>

<ol class="example">
  <li>化简 `root 3(3+sqrt(275/27)) + root 3(3-sqrt(275/27)) = root 3 2`.</li>
  <li>化简 `root 3(2+sqrt 5) = (1+sqrt 5)/2`.</li>
  <li>化简 `root 3(2+11 "i") + root 3(2-11 "i") = 4`.</li>
</ol>

<ol class="solution">
  <li>
  利用 Cardano 公式
  <span class="formula">
    `root 3(-q/2 + sqrt((q/2)^2 + (p/3)^3))`
    `+ root 3(-q/2 - sqrt((q/2)^2 + (p/3)^3))`,
  </span>
  原式化为方程 `x^3 + 2^(5/3) x - 6 = 0` 的一根. 由于判别式大于 0, 该方程只有一个实根, 观察知该实根等于 `root 3 2`.
  </li>
  <li>
  利用 Cardano 公式,
  <span class="formula">
    `root 3(2+sqrt 5) + root 3(2 - sqrt 5)`
  </span>
  是 `x^3 + 3x - 4` 的唯一实根, 观察知 `x = 1`. 又
  <span class="formula">
    `root 3(2+sqrt 5) root 3(2-sqrt 5) = -1`,
  </span>
  于是由 `u + v = 1`, `u v = -1` 解得 `u, v = (1 +- sqrt 5)/2`.
  其中 `root 3(2+sqrt 5)` 取较大的一个, 即 `(1+sqrt 5)/2`.
  </li>
  <li>表达式含有虚数, 对应的三次方程有三个实根. 怎么办呢? 先注意到 `|2+11"i"| = sqrt(125)`,
    所以 `|root 3 (2+11"i")| = sqrt 5`, 猜测 `(2+"i")^3 = 2+11"i"` 并验证即可.
    于是原式等于 `2+"i"+2-"i" = 4`.
  </li>
</ol>

<h3>四次方程</h3>

<p class="example">
	<b>解四次方程</b> `x^4 + p x^2 + q x + r = 0`.
</p>

<p class="solution">
	设方程左侧可以因式分解为
	<span class="formula">
		`x^4 + p x^2 + q x + r = (x^2 - a x + b)(x^2 + a x + c)`
	</span>
	注意我们已将两个二次因式中的一次项系数设为相反数,
	这是因为它们相乘的结果的三次项系数为零. 比较各次项系数有:
	<span class="formula">`{
		b + c -a^2 = p;
		a(b-c) = q;
		b c = r;
		:}`</span>
	由前两式得
	<span class="formula">
		`2a b = a(a^2 + p) + q`,<br/>
		`2a c = a(a^2 + p) - q`.
	</span>
	代入第三式,
	<span class="formula">
		`4a^2 r = a^2 (a^2 + p)^2 - q^2`,
	</span>
	即
	<span class="formula">
		`a^6 + 2p a^4 + (p^2 - 4r)a^2 - q^2 = 0`.
	</span>
	上式看作关于 `a^2` 的一元三次方程, 取它的任一根 (比如实根),
	就可得到 `b, c` 的值, 进而解两个一元二次方程
	<span class="formula">
		`x^2 - a x + b = 0`, `quad x^2 + a x + c = 0`
	</span>
	得到原方程的根.
</p>

<p class="solution">
  [来自 <a href="https://www.bilibili.com/video/BV1MU4y1s7AK" target="_blank">bilibili@千梓猫鹿</a>]
  一个类似三次方程 Cardano 公式的解法. 设 `x = u + v + w` 是方程的解, 则
  <span class="formula">
    `x^2 = sum u^2 + 2 sum u v`,<br>
    `x^4 = (sum u^2)^2 + 4(sum u^2)(sum u v)`
    `+ 4 sum u^2 v^2 + 8 u v w sum u`,
  </span>
  代入原方程得
  <span class="formula">
    `(sum u^2)^2 + 4 sum u^2 v^2`
    `+ (8 u v w + q) sum u
    + (4 sum u^2 + 2 p) sum u v`
    `+ p sum u^2 + r = 0`.
  </span>
  因此 `x` 是方程的解的充分条件为
  <span class="formula">
  `{
    (sum u^2)^2 + 4 sum u^2 v^2 + p sum u^2 + r = 0;
    8 u v w + q = 0;
    4 sum u^2 + 2 p = 0;
  :}`
  </span>
  化简得到 `u^2, v^2, w^2` 满足的方程组:
  <span class="formula">
  `{
    sum u^2 = -p // 2;
    u^2 v^2 w^2 = (q//8)^2;
    sum u^2 v^2 = (p//4)^2 - r//4;
  :}`
  </span>
  利用 Vieta 定理, 它们是三次方程
  <span class="formula">
    `z^3 + p/2 z^2 + [(p/4)^2 - r/4] z - (q/8)^2 = 0`
  </span>
  的三根. 至此问题化为求解三次方程.
</p>

<p class="example">
  <b>策略1: 两根和等于另外两根和</b>
  解方程 `x^4+6x^3+11x^2+6x-1 = 0`.
</p>

<p class="solution">
  [来自群友 Gzz] 注意到左边可以写成 `(x^2+3x+1)^2-2`.  我注意不到😭
</p>

<div class="solution p">
  待定系数法.
  令 `y = x(x+a)`, 再令方程左边等于 `y^2 + b y -1` `= x^4 + 2a x^3 + (a^2+b) x^2 + a b x -1`,
  于是
  <span class="formula">
    `2a = 6`, `quad a b = 6`, `quad a^2+b=11`.
  </span>
  解得 `a = 3`, `b = 2`.
  后面的处理是容易的.
  <hr>
  一般地, 若四次方程的两根和等于另外两根和, 则它可以分解为 `(x^2+a x+b)(x^2+a x+c) = 0`,
  进而可以采用上面令 `y = x(x+a)` 的换元方法.
</div>

<p class="example">
  <b>策略2: 尝试在 `ZZ` 上分解</b>
  解方程 `x^4 + 5 x^3 + 2 x^2 + 20 x + 16 = 0`.
</p>

<p class="solution">
  假设左边可以分解为 `(x^2 + a x + c)(x^2 + b x + d)`, 则
  <span class="formula">
    `a + b = 5`, `quad a b + c + d = 2`, `quad a d + b c = 20`, `quad c d = 16`.
  </span>
  假设 `c, d` 均为整数, 列举 16 的因子, 发现当 `c = d = 4` 时, 上述方程组有解:
  `a + b = 5`, `a b = -6`.
  于是 `a, b` 是方程 `y^2 - 5 y - 6 = 0` 的两根, `{a, b} = {6, -1}`.
  后面的处理是容易的.
</p>

<p class="example">
  [题源网络] 郭小弟有四個女朋友，恰好一個比一個大兩歲，且他們年齡的乘積是 3465，請問最大的女孩年齡是多少？
</p>

<p class="solution">
  设她们年龄的平均值是 `x`, 则
  <span class="formula">
    `(x+1)(x-1)(x+3)(x-3) = 3465`,
  </span>
  上式可轻松化为 `x^2` 的二次方程, 这就避免了四次方程.
  解得 `x = 8`, 于是四个女朋友的年龄分别是 <span class="box">5, 7, 9, 11</span> 😅.
</p>

<p class="solution">
  即使你不小心设了 `x` 是最小的那个年龄, 得到了下面这样的四次方程:
  <span class="formula">
    `x^4 + 12x^3 + 44x^2 + 48x - 3465 = 0`,
  </span>
  没有关系! 由题意知道方程有两根和等于另外两根和, 故可以换元 `y = x(x+a)`,
  方程化为 `y^2 + b y - 3465 = 0`. 解方程组
  <span class="formula">
    `2a = 12`, `quad a b = 48`, `a^2 + b = 44`,
  </span>
  得到 `a = 6`, `b = 8`.
  先解 `y^2 + 8 y - 3465 = 0` 得 `y = 55, -63`;
  再解 `x(x+6) = y` 得 `x = -3+-sqrt(9+y)`, 其中只有 `x=5` 符合题意.
</p>

<h3>Gauss 引理与 Eisenstein 判别法</h3>

<ol class="remark">
  <b>解高次方程的实用策略</b>
  <li>消去重根. 从 `f(x)` 中约去 `(f(x), f'(x))`,
      得到最多只含一重根的多项式. 最大公因式可用辗转相除法求.
  </li>
  <li>Gauss 引理 (见下文).</li>
  <li>Eisenstein 判别法 (见下文).</li>
</ol>

<ol class="theorem">
  <b>Gauss 引理</b>
  称 `f in ZZ[x]` 是<b>本原多项式</b>, 如果它各系数的最大公约数是 1.
  <li>两个本原多项式的乘积仍是本原多项式.</li>
  <li>若 `f in ZZ[x]` 在 `QQ` 上可约, 那么它也在 `ZZ` 上可约.</li>
  <li>若 `f, g` 都是首一多项式, `f in ZZ[x]`, `g in QQ[x]`, 且 `g | f`, 那么 `g in ZZ[x]`.</li>
</ol>

<ol class="proof">
  <li>设 `f, g in ZZ[x]` 是本原多项式, `h = f g`.
    反设 `h` 不是本原多项式, 则存在素数 `p` 整除它的所有系数.
    由于 `f, g` 本原, 存在最小的整数 `i, j` 使得 `p !| f_i`, `p !| g_j`.
    考虑 `h` 的 `i+j` 次系数
    <span class="formula">
      `h_(i+j) = sum_(k=0)^(i+j) f_k g_(i+j-k)`,
    </span>
    由于所有 `f_k` `(k lt i)` 和 `g_(i+j-k)` `(k gt i)` 都被 `p` 整除, 因此
    <span class="formula">
      `h_(i+j) -= f_i g_j (mod p)`.
    </span>
    然而 `p !| f_i`, `p !| g_j`, 故 `p !| h_(i+j)`, 与假设矛盾.
  </li>
  <li>
    设 `h in ZZ[x]` 在 `QQ` 上可约, 则存在不为常数的 `f_1, g_1 in QQ[x]` 使得 `h = f_1 g_1`.
    适当选取有理数 `a, b`, 可使 `f := a f_1 in ZZ[x]` 和 `g := b g_1 in ZZ[x]` 都是本原多项式.
    由 1. 知, `f g` 也是本原多项式, 因此 `h` 只能是 `f g` 的整数倍, 从而 `h` 在 `ZZ` 上可约.
  </li>
  <li>由 2. 知存在 `k in QQ` 使得 `f = k g h`, 其中 `k g in ZZ[x]`, `h in ZZ[x]`.
    但 `f, g` 首一, 为使 `h` 的首项系数为整数必须有 `k = +-1`. 所以 `g in ZZ[x]`.
  </li>
</ol>

<ol class="theorem">
  设 `f(x) = sum_(k=0)^n f_k x^k in ZZ[x]`.
  <li><b>有理根由首尾系数决定</b>
    如果 `c//d` 是 `f` 的有理根, 且为最简分数. 那么
    `c | f_0`, `d | f_n`, 即分子整除常数项, 分母整除首项系数.
    <br>
    推论1: `f` 首一时, 它的有理根只能是整数.
    <br>
    推论2: 设 `a, n` 为正整数, 则 `root n a` 不是整数, 就是无理数.
  </li>
  <li>
    <b>Eisenstein 判别法</b>
    设 `f` 的次数 `n ge 2`, 且存在素数 `p` 整除 `f` 首项系数以外的每个系数, 且 `p^2` 不整除常数项,
    换言之:
    <span class="formula">
      `p !| f_n`,
      `quad p^2 !| f_0`,
      `quad p | f_i`
      `quad (AA i lt n)`,
    </span>
    则 `f` 在 `QQ` 上不可约, 更不存在有理根.
  </li>
</ol>

<ol class="proof">
  <li>
    将有理根 `c//d` 代入 `f`:
    <span class="formula">
      `sum_(k=0)^n f_k c^k d^(n-k) = 0`.
    </span>
    等式两边分别模 `c` 可得
    <span class="formula">
      `f_0 d^n -= 0 (mod c)`.
    </span>
    但 `(c, d) = 1`, 故 `c | f_0`.
    同理两边模 `d` 可得 `d | f_n`.
  </li>
  <li>先证 `f` 不存在有理根. 假设 `c//d` 是一个有理根 (最简分数),
    1. 中的等式两边模 `p` 得到 `f_n c^n -= 0 (mod p)`.
    但已知 `p !| f_n`, 所以 `p | c`.
    现在等式两边模 `p^2`. 由于 `n ge 2`, 除了常数项外各项均被 `p^2` 整除, 得到
    <span class="formula">
      `f_0 d^n -= 0 (mod p^2)`.
    </span>
    由于 `c, d` 互素, `p !| d`, 上式推出 `p^2 | f_0`, 矛盾.
  </li>
  <li>
    现在证 `f` 实际上在 `QQ` 中不可约.
    反设 `f` 可约, 则由 Gauss 引理它也在 `ZZ` 上可约: `f = g h`.
    其中 `g` 是 `s` 次多项式, `h` 是 `n - s` 次多项式.
    由 `f_0 = g_0 h_0` 和 `p | f_0`, `p^2 !| f_0` 得到 `p` 能且只能整除 `g_0, h_0` 中的一个.
    不妨设 `p | g_0`, `p !| h_0`, 那么:
    <span class="formula">
      `f_1 = g_0 h_1 + g_1 h_0 -= g_1 h_0 (mod p)`.
    </span>
    但 `f_1 -= 0 (mod p)`, 所以 `p | g_1`.
    一般地, 设 `k le s lt n`, 且对任意 `j lt k` 成立 `p | g_j`, 则
    <span class="formula">
      `g_k h_0 = f_k - sum_(j=0)^(k-1) g_j h_(k-j)`
      `-= 0 (mod p)`.
    </span>
    从而 `p | g_k`.
    由数学归纳法, `p` 整除 `g` 的各项系数, 从而整除 `f` 的各项系数, 这与 `p !| f_n` 矛盾.
  </li>
</ol>

<ol class="example">
  设 `p` 为素数,
  <li>`n ge 2` 时, 由 Eisenstein 判别法, `x^n +- p` 在 `QQ` 上不可约.</li>
  <li>`f(x) = (x^p-1)/(x-1)`
    `= 1 + x + cdots + x^(p-1)` 在 `QQ` 上不可约.</li>
</ol>

<p class="proof">
  只证 2. 令 `y = x-1`, 则 `f(x) = ((y+1)^p - 1) // y`,
  这也是多项式, 且首项系数为 1, 常数项为 `p`, 且中间各项都被 `p` 整除.
  由 Eisenstein 判别法知道它在 `QQ` 上不可约.
</p>

<p class="remark">
  判断 `ZZ` 上多项式不可约的另一个方法是对素数 `p` 取模.
  如果取模后的多项式不可约, 则原多项式也不可约.
  这引出下一节的内容.
</p>

<h3>有限域上的不可约多项式</h3>

<ol class="theorem">
  <b>有限域上不可约多项式的结构</b>
  考虑有限域 `bbb F_q`, `q` 为素数幂.
  用 `Omega_n` 表示 `bbb F_q[x]` 中所有 `n` 次首一不可约多项式的集合.
  <li>`x^(q^n) - x = prod_(f in Omega_d; d | n) f(x)`.</li>
  <li>记 `N(n) = |Omega_n|`, 则 `q^n = sum_(d | n) d N(d)`.</li>
  <li>`N(n) = 1/n sum_(d | n) q^d mu(n//d)`.</li>
</ol>

<ol class="proof">
  <li>首先任意 `f in Omega_d` 的根落在域 `bbb F_(q^d)` 中,
    满足 `a^(q^d) = a`, 所以 `a` 也是 `F = x^(q^n) - x` 的根.
    <br>
    反之若 `a` 是 `F` 的根, 则存在最小正整数 `d` 使得 `a^(q^d) = a`,
    即 `a in bbb F_(q^d)`, `a` 是某个 `f in Omega_d` 的根.
    注意 `bbb F_(q^d)` 是 `bbb F_q` 到 `bbb F_(q^n)` 的中间域, 所以扩张次数 `d | n`.
  </li>
  <li>利用 1. 将 `x^(q^n) - x` 拆解为不可约多项式的乘积, 然后比较两边次数.</li>
  <li>利用 Möbius 反演.</li>
</ol>

<p class="corollary" id="the-fp-irreducible">
  <b>有限域上判定不可约多项式的 Rabin 判别法</b> [来自群友 stupidpig]
  设 `p` 为素数, `n` 次多项式 `f(x) in bbb F_p[x]` 不可约当且仅当 `f | x^(p^n) - x`,
  且对 `n` 的任意素因子 `q` 成立 `gcd(f, x^(p^(n//q)) - x) = 1`.
  该判别法的时间复杂度是 `O((n log n log p)^2)`.
</p>

<ol class="proof enum">
  <li>
    由公式
    <span class="formula">
      `F_n(x) := x^(p^n) - x`
      `= prod_(g in Omega_d; d | n) g(x)`
      `= prod_(g in Omega_n) g(x) prod_(g in Omega_d; d | n; d lt n) g(x)`
      `:= Pi_1 * Pi_2`.
    </span>
    知道, `n` 次多项式 `f` 不可约当且仅当它是 `F_n` 的因子, 且与 `Pi_2` 互素.
    为了使 `gcd(f, Pi_2) = 1`, 只需对 `n` 的每个素因子 `q` 成立
    <span class="formula">
      `gcd(f, F_(n//q)) = 1`.
    </span>
    这是因为 `F_(n//q)` 由所有次数 `d | (n//q)` 的首一不可约多项式组成,
    因此事实上 `prod_(q 是素数; q | n) F_(n//q)` 和 `Pi_2` 具有相同的不可约因式,
    只不过前者的因式有重复而已.
  </li>
  <li>
    <ol>
      <li>
        预处理步骤: 枚举 `n` 的素因子花费时间 `O(sqrt n)`, 和后面的计算量相比可以忽略不计.
      </li>
      <li>
        使用快速幂验证同余 `x^(p^n) -= x (mod f)` 需要做 `O(log(p^n)) = O(n log p)` 次多项式乘法和模运算.
        借助快速 Fourier 变换 (FFT), 多项式乘法和模运算均可以在 `O(n log n)` 次域运算中完成.
        每次域运算的时间以 `O(log p)` 计算.
        这一步的总时间是 `O(n^2 log n log^2 p)`.
      </li>
      <li>
        gcd 部分. 先求 `x^(p^(n//q)) mod f` 将它的次数降到 `n` 以内.
        和第一步一样, 花费时间 `O(n^2 log n log^2 p)`.
        接下来求两个不超过 `n` 次多项式的 gcd, 需要做 `O(log n)` 次多项式模运算,
        花费时间 `O(n log^2 n log p)`, 和前一项相比可以忽略不计.
        由于 gcd 部分要对 `n` 的所有素因子进行, 而 `n` 的素因子个数少于 `log n`,
        所以 gcd 部分花费时间 `O((n log n log p)^2)`.
      </li>
    </ol>
  </li>
</ol>

<p class="example">
  <b>区分“有根”与“可约”</b>
  [来自群友 rei]
  注意, 如果对 `a = 0, cdots, p-1` 均有 `f(a) != 0`, 只能说明 `f` 在 `bbb F_p` 上没有根,
  不能说明它不可约. 比如: `x^5 + x + 1` 显然在 `bbb F_2` 上没有根,
  因为它的常数项为 1, 且系数为 1 的项有奇数个, 即 `f(0) = f(1) = 1`.
  但是它在 `ZZ` 上可约, 从而在 `bbb F_2` 上也是可约的:
  <span class="formula">
    `x^5 + x + 1`
    `= (x^3 - x^2 + 1)(x^2 + x + 1)`.
  </span>
  当然, 若 `f` 的次数 `le 3`, 则此法奏效: `f` 不可约当且仅当它没有根.
</p>

<ol class="example">
  [来自群友 幂零群, Fran]
  考虑 `bbb F_2` 上的多项式 `p_N(x) = x^N + x + 1`, `N` 为正整数.
  手工验证 `N = 1, 2, 3, 4` 时 `p_N` 均不可约.
  问 `N = 2^n`, `n ge 3` 时, `p_N` 都可约吗?
  下面给出 `n ge 3` 为奇数以及 `n -= 2 (mod 4)` 时的证明:
  <li>
    当 `N = 3n+2` 时, `p_2 = x^2+x+1` 整除 `p_N`;
    <br>
    当 `N = 7n+3` 时, `p_3 = x^3+x+1` 整除 `p_N`;
    <br>
    当 `N = 15n+4` 时, `p_4 = x^4+x+1` 整除 `p_N`.
  </li>
  <li>当 `N = 2^n`, `n` 为奇数时, `p_2 = x^2+x+1` 整除 `p_N`.
    <br>
    当 `N = 2^n`, `n = 4k+2` 时, `p_4 = x^4+x+1` 整除 `p_N`.
  </li>
</ol>

<ol class="proof">
  <li>
    事实上 `p_2 | x^3 - 1`.
    进一步对任意 `n` 有 `x^3 - 1| x^(3n)-1 = x^(3n)+1`.
    因此
    <span class="formula">
      `p_N -= x^(3n+2) + x^2`
      `-= x^2(x^(3n) + 1) -= 0 (mod p_2)`.
    </span>
    同理, 利用 `p_3 | x^7 - 1` 和 `p_4 | x^15-1` 可以推出后面两个结论.
    (`p_3` 是三次不可约多项式, 它的根属于 `bbb F_(2^3)`, 必定满足 `x^8 = x`; `p_4` 同理).
  </li>
  <li>
    因为 `n` 为奇数时 `N = 2^n -= (-1)^n -= -1 -= 2 (mod 3)`, 所以 `p_2` 整除 `p_N`.
    又因为 `n = 4k+2` 时 `N = 2^(4k+2) -= 4 * 16^k -= 4 (mod 15)`, 所以 `p_4` 整除 `p_N`.
  </li>
</ol>

<h2>对称多项式</h2>

<p class="definition">
	若一个 `n` 元代数式 `f(x_1, x_2, cdots, x_n)` 对任意实数 `t` 满足
	<span class="formula">
		`f(t x_1, t x_2, cdots, t x_n) = t f(x_1, x_2, cdots, x_n)`,
	</span>
	就称它为 `n` 元<b>齐次式</b>.
	齐次的 `n` 元多项式称为 `n` 元<b>齐次多项式</b>.
	容易知道, 一个多项式是齐次的当且仅当它的各项次数都相等, 如
	`x^3 - 2x^2 y` 就是一个齐次多项式.
</p>

<ol class="definition">
	若一个 `n` 元代数式 `f(x_1, x_2, cdots, x_n)` 满足:
	<li>交换其中任意两个字母 `x_i`, `x_j` 后都保持不变, 即
		<span class="formula">
			`f(x_1, cdots, x_i, cdots, x_j, cdots, x_n)`
			`= f(x_1, cdots, x_j, cdots, x_i, cdots, x_n)`,
		</span>
		就称它为 `n` 元<b>对称式</b>.
	</li>
	<li>交换其中任意两个字母 `x_i`, `x_j` 后恰好变为原来的 -1 倍, 即
		<span class="formula">
			`f(x_1, cdots, x_i, cdots, x_j, cdots, x_n)`
			`= -f(x_1, cdots, x_j, cdots, x_i, cdots, x_n)`,
		</span>
		就称它为 `n` 元<b>交代式</b>.
	</li>
	<li>将字母 `x_1, x_2, cdots, x_(n-1), x_n` 分别换成 `x_2, x_3, cdots, x_n, x_1` 后保持不变, 即
		<span class="formula">
			`f(x_1, x_2, cdots, x_(n-1), x_n)`
			`= f(x_2, x_3, cdots, x_n, x_1)`,
		</span>
		就称它为 `n` 元轮换式. 显然对称式必为轮换式.
	</li>
	对称的 (交代的, 轮换的) `n` 元多项式分别称为 `n` 元 <b>对称多项式
		(symmetric polynomial)</b>
	(<b>交代多项式</b>, <b>轮换多项式</b>).
</ol>

<ol class="example">
  <li>对称式的例子: `(x+y)/(x y)`, `x+y`, `x y`, `x^2 + y^2 + z^2`, `x y+y z+z x`.</li>
  <li>交代式的例子: `(x-y)/(x+y)`, `x-y`, `(x-y)(y-z)(z-x) = |1, 1, 1; x, y, z; x^2, y^2, z^2|`.</li>
  <li>轮换式的例子: `x^2 y + y^2 z + z^2 x`.</li>
</ol>

<h3>初等对称多项式</h3>

<p class="definition">
  <b>初等对称多项式 (基本对称多项式, elementary symmetric polynomial)</b>
  关于 `n` 个变元 `x_1, cdots, x_n` 的初等对称多项式定义为
	<span class="formula">
		`sigma_i(x_1, cdots, x_n) = sum_(C sube N, |C| = i) prod_(j in C) x_j`,
		`quad i = 0, 1, cdots, n`.
	</span>
	其中 `N = {1, 2, cdots, n}`. 上式也可以写成
	<span class="formula">
		`sigma_0 = 1`,
		`quad sigma_1 = sum_i x_i`,
		`quad sigma_2 = sum_(i lt j) x_i x_j`,
		`quad sigma_3 = sum_(i lt j lt k) x_i x_j x_k`,
		`quad cdots`,
		`quad sigma_n = x_1 x_2 cdots x_n`.
	</span>
  初等对称多项式是每个变元最高次数为 1 的齐次对称多项式, 其中 `sigma_i`
  的次数为 `i`, 它等于 `x_1` 到 `x_n` 中任取 `i` 个变量相乘的所有情况之和.
</p>

<p class="theorem">
	<b>Vieta 定理</b>
	`n` 次多项式 `f(x) = sum_(i=0)^n a_i x^i` 的全部 `n` 个根记为 `x_i`,
	`i = 1, 2, cdots, n`.  我们有根与系数的关系:
	<span class="formula">
		`sigma_i(x_1, cdots, x_n) = (-1)^i a_(n-i)/a_n`,
		`quad i = 0, 1, cdots, n`.
	</span>
</p>

<p class="example">
  <b>初等对称多项式的生成函数</b>
  观察下式:
  <span class="formula">
    `(1+x_1)(1+x_2) cdots (1+x_n)`
    `= 1 + sigma_1 + sigma_2 + cdots + sigma_n`.
  </span>
  如果将每个 `x_i` 都乘以 `t`, 就得到
  <span class="formula">
    `prod_(i=1)^n (1 + x_i t)`
    `= sum_(i=0)^n sigma_i t^i`,
  </span>
  这是一个多项式, `i` 次项系数恰为 `sigma_i`, 因此它是生成函数.
</p>


<p class="theorem">
	<b>对称多项式基本定理</b>
	任一 `n` 元对称多项式 `f(x_1, x_2, cdots, x_n)`
	可以唯一表示为初等对称多项式 `sigma_i^((n)) := sigma_i(x_1, x_2, cdots, x_n)`,
	`i = 1, 2, cdots, n` 的多项式.
</p>

<p class="proof">
	首先注意, 令 `x_n = 0`, 就能将任一 `n` 元对称多项式降为 `n-1`
  元对称多项式. 特别在 `sigma_i^((n))` 中令 `x_n = 0`,
  就得到 `sigma_i^((n-1))`:
	<span class="formula">
		`sigma_i(x_1, cdots, x_(n-1), 0) = sigma_i(x_1, cdots, x_(n-1))`.
	</span>
	对 `n` 进行归纳证明. `n = 1` 时显然成立. 设 `n gt 1`, 且结论对 `n-1`
	成立.  由归纳假设, `f|_(x_n=0) := f(x_1, cdots, x_(n-1), 0)` 是
  `n-1` 元对称多项式,
	它能表示为
	<span class="formula">
		`f|_(x_n=0)`
		`= p(sigma_1^((n-1)), cdots, sigma_(n-1)^((n-1)))`,
	</span>
	其中 `p` 是一个多项式.  令
	<span class="formula">
		`g(x_1, cdots, x_n)`
		`= p(sigma_1^((n)), cdots, sigma_(n-1)^((n)))`,
	</span>
  则
  <span class="formula">
    `{:g|_(x_n=0) = {:f|_(x_n=0)`.
  </span>
	令 `h = f - g`, 有 `h|_(x_n=0) = 0`, 这说明 `x_n | h`.
  由对称性, `sigma_n^((n)) = x_1 x_2 cdots x_n | h`.
	如果 `h` 的次数不小于 `n`, 就令 `f_1 = h//sigma_n`, 代替原来的 `f`
	进行操作, 直到得到的 `h` 次数小于 `n`. 这时由
	`sigma_n^((n)) | h` 知 `h -= 0`.
  零多项式当然是初等对称多项式的多项式, 证毕.
</p>

<ol class="algorithm">
  <b>`n` 元对称多项式的标准化</b>
  [来自 <a href="https://www.bilibili.com/video/BV19f4y137mJ" target="_blank">bilibili@凡人忆拾</a>]
  <li>
    <b>记号</b>
    设 `n` 元 `m` 次对称多项式的变元为 `x_1, cdots, x_n`.
    用记号 `[k_s, cdots, k_1, k_0]` 表示一个对称求和, 其中有 `k_0`
    个变元为 `0` 次, `k_1` 个变元为 `1` 次, `cdots`, `k_s` 个变元为 `s` 次,
    满足
    <span class="formula">
      `k_0 + k_1 + cdots + k_s = n`,<br>
      `0 * k_0 + 1 * k_1 + cdots + s * k_s = m`.
    </span>
    比如
    <span class="formula">
      `[1, 1, 0, 2] = sum_"sym" x_1^3 x_2^2 x_3^0 x_4^0`,
    </span>
    其中 3 次和 2 次的变元各有一个, 0 次的变元有两个.<br>
    又比如, `n` 元初等对称多项式 `sigma_k = [k, n-k]`,
    因为它的每一项都是 `k` 个变量的一次方的乘积.
  </li>
  <li>
    <b>乘法法则</b>
    我们的目标是降低 `f = [color(red)(k_s), cdots, k_0]` 中的最高次方 `k_s`,
    为此, 将它与另一个多项式比较:
    <span class="formula">
      `g = [color(red)(k_s + k_(s-1)), cdots, k_0]`.
    </span>
    考虑乘积 `sigma_k * g`, `k = k_s`.
    一个对称多项式乘上 `sigma_k`, 效果是给它的 `k` 个变元 `x_(i_1), cdots x_(i_k)` 升阶.
    其中 `i_1, cdots, i_k` 取遍 `1` 到 `n` 的所有组合.
    假如我们只给 `g` 的 `k` 个最高次变元升阶, 得到的就是多项式 `f`, 因此 `f` 是 `sigma_k * g`
    的结果的一部分:
    <span class="formula">
      `sigma_k * g = f + cdots`.
    </span>
    一般地, 假如我们给 `g` 的任意 `k` 个变元升阶, 得到多项式 `h = [a_s, cdots, a_0]`,
    其中 `a_s le k`, 等号成立当且仅当 `h = f`.
    则 `h` 在 `sigma_k * g` 中的系数等于 `(a_s;b_s)cdots(a_0;b_0)`.
    其中 `(a_i; b_i)` 表示在 `h` 的 `a_i` 个次数为 `i` 的变元中, 有 `b_i`
    个是升阶得到的, 其余的次数原本就等于 `i`, 保持不变.
    总之
    <span class="formula">
      `sigma_k * g = sum (a_s;b_s) cdots (a_0;b_0) [a_s, cdots, a_0]`.
    </span> 
    上式对 `g` 的一切可能升阶方案求和.
  </li>
</ol>

<p class="example">
  化简 4 元对称式 `-[1, 1, 0, 2] - 2[1, 3, 0] + [2, 1, 1]`.
</p>

<p class="solution">
  应用乘法法则:<br>
  `[1, 1, 0, 2]`
  `= sigma_1[2, 0, 2] - (color(red)2;0)(color(red)1;1)(color(red)1;0)[2, 1, 1]`
  `= sigma_1[2, 0, 2] - [2, 1, 1]`,<br>
  `[2, 1, 1] = sigma_2[3, 1] - (color(red)1;1;)(color(red)3;1)(color(red)0;0)[1, 3, 0]`
  `= sigma_2 sigma_3 - 3[1, 3, 0]`,<br>
  `[2, 0, 2]`
  `= sigma_2[2, 2] - (color(red)1;1)(color(red)2;1)(color(red)1;0)[1, 2, 1] - (color(red)4;2)(color(red)0;0)[4,0]`
  `= sigma_2^2 - 2[1, 2, 1] - 6 sigma_4`,<br>
  `[1, 3, 0] = sigma_1[4, 0] = sigma_1 sigma_4`,<br>
  `[1, 2, 1] = sigma_1[3, 1] - (color(red)4;1)(color(red)0;0)[4, 0] = sigma_1 sigma_3
  - 4 sigma_4`,<br>
  将上面材料代入化简得
  <span class="formula">
    `-[1, 1, 0, 2] - 2[1, 3, 0] + [2, 1, 1]`
    `= 2σ_1^2 σ_3 - σ_1 σ_2^2 - 10 σ_1 σ_4 + 2 σ_2 σ_3`.
  </span>
</p>

<div class="playground" type="textarea" value="-[1,1,0,2]-2*[1,3,0]+[2,1,1]">
<p>注: 下面程序的结果需要做一些多项式运算将它化简.</p>
<script type="text">
// 枚举多重集 s 的 k-子集
// 例: [2,2] 的 2-子集有 3 个: [2,0],[1,1],[0,2]
// [1,2,3] 的 3-子集有 6 个: [0,0,3],[0,1,2],[0,2,1],[1,0,2],[1,1,1],[1,2,0]
var submultisets = (s, k) => {
  const n = s.length
  const res = []
  const buf = []
  const dfs = (depth, k) => {
    if (depth === n && k === 0) return res.push(buf.slice())
    for (let i = 0; i <= k && i <= s[depth]; ++i) {
      buf[depth] = i
      dfs(depth+1, k-i)
    }
  }
  dfs(0, k)
  return res
}

// 组合数 n 选 k
var comb = (n, k) => {
  k = Math.min(k, n-k)
  let res = 1
  for (let i = 1; i <= k; ++i) {
    res *= (n - i + 1) / i
  }
  return res
}

// 对称多项式的标准化
// 注意先反转再传入
var stdsym = (p, { paren = true, reverse = true, sym = 's' } = {}) => {
  p = p.slice()
  if (reverse) p = p.reverse()
  const n = p.reduce((x, y) => x + y, 0) // 变元数
  if (p.length <= 2) return p[1] ? sym + p[1] : '1'
  const k = p[p.length-1]
  p[p.length-2] += k
  p.pop()
  const res = [[sym, k, '*', stdsym(p, { paren: true, reverse: false, sym })].join('')]
  submultisets(p, k).forEach(s => {
    const a = p.slice()
    let coef = 1
    if (s[s.length-1] === k) return // 排除转化前的多项式
    s.forEach((v, i) => {
      if (v > 0) {
        a[i] -= v
        a[i+1] = (a[i+1] || 0) + v
      }
      if (i > 0) coef *= comb(a[i], s[i-1])
    })
    // console.log(coef, a, s)
    res.push([coef, '*', stdsym(a, { paren: true, reverse: false, sym })].join(''))
  })
  if (paren) return '(' + res.join(' - ') + ')'
  return res.join(' - ')
}

module.exports = function (str) {
  return str.replace(/\[.*?\]/g, ($0) => {
    const p = Playground.parse($0)
    return stdsym(p)
  })
}
</script>
</div>

<h3>Newton-Girard 公式</h3>

<p class="theorem">
  <b>Newton-Girard 公式</b>
  设 `S_i` 是 `n` 元 `i` 次对称多项式:
  <span class="formula">
    `S_i = sum_(j=1)^n x_j^i`, `quad i = 0, 1, 2, cdots`.
  </span>
  `sigma_i` 是 `n` 元 `i` 次初等对称多项式, 则
  <span class="formula">
  `S_i = {
    sum_(j=1)^n (-1)^(j-1) sigma_j S_(i-j), if i ge n;
    sum_(j=1)^(i-1) (-1)^(j-1) sigma_j S_(i-j)
    + (-1)^(i-1) sigma_i * i, if i lt n;
  :}`
  </span>
  需要注意, 一般来说 `i lt n` 时 `S_0` 被认为是未定义的,
  因此最后一项被单独提出.
</p>

<ol class="proof">
  利用 `sigma_0 = 1`, 我们只需证明公式的等价形式:
  <span class="formula">
    `{
    sum_(j=0)^n (-1)^j sigma_j S_(i-j) = 0, if i ge n;
    sum_(j=0)^(i-1) (-1)^j sigma_j S_(i-j) + (-1)^i sigma_i * i = 0,
    if i lt n;
    :}`
  </span>
  <li>
  `i ge n` 时, 设多项式 `f(x) = sum_(j=0)^n a_(n-j) x^(n-j)`
  的 `n` 个根恰为 `x_1, cdots, x_n`, 且 `a_n = 1`.
  于是
  <span class="formula">
    `sum_(j=0)^n a_(n-j) S_(i-j)`
    `= sum_(j=0)^n a_(n-j) sum_(k=1)^n x_k^(i-j)`
    `= sum_(k=1)^n x_k^(i-n) f(x_k) = 0`.
  </span>
  由 Vieta 定理, `a_(n-j) = (-1)^j sigma_j a_n`, 代入上式得
  <span class="formula">
    `sum_(j=0)^n (-1)^j sigma_j S_(i-j) = 0`.
  </span>
  </li>
  <li>
  现在设 `i lt n`. 对 `k = n-i gt 0` 作归纳, 设结论对任意 `k' lt k`
  已经成立.
  用 `f_(n,i)(x_1, x_2, cdots, x_n)` 表示 Newton-Girard 公式 (等价形式)
  的左边, 因为
  <span class="formula">
    `sigma_j(x_1, cdots, x_(n-1), 0) = sigma_j(x_1, cdots, x_(n-1))`,
    <br/>
    `S_j(x_1, cdots, x_(n-1), 0) = S_j(x_1, cdots, x_(n-1))`.
  </span>
  有
  <span class="formula">
    `f_(n,i)(x_1, cdots, x_(n-1), 0)`
    `= f_(n-1,i)(x_1, cdots, x_(n-1))`.
  </span>
  由归纳假设, 上式右边等于零, 这说明 `x_n | f_(n,i)`.
  由 `f_(n,i)` 的对称性, `sigma_n = x_1 x_2 cdots x_n | f_(n,i)`.
  注意到 `f_(n,i)` 的次数不超过 `i`, 且 `i lt n`, 我们得到
  `f_(n,i) = 0`. 证毕.
  </li>
</ol>

<p class="example">
  当变元数 `n = 3` 时, Newton-Girard 公式写为
  <span class="formula">
  `{
    S_1 = sigma_1;
    S_2 = sigma_1 S_1 - 2 sigma_2;
    S_3 = sigma_1 S_2 - sigma_2 S_1 + 3 sigma_3;
  :}`
  </span>
</p>

<p class="example">
	当变元数 `n = 3` 时, `a = b = c` 当且仅当 `S_2 = sigma_2`, 即
	<span class="formula">
		`a^2+b^2+c^2 = a b+b c+c a`.
	</span>
	这是因为配方得:
	<span class="formula">
		`a^2+b^2+c^2-(a b+b c+c a)`
		`= (a-b)^2/2 + (b-c)^2/2 + (c-a)^2/2`.
	</span>
</p>

<p class="example">
  设 `f(x) = (x-1)(x-2)(x-3)` `= x^3 - 6x^2 + 11x - 6`.
  分别求 `sigma_i` 和 `S_i`, `i in {1, 2, 3, -1, -2, -3}`.
</p>

<p class="solution">
  多项式的三个根记为 `a, b, c`, 于是
  <span class="formula">
    `a+b+c = sigma_1 = 6`,<br/>
    `ab+bc+ca = sigma_2 = 11`,<br/>
    `abc = sigma_3 = 6`,<br/>
    `1/a+1/b+1/c = sigma_(-1) = sigma_2//sigma_3 = 11/6`,<br/>
    `1/(ab) + 1/(bc) + 1/(ca) = sigma_(-2) = sigma_1//sigma_3
    = 1`,<br/>
    `1/(abc) = sigma_(-3) = 1//sigma_3 = 1/6`.
  </span>
  用 Newton-Girard 公式计算:
  <span class="formula">
    `a+b+c = S_1 = sigma_1 = 6`,<br/>
    `a^2+b^2+c^2 = S_2 = sigma_1 S_1 - 2 sigma_2 = 14`,<br/>
    `a^3+b^3+c^3 = S_3 = sigma_1 S_2 - sigma_2 S_1 + 3 sigma_3 = 36`,<br/>
    `1/a+1/b+1/c = S_(-1) = sigma_(-1) = 11/6`,<br/>
    `1/a^2+1/b^2+1/c^2 = S_(-2) = sigma_(-1) S_(-1) - 2 sigma_(-2)
    = 49/36`,<br/>
    `1/a^3+1/b^3+1/c^3 = S_(-3) = sigma_(-1) S_(-2) - sigma_(-2)
    S_(-1) + 3 sigma_(-3) = 251/216`.
  </span>
</p>

<p class="example">
	<span class="formula">
		`(a x_1+b)(a x_2+b) = a^2 sigma_2 + a b sigma_1 + b^2`,<br/>
		`(a x_1+b)(a x_2+b)(a x_3+b) = a^3 sigma_3 + a^2 b sigma_2 + a b^2
		sigma_1 + b^3`.
	</span>
</p>

<p class="example">
	[题源 学而思] 解方程组
	<span class="formula">`{
		x - y + z - w = 2;
		x^2 - y^2 + z^2 - w^2 = 6;
		x^3 - y^3 + z^3 - w^3 = 20;
		x^4 - y^4 + z^4 - w^4 = 66;
	:}`</span>
</p>

<p class="solution">
	注意到方程组的对称性, 故使用对称多项式进行换元: 令
	<span class="formula">
		`m = x + z`, `quad n = x z`,<br/>
		`u = y + w`, `quad v = y w`,
	</span>
	于是
	<span class="formula">
		`m^2 = x^2 + z^2 + 2n`,<br/>
		`m^3 = x^3 + z^3 + 3m n`,<br/>
		`m^4 = x^4 + z^4 + 4m^2 n - 2n^2`.
	</span>
	关于 `u^2, u^3, u^4` 也有类似的公式; 代入原方程组得到
	<span class="formula">`{
		m = u + 2, (1);
		m^2 - 2n = u^2 - 2v + 6, (2);
		m^3 - 3m n = u^3 - 3u v + 20, (3);
		m^4 - 4m^2 n + 2n^2 = u^4 - 4u^2 v + 2v^2 + 66, (4);
	:}`</span>
	将 (1) 代入 (2) 得
	<span class="formula">
		`n = 2u + v - 1`. `quad (5)`
	</span>
	将 (1) (5) 代入 (3) 得
	<span class="formula">
		`u = 2(v+1)`. `quad (6)`
	</span>
	再联系 (5),
	<span class="formula">
		`n = 5v + 3`. `quad (7)`
	</span>
	将 (1) (6) (7) 代入 (4) 得
	<span class="formula">
		`v = 0`, `u = 2`, `n = 3`, `m = 4`.
	</span>
	最终得
	<span class="formula">
		`{x, z} = {1, 3}`, `{y, w} = {0, 2}`.
	</span>
</p>

<ol class="example">
	<li>设 `n` 为整数, 记 `x_n = t^n+t^-n`, 显然 `x_n = x_(-n)`, 即 `x`
		关于 `n` 是偶函数.  又容易验证 `x_m x_n = x_(m+n) + x_(m-n)`,
		特别取 `m = 1`, `n = n-1` 有
		<span class="formula">
			`x_n = x_1 x_(n-1) - x_(n-2)`.
		</span>
		从而任意 `x_n` 都是 `x_1` 的多项式, 记 `x_1 = x`,
		这一系列多项式定义为
		<span class="formula">`x_n = {
			2, if n = 0;
			x, if n = 1;
			x x_(n-1) - x_(n-2), if n ge 2;
		:}`</span>
	</li>
	<li>记 `y_n = t^n-t^-n`, 则 `y` 关于 `n` 是奇函数.
		又 `x_m y_n = y_(m+n) - y_(m-n)`, 取 `m=1`, `n = n-1` 有
		<span class="formula">
			`y_n = x_1 y_(n-1) - y_(n-2)`.
		</span>
		则 `w_n := y_n//y_1` 是 `x := x_1` 的多项式.  可以定义
		<span class="formula">`w_n = {
			0, if n = 0;
			1, if n = 1;
			x w_(n-1) - w_(n-2), if n ge 2;
		:}`</span>
	</li>
	两种多项式的迭代步骤相同, 而初值不同.
</ol>

<table>
	<tr>
		<td>`n`</td>
		<td>`x_n`</td>
		<td>`w_n`</td>
	</tr>
	<tr>
		<td>`0`</td>
		<td>`2`</td>
		<td>`0`</td>
	</tr>
	<tr>
		<td>`1`</td>
		<td>`x`</td>
		<td>`1`</td>
	</tr>
	<tr>
		<td>`2`</td>
		<td>`x^2-2`</td>
		<td>`x`</td>
	</tr>
	<tr>
		<td>`3`</td>
		<td>`x^3-3x`</td>
		<td>`x^2-1`</td>
	</tr>
	<tr>
		<td>`4`</td>
		<td>`x^4-4x^2+2`</td>
		<td>`x^3-2x`</td>
	</tr>
	<tr>
		<td>`5`</td>
		<td>`x^5-5x^3+5x`</td>
		<td>`x^4-3x^2+1`</td>
	</tr>
</table>

<h3>Lagrange 预解式</h3>

<p>[来自 <a href=https://zhuanlan.zhihu.com/p/582315546" target="_blank">Hilbert@知乎</a>]</p>

<p class="definition">
  <b>预解式</b>
  设 `f(x_1, cdots, x_n)` 是一个 `n` 元多项式,
  `sigma, tau in S_n` 是 `1` 到 `n` 的排列.  如果
  <span class="formula">
    `f(x_(sigma(1)), cdots, x_(sigma(n))) = f(x_(tau(1)), cdots, x_(tau(n)))`,
  </span>
  则称 `sigma` 与 `tau` 是等价的, 显见 `S_n` 商掉这个等价关系后为一群 `G := { f_1, cdots, f_m }`.
  当 `f` 为对称多项式时, `m = 1`; `f` 为交代式时, `m = 2`.
  <br>
  构造一个关于 `y` 的一元多项式
  <span class="formula">
    `g(y) = prod_(i=1)^m (y - f_i)`.
  </span>
  由韦达定理知道, `g(y)` 的系数是 `f_i` 的初等对称多项式, 从而是 `x_1, cdots, x_n` 的对称多项式.
  <br>
  现在设 `x_1, cdots, x_n` 是 `n` 次方程的 `n` 个根, 则 `f(x_1, cdots, x_n)`
  称为原方程的一个<b>预解式</b>, `g(y) = 0` 称为原方程的一个<b>预解方程</b>.
</p>

<p class="definition">
  <b>Lagrange 预解式</b>
  设 `zeta` 是 `n` 次本原单位根, 则下面的 `n` 个多项式称为 <b>Lagrange 预解式</b>:
  <span class="formula">
    `L_i(x_1, cdots, x_n)` `:= sum_(j=0)^(n-1) zeta^(i j) x_(j+1)`,
    `quad i = 0, cdots, n-1`.
  </span>
  假如知道 `L_0, cdots, L_(n-1)` 的值, 通过解线性方程组就可以得到 `x_1, cdots, x_n` 的值:
  <span class="formula">
    `x_(j+1) = 1/n sum_(i=1)^(n-1) zeta^(-i j) L_i`
    `quad j = 0, cdots, n-1`.
  </span>
</p>

<p class="proof">
  验证矩阵互逆:
  <span class="formula">
    `sum_(k=0)^(n-1) zeta^(i k) zeta^(-k j)`
    `= sum_(k=0)^(n-1) zeta^(k (i-j))`
    `= {n, if i = j;
      (zeta^(n(i-j)) - 1)//(zeta^(i-j) - 1) = 0, otherwise
    :}`
  </span>
</p>

<p class="remark">
  Lagrange 预解式的主要应用是推导二到四次方程的求根公式;
  因其计算过程繁琐, 可以参见本节开头的链接, 这里从略.
</p>

<h3>五次及以上一般方程无根式解的证明思路</h3>

<h4>根式可解</h4>

<p>
  设 `a^n in bbb F`, 即 `a` 是 `bbb F` 中某个元素的 `n` 次方根.
  把 `a` 加到 `bbb F` 中生成的域 `bbb F(a)` 称为 `bbb F`
  的一个<b>单根式扩域</b>.  若存在单根式扩张的链条
  <span class="formula">
    `bbb F sube bbb F_1 sube bbb F_2 sube cdots sube bbb K`,
  </span>
  则 `bbb K` 称为 `bbb F` 的一个<b>根式扩域</b>.
</p>

<p>设 `f` 是 `bbb F` 上的 `n` 次多项式, 且在 `bbb F` 的扩域 `bbb K`
  上能被完全因式分解:
  <span class="formula">
    `f(x) = a(x-k_1)cdots(x-k_n)`, `quad k_1, cdots, k_n in bbb K`,
  </span>
  满足上式的最小域 `bbb K` 称为 `bbb F` 的<b>分裂域</b>.
</p>

<p>
  于是, `f in bbb F[x]` <b>根式可解</b>定义为:
  `f` 的分裂域 `bbb K` 是 `bbb F` 的一个根式扩域.
  换言之, 存在 `bbb F` 的一个根式扩域包含 `f` 的所有根.
</p>

<h4>可解群与 Galois 群</h4>

<p>一个群是 `G` <b>可解</b>的, 是指存在正规子群的链条
  <span class="formula">
    `{e} normal H_1 normal H_2 normal cdots normal G`,
  </span>
  且相邻两个群之商 `H_(i+1) // H_i` 都是 Abel 群.
</p>

<p>设 `bbb K` 是 `bbb F` 的扩域, 则 `bbb K` 上全体保持 `bbb F`
  中元素不变的自同构组成一个群, 称为 `bbb K` 在 `bbb F` 上的 <b>Galois 群</b> `Gal(bbb K, bbb F)`.
</p>

<p class="remark">
  为理解 Galois 群, 任取 `f in bbb F[x]`, `k in bbb K` 和 `varphi in Gal(bbb K, bbb F)`,
  由于 `varphi` 保持 `bbb F` 中元素不变, 所以它保持 `f` 的系数不变, `varphi(f(k)) = f(varphi(k))`.
  特别取 `k = x_i` (`x_i` 是 `f` 的根) 时, 有
  <span class="formula">
    `f(varphi(x_i)) = varphi(f(x_i)) = 0`.
  </span>
  这推出 `varphi(x_i)` 亦是 `f` 的根. 因此 Galois 群实际就是对 `f` 的根的置换, 是 `S_n` 的一个子群.
</p>

<p class="theorem">
  <b>Galois 定理</b>
  `f in bbb F[x]` 根式可解当且仅当其分裂域 `bbb K` 在 `bbb F` 上的 Galois
  群可解.
</p>

<p>由于一般的五次多项式的 Galois 群不可解, 故一般五次方程无根式解.</p>

<p class="example">
  <b>五次方程的 Bring-Jerrard 标准形</b> `x^5 +- x + k = 0`.
  一般地, `n` 次方程可以化简消去 `n-1`, `n-2`, `n-3` 次项.
  [来自 <a href=https://math.stackexchange.com/questions/542108/how-to-transform-a-general-higher-degree-five-or-higher-equation-to-normal-form" target="_blank">stackexchange</a>]
</p>

<ol class="proof">
  <li>对方程的根作 Tschirnhaus 变换, 消去 4 次和 3 次项.
    设 `x_i`, `i = 1, cdots, 5` 是原方程的根,
    令 `y_i = x_i^2 + m x_i + n`, 只需将原方程与
    <span class="formula">
      `y = x^2 + m x + n`
    </span>
    联立, 求解<b>结式 (resultant)</b>, 比如使用
    <a href="https://wolframalpha.com" target="_blank">wolfram</a> 语言:
    <pre>Collect[Resultant[x^5+ax^4+bx^3+cx^2+dx+e, y-(x^2+mx+n), x],y]</pre>
    就得到
    <span class="formula">
      `y^5 + c_1 y^4 + c_2 y^3 + c_3 y^2 + c_4 y + c_5 = 0`.
    </span>
    其中
    <span class="formula">
      `c_1 = -a^2 + 2 b + a m - 5 n`,<br>
      `c_2 = b^2 - 2 a c + 2 d + (3c - a b)m + (4a-8b)n
      + b m^2 - 4 a m n + 10 n^2`.
    </span>
    通过求解二次方程组,
    选择适当的 `m, n`, 就能使 `c_1 = c_2 = 0`, 得到
    <span class="formula">
      `y^5 + u y^2 + v y + w = 0`.
      <span class="label" id="for-principal-quintic-form"></span>
    </span>
  </li>
  <li>要继续消去方程的 2 次项, 一个简单的想法是使用 3 次 Tschirnhaus 变换,
    但这会引出 1 次, 2 次和 3 次方程的方程组, 最终需要求解一个 6 次方程.
    Bring 与 Jerrard 另辟蹊径, 使用 4 次 Tschirnhaus 变换,
    利用额外多出的一个参数来避免高次方程:
    <span class="formula">
      `z = y^4 + p y^3 + q y^2 + r y + s`,
    </span>
    与 <a class="ref" href="#for-principal-quintic-form"></a> 联立有
    <span class="formula">
      `z^5 + d_1 z^4 + d_2 z^3 + d_3 z^2 + d_4 z + d_5 = 0`,
    </span>
    其中
    <span class="formula">
      `d_1 = -5s + 3p u + 4v`,<br>
      `d_2 = 10s^2 - 12p s  u + 3p^2 u^2 - 3q u^2 + 2q^2 v - 16 s v`
      `+ 5 p u v + 6 v^2 + 5p q w - 4u w + r(color(#823)(3q u + 4p v + 5 w))`,<br>
      `d_3 = ** r^3 + ** r^2 + ** r + **`.
    </span>
    令 `d_1 = d_2 = 0` 以及 `color(#823)(3q u + 4p v + 5 w) = 0`,
    只需求解二次方程组即可得到 `p, q, s` 的值.
    注意我们的条件使得前两个方程与变量 `r` 无关, 因此可以独立地使用 `d_3
    = 0` 的任一解作为 `r` 的值. 总之我们有
    <span class="formula">
      `z^5 + d_4 z + d_5 = 0`.
    </span>
  </li>
  <li>最后, 应用伸缩变换 `z = t // f`,
    <span class="formula">
      `t^5 + d_4 f^4 t + d_5 f^5 = 0`,
    </span>
    再令 `d_4 f^4 = +-1` 解出 `f` 的值即可.
  </li>
  <li>注: 如果你想手动得到 1. 中的结式, 可以展开
    <span class="formula">
      `prod (y - x_i^2 - m x_i - n) = 0`,
    </span>
    利用 Vieta 定理和 Newton 多项式消去展式中的 `x_i`, 便得到 `y`
    的五次方程.
  </li>
</ol>

<h2>代数学基本定理</h2>

<p class="example">
	设 `f` 是复数域上的多项式
	<span class="formula">
		`f(z) = sum_(k=0)^n a_k z^k`, `quad a_n != 0`.
	</span>
	令 `A = max_(0 le k lt n) |a_k|`, `r = A/|a_n| + 1`, 则 `|z| gt r` 时,
	首项的模大于其余各项的模之和:
	<span class="formula">
		`|a_n z^n| gt sum_(k=0)^(n-1) |a_k z^k|`.
	</span>
	这一结论可以类比于盖尔圆盘定理.
</p>

<p class="proof">
	<span class="formula">
		`sum_(0 le k lt n) |a_k z^k|`
		`le A sum_(0 le k lt n) |z|^k`
		`= A (|z|^n-1)/(|z|-1)`
		`lt A |z|^n/(r-1)`
		`= |a_n z^n|`.
	</span>
</p>

<p class="example">
	设 `z^n + a_(n-1) z^(n-1) + cdots + a_1 z + a_0 = 0`,
	`A = max_(0 le k lt n) |a_k|`, 则
	<span class="formula">
		`|z| le max{1, n A}`.
	</span>
</p>

<p class="proof">
	不妨设 `|z| gt 1`, 下证 `|z| le n A`. 移项并取模
	<span class="formula">
		`|z|^n = |a_(n-1) z^(n-1) + cdots + a_1 z + a_0|`
		`le A |z^(n-1) + cdots + z + 1|`
		`le n A |z|^(n-1)`.
	</span>
	两边同除以 `|z|^(n-1)` 即得证.
</p>

<p class="theorem">
	<b>代数学基本定理</b>
	`n` 次复系数多项式 (`n ge 1`)
	<span class="formula">
		`f(z) = sum_(k=0)^n a_k z^k`, `quad a_n != 0`
	</span>
	在复数域内有零点.
</p>

<ol class="proof">
	若 `f` 的常数项为零, 显然 `z = 0` 就是 `f` 的零点. 下设 `a_0 != 0`.
	<li>因为 `a_0 != 0`, 有 `lim_(z to oo) |f(z)| = oo` (将 `f`
		的各项同除以首项可以证明. 这是因为 `z to oo` 时, `f`
		的高次项是最主要的项). 因此存在 `R gt 0`, 使得 `|f|` 在闭圆盘
		`D = bar(B(0, R))` 外大于 `1`. 换言之, `f` 的零点若是存在,
		只可能出现在 `D` 中. 由于 `D` 是紧集, 可以取 `z_0 in D`.
		使得 `|f(z_0)| = min_(z in D) |f(z)|`.
	</li>
	<li>下证 `f(z_0) = 0`. 若不然, 设 `f(z_0) = a != 0`,
		我们来证明存在 `z_1 in D`, 使得
		`|f(z_1)| lt |f(z_0)|`, 从而与 `z_0` 是最小值点矛盾.
		令 `Delta z = z - z_0`, 将 `f(z)` 在 `z_0` 处 Taylor 展开
		(由于 `f` 是多项式函数, 只需将 `z = z_0 + Delta z` 代入
		`f(z)` 的表达式即可):
		<span class="formula">
			`f(z) = f(z_0 + Delta z) = f(z_0) + Delta z^m g(Delta z)`,
		</span>
		其中 `m ge 1`, `g` 是多项式. 由 `f` 的次数 `ge 1` 推出 `g`
		不是零多项式, 因此可以设 `g(0) = b != 0`.
	</li>
	<li>
		由多项式函数的连续性知, 存在 `delta gt 0`,
    对任意 `|Delta z| lt delta` 有
		<span class="formula">
			`|g(Delta z) - b|`
			`= |g(Delta z) - g(0)| lt |b|//2`.
		</span>
		令 `0 lt t lt min{1, delta^m |b//a|}`,
    又取 `Delta z in CC` 满足 `t = -Delta z^m b//a`
    (注意在复数域中总是可以开 `m` 次方), 则
    <span class="formula">
			`|Delta z^m b| = t |a| lt delta^m |b|`
      `rArr |Delta z| lt delta`,<br/>
			`a + Delta z^m b`
			`= (1 + Delta z^m b // a) a`
			`= (1-t) a`.
		</span>
		记 `z_1 = z_0 + Delta z`, 于是
		<span class="formula align">
      `quad |f(z_1)|`
			`= |f(z_0) + Delta z^m g(Delta z)|`
			`= |a + Delta z^m b + Delta z^m g(Delta z) - Delta z^m b|`
			`le |a + Delta z^m b| + |Delta z|^m |g(Delta z) - b|`
			`lt (1-t) |a| + |Delta z|^m |b|//2`
			`= (1-t) |a| + t/2 |a|`
			`= (1-t/2) |a| lt |a| = |f(z_0)|`.
		</span>
		定理证毕.
	</li>
</ol>

<ol class="algorithm">
  <b>`QQ` 上因式分解的暴力算法</b>
  对于 `ZZ` 上的多项式 `f(x)`
  <li>若 `f` 有重因式, 则重因式是 `f` 和 `f'` 的最大公因式.</li>
  <li>若 `f` 存在一次因式, 即 `f` 存在有理根. 则这个有理根的分母是 `f`
    的最高次项系数的因子, 分子是 `f` 常数项的因子.
    通过枚举因子可以得到这个一次因式. 下面设 `f` 的因式都是大于一次的,
    且重数为 1.
  </li>
  <li>由 Gauss 引理, 若 `f` 在 `QQ` 上可约, 则 `f` 在 `ZZ` 上也可约.</li>
  <li>在复平面上可以找到一个圆盘, 包含 `f` 的所有根. 事实上 `|z| le max{1,
    n A}` 就是这样一个圆盘, 其中 `A` 是 `f` 各系数模的最大值.
  </li>
  <li>利用韦达定理确定 `f` 的因式 `g` 的系数的界.
    例如, 设 `g` 的次数为 `m`, 且它的所有根位于单位圆盘内, 则 `g` 的 `k`
    次项系数的模有上界 `|c_k| le (m;k)`.
    由于 `g` 的次数有限, 系数是整数且有上界, 可以对其系数进行枚举.
  </li>
</ol>

<h2>结式</h2>

<p>[来自<a href="https://zhuanlan.zhihu.com/p/165459547" target="_blank">知乎@三维欧氏心</a>]</p>

<p>
  判断两个多项式是否互素, 一种方法是用辗转相除法求出最大公因式, 再判断其是否为常数.
  不过, 这种方法要求多项式至少是 Euclid Domain 上的, 方能进行辗转相除.
  结式给出了判断多项式是否互素的另一种方法.
</p>

<p class="remark">
  没有另行说明的情况下, 本节始终假定 `f, g in R[x]`, `deg f, deg g ge 1`,
  且
  <span class="formula">
    `f(x) = sum_(k=0)^m a_k x^k`,
    `quad g(x) = sum_(k=0)^n b_k x^k`,
    `quad a_m, b_n != 0`.
  </span>
</p>

<p class="lemma">
  `f, g` 不互素的充要条件是存在 `u, v in R[x]`, `deg u lt deg g`, `deg v lt degf`,
  使得 `u(x) f(x) = v(x) g(x)`.
</p>

<ol class="proof">
  <li>`rArr`: 若 `f, g` 有非平凡的公因子 `d`, 设 `f = v d`, `g = u d`,
    则 `deg u lt deg g = n`, `deg v lt deg f = m`, 且 `u f = u v d = v g`.
  </li>
  <li>`lArr`: 设 `d = gcd(f, v)`, `f = f_1 d`, `v = v_1 d`, 则由 `u f = v g` 得
    `u f_1 d = v_1 d g`, 即 `u f_1 = v_1 g`. 但 `gcd(f_1, v_1) = 1` 所以 `f_1 | g`.
    这说明 `f_1` 是 `f, g` 的公因子.
    又 `deg d le deg v lt deg f`, 所以 `deg f_1 ge 1`.
  </li>
</ol>

<p class="definition">
  `f, g` 的 <b>Sylvester 行列式</b>或<b>结式 (Resultant)</b> 定义为
  <span class="formula">
   `"Res"(f, g) = |
      a_m,  a_(m-1), a_(m-2), cdots, a_0;
      , a_m,  a_(m-1), cdots, a_1, a_0;
      , , ddots, ddots, , ddots, ddots;
      , , , a_m, a_(m-1), cdots, a_1, a_0;
      b_n,  b_(n-1), b_(n-2), cdots, b_0;
      , b_n, b_(n-1), cdots, b_1, b_0;
      , , ddots, ddots, , ddots, ddots;
      , , , b_n, b_(n-1), cdots, b_1, b_0;
    | {: {:; ; ; ;} n 行; {:; ; ; ;} m 行 :}`
  </span>
  这个行列式的阶数为 `m+n`, 前 `n` 行由 `f` 的系数组成, 后 `m` 行由 `g` 的系数组成.
  行列式的主对角线由 `n` 个 `a_m` 和 `m` 个 `b_0` 组成.
</p>

<p class="corollary" id="cor-res-anbm">
  由 Sylvester 行列式立即得到, 对于非零常数 `a, b` 有
  <span class="formula">
    `"Res"(a f, b g) = a^n b^m "Res"(f, g)`.
  </span>
</p>

<p class="theorem" id="the-res">
  `f, g` 不互素 `iff "Res"(f, g) = 0`.
</p>

<p class="proof">
  由引理, `f, g` 不互素当且仅当存在系数不全为零的
  `u(x) = sum_(k=0)^(n-1) u_k x^k` 和 `v(x) = - sum_(k=0)^(m-1) v_k x^k` 使得 `f(x) u(x) = g(x) v(x)`,
  比较等号两边系数得到
  <span class="formula">
    `{
      a_m u_(n-1) = - b_n v_(m-1);
      a_(m-1) u_(n-1) + a_m u_(n-2) = - b_(n-1) v_(m-1) - b_n v_(m-2);
      cdots;
      a_0 u_1 + a_1 u_0 = - b_0 v_1 - b_1 v_0;
      a_0 u_0 = - b_0 v_0;
    :}`
  </span>
  这个方程组含有 `m+n` 个变元 `u_0, cdots, u_(n-1), v_0, cdots, v_(m-1)` 和 `m+n` 个方程.
  该方程组存在非零解, 因此系数行列式等于零.
</p>

<p class="example">
  设 `f(x) = 2x^3 - 3x^2 + lambda x + 3`, `g(x) = x^3 + lambda x + 1`, 若 `f, g` 不互素, 求 `lambda` 可能的值.
</p>

<p class="solution">
  令
  <span class="formula">
    `"Res"(f, g) = |
      2, -3, lambda, 3;
      , 2, -3, lambda, 3;
      , , 2, -3, lambda, 3;
      1, 0, lambda, 1;
      , 1, 0, lambda, 1;
      , , 1, 0, lambda, 1;
    |`
    `= -(2+lambda)(2 lambda^2 + 14 lambda - 13)`
    `= 0`,
  </span> 
  解得 `lambda = 2` 或 `lambda = -(7 +- 5 sqrt 3)/2`.
</p>

<p class="theorem">
  <b>结式的等价定义</b>
  <span class="formula">
    `"Res"(f, g) = a_m^n b_n^m prod_(i,j) (x_i - y_j)`,
  </span>
  其中 `x_i`, `y_j` 分别是 `f, g` 的根.
</p>

<ol class="proof">
  <li>
    把 `"Res"(f, g)` 看成是 `x_i, y_j` 的 `m+n` 元多项式.
    对任意 `i, j`, 若 `x_i = y_j`, 则 `f, g` 不互素,
    由<a class="ref" href="#the-res"></a> 知 `"Res"(f, g) = 0`.
    因此 `(x_i - y_j)` 是 `"Res"(f, g)` 的一个因式.
  </li>
  <li>
    另一方面, 由 Vieta 定理, 系数 `a_i, b_j` 分别可以写成根 `x_i, y_j` 的对称多项式,
    比如 `a_(m-1) = sum x_i`, `a_0 = prod x_i` 等.
    注意到 Sylvester 行列式展开的每一项 (视为 `x_i, y_j` 的多项式) 次数均为 `m n`,
    所以 `"Res"(f, g)` 的次数是 `m n`, 其形如 `(x_i - y_j)` 的因式都是一次的. 即
    <span class="formula">
      `"Res"(f, g) = c prod_(i,j) (x_i - y_j)`,
      `quad c` 为待定系数.
    </span>
  </li>
  <li>
    最后来确定常数 `c`.  不妨设 `f, g` 首一,
    Sylvester 行列式展开中主对角线的那一项为 `a_m^n b_0^m = b_0^m = prod_j y_j^m`.
    但 `c prod_(i,j) (x_i - y_j)` 的展开式中相应的一项为 `c prod_j y_j^m`, 由此得到 `c = 1`.
    再利用<a class="ref" href="#cor-res-anbm"></a> 得到最终结论.
  </li>
</ol>

<p class="corollary">
  将 `f(y_j) = a_m prod_i (x_i - y_j)` 代入结式的乘积表达式中得到
  <span class="formula">
    `"Res"(f, g) = b_n^m prod_j f(y_j)`
    `= a_m^n prod_i g(x_i)`.
  </span>
</p>

<p class="corollary">
  <span class="formula">
    `"Res"(f - g h, g) = b_n^(delta - m) "Res"(f, g)`,
  </span>
  其中 `delta = deg(f - g h)`.
</p>

<p class="proof">
  <span class="formula">
    `"Res"(f - g h, g) = b_n^delta prod_j (f - g h)(y_j)`
    `= b_n^delta prod_j f(y_j)`
    `= b_n^(delta - m) "Res"(f, g)`.
  </span> 
</p>

<p class="definition">
  <b>判别式</b> 多项式 `f(x)` 的判别式定义为
  <span class="formula">
    `Delta(f) := (-1)^s/a_m "Res"(f, f')`
    `= a_m^(2m-2) prod_(i lt j) (x_i - x_j)^2`.
  </span>
  其中 `s = m(m-1)//2`, 最高次项系数 `a_m != 0`, `f'` 是 `f` 的求导, `x_i` 是 `f(x)` 的根.
  因此
  <span class="formula">
    `f` 有重根 `iff f` 与 `f'` 不互素 `iff Delta(f) = 0`.
  </span>
  特别地,
  <span class="formula">
    `Delta(a x^2 + b x + c) = b^2 - 4 a c`,<br>
    `Delta(a x^3 + b x^2 + c x + d)`
    `= -27 a^2 d^2 + 18 a b c d - 4 a c^3 - 4 b^3 d + b^2 c^2`.
  </span>
</p>

<ol class="proof">
  <li>判别式的乘积公式.
    设 `f(x) = a_m prod_i (x-x_i)` 则
    <span class="formula">
      `f'(x) = a_m sum_i prod_(j != i) (x - x_j)`,<br>
      `f'(x_i) = a_m prod_(j != i) (x_i - x_j)`.
    </span> 
    于是
    <span class="formula">
      `"Res"(f, f')`
      `= a_m^(m-1) prod_i f'(x_i)`
      `= a_m^(m-1) a_m^m prod_(i != j) (x_i - x_j)`
      `= (-1)^s a_m^(2m-1) prod_(i lt j) (x_i - x_j)^2`.
    </span>
  </li>
  <li>二次多项式的判别式
    <span class="formula">
      `Delta(a x^2 + b x + c)`
      `= -1/a "Res"(a x^2 + b x + c, 2a x + b)`
      `= -1/a|
      a, b, c;
      2a, b;
      , 2a, b;
      |`
      `= -1/a(a b^2 - 2a b^2 + 4a^2 c)`
      `= b^2 - 4 a c`.
    </span>
  </li>
  <li>三次多项式的判别式
<pre>
from sympy import *
from sympy.abc import a, b, c, x
expand(resultant(a*x**3 + b*x**2 + c*x + d, 3*a*x**2 + 2*b*x + c, x)/(-a))
</pre>
  </li>
</ol>

<p class="algorithm">
  <b>二元高次方程组</b>
  考虑 `{F(x, y) = 0; G(x, y) = 0:}`, 先把 `y` 看作常数, 从而得到一元多项式 `f(x) := F(x, y)` 和 `g(x) := G(x, y)`.
  方程组有解时, `f, g` 不互素, 即 `"Res"(f, g) = 0`, 问题化为 `y` 的一元高次方程.
  解出 `y` 后代入原方程组求解 `x`.
</p>

<p class="example">
  解方程组 `{ 5x^2 - 6xy + 5y^2 - 16 = 0; 2x^2 - (1+y) x + y^2 - y - 4 = 0 :}`
</p>

<ol class="solution">
  视 `y` 为常数, 求结式:
  <span class="formula">
    `"Res"_x(5x^2 - 6x y + 5y^2 - 16, 2x^2 - (1+y)x + y^2 - y - 4)`
    `= 32(y - 2)(y - 1)(y + 1)^2`.
  </span>
  用计算机验证:
  <pre>
  factor(resultant(5*x**2-6*x*y+5*y**2-16, 2*x**2-(1+y)*x+y**2-y-4, x))
  </pre>
  从而 `y = 2` 或 `+-1`.
  <li>`y = 2` 时, 解 `{5x^2 - 12 x + 4 = 0; 2x^2 - 3x - 2 = 0:}` 得 `x = 2`;</li>
  <li>`y = 1` 时, 解 `{5x^2 - 6x - 11 = 0; 2x^2 - 2x - 4 = 0:}` 得 `x = -1`;</li>
  <li>`y = -1` 时, 解 `{5x^2 + 6x - 11 = 0; 2x^2 - 2 = 0:}` 得 `x = 1`;</li>
  综上解为 `(2, 2)`, `(1, -1)`, `(-1, 1)`.
</ol>

<script>
var asciimath = {
  define: [
    [/deg/g, 'op(deg)'],
  ]
}
</script>
<script src="../../js/note.js?type=math"></script>
<script src="../../js/playground.js"></script>
</body>
</html>
