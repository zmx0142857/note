<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>λ 矩阵与相似标准形</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="../../css/note.css" />
</head>
<body>

<p class="definition">
  <b>`lambda` 矩阵</b>
  是指元素是 `lambda` 的一元多项式的矩阵, 也可以看作是矩阵环上的一元多项式. 如
  <span class="formula">
    `[lambda + 1, 2; 3, lambda^2 + 4] in RR[lambda]^(2 xx 2)`<br>
    `= lambda^2 [0, 0; 0, 1] + lambda [1, 0; 0, 0] + [1, 2; 3, 4] in RR^(2 xx 2) [lambda]`.
  </span>
</p>

<p class="remark">
  对于 `lambda` 矩阵 `bm M(lambda)` 和方阵 `bm A`,
  把 `bm A` "代入" `bm M(lambda)` 中得到的 `bm M(bm A)`
  一般来说无意义, 这是因为矩阵的乘法一般不可交换. 如
  <span class="formula">
    `bm M(lambda) = lambda bm M_1`,
  </span>
  那么 `bm M(bm A) = bm(A M_1)` 还是 `bm(M_1 A)` 呢, 这是不确定的.
</p>

<!--
<p class="theorem">
  平行于多项式的零点-因子定理, 有:
  令 `M(lambda)` 为 `lambda` 矩阵, `f` 为多项式. 若
  <span class="formula">
    `(lambda bm I-bm A)M(lambda) = f(lambda) bm I` 或
    `M(lambda)(lambda bm I-bm A) = f(lambdaa) bm I`,
  </span>
  则 `f(bm A) = bm O`.
</p>
-->

<h2>Smith 标准形</h2>

<ol class="definition">
  <li>
    <b>`k` 阶子式</b>
    是指在 `n` 阶行列式中删去 `n-k` 行 `n-k` 列所得的 `k` 阶行列式. 有 `(n;k)^2` 种取法.
  </li>
  <li>
    <b>`k` 阶主子式</b>
    和 `k` 阶子式类似, 但删去的行号与列号必须相同. 有 `(n;k)` 种取法.
  </li>
  <li>
    <b>`k` 阶顺序主子式</b>
    在 `n` 阶行列式中取前 `k` 行前 `k` 列所得的 `k` 阶行列式. 只有一种取法.
  </li>
</ol>

<p class="definition">
  <b>Smith 标准形</b> 即对角形 `lambda` 矩阵
  <span class="formula">
    `"diag"(f_1(lambda), cdots, f_n(lambda))`,
  </span>
  且前一个对角线元素 `f_i(lambda)` 整除后一个元素 `f_(i+1)(lambda)`.
  比如
  <span class="formula">
    `"diag"(1, lambda - 1, (lambda-1)(lambda-2))`.
  </span>
</p>

<ol class="definition">
  <li>
    <b>不变因子</b>
    `d_i(lambda)` 是将 `lambda` 矩阵化为 Smith 标准形后, 对角线上的全体非零元素.
  </li>
  <li>
    <b>行列式因子</b>
    `D_i(lambda)` 是 `lambda` 矩阵的全部非零 `k` 阶子式的首一的最大公因式.
    规定 `D_0(lambda) = 1` 的话, 则有 `d_i = D_i // D_(i-1)`.
  </li>
  <li>
    <b>初等因子</b>
    是把不变因子中的常数 1 去掉, 其余的每个不变因子进行因式分解后得到的所有形如
    `p(lambda)^a` 的因式, 其中 `p(lambda)` 为不可约多项式.
    两个不变因子各自分解得到的初等因子有可能相同, 如不变因子
      `1`, `color(red)(lambda)`, `color(blue)(lambda(lambda-1))`
    分解得到的初等因子为
      `color(red)(lambda)`, `color(blue)(lambda)`, `color(blue)(lambda-1)`.
  </li>
  对于一个数字矩阵 `bm A`, 它的不变因子、行列式因子、初等因子就定义为 `lambda bm I - bm A` 的相应因子.
</ol>

<h2>有理标准形</h2>

<p class="definition">
  数域 `bbb P` 上多项式 `f(lambda) = lambda^n + sum_(k=0)^(n-1) a_k lambda^k`
  的<b>友阵</b>定义为
  <span class="formula">
    `bm A = [0, 0, cdots, 0, -a_0;
    1, , , , -a_1;
    , 1, , , -a_2;
    , , ddots, , vdots;
    , , , 1, -a_(n-1)]`.
  </span>
  在行列式一章我们已验证过 `det(lambda bm I - bm A) = f(lambda)`,
  事实上, 进一步有 `bm A` 的不变因子, 即 `lambda bm I - bm A` 的不变因子为
  `overbrace(1, cdots, 1)^(n-1), f(lambda)`.
</p>

<p class="definition">
  <b>有理标准形</b>
  是指分块对角矩阵
  <span class="formula">
    `bm A_(n xx n) = "diag"(bm A_1, cdots, bm A_s)`,
  </span>
  其中 `bm A_1, cdots, bm A_s` 分别是数域 `bbb P` 上多项式 `f_1, cdots, f_s` 的友阵,
  且前一个多项式 `f_i` 整除后一个 `f_(i+1)`.
  由多项式的友阵阶数等于该多项式的次数知道, `f_1, cdots, f_s` 的次数之和等于 `n`.
</p>

<p class="corollary">
  有理标准形 `bm A` 的不变因子为 `overbrace(1, cdots, 1)^(n-s), f_1(lambda), cdots, f_s(lambda)`,
</p>

<h2>Jordan 标准形</h2>

<p class="remark">
  Jordan 标准形是复数域上特有的标准形, 因此本节都假定矩阵是复数域上的.
</p>

<ol class="definition">
  <li>
    <b>Jordan 块</b> 是指形如
    <span class="formula">
      `bm J_m(lambda) = [lambda, 1, , , ;
      , lambda, 1, ;
      , , ddots, ddots, ;
      , , , lambda, 1;
      , , , , lambda]_(m xx m)`
    </span>
    的 `m` 阶方阵. 它具有 `m` 重特征值 `lambda`.
  </li>
  <li>
    <b>Jordan 标准形</b>或 <b>Jordan 形矩阵</b>
    是指一个分块对角矩阵, 其中每个对角块都是 Jordan 块. 例如
    `"diag"(J_4(2), J_3(2), J_1("i"), J_3(-5))` 就是一个 Jordan 形矩阵.
  </li>
</ol>

<p class="example">
  考虑特征值为零的 Jordan 块 `J_m(0)`, 计算知,
  <span class="formula">
    `J_m(0)^2 = [0, 0, 1, , ; , 0, 0, ddots, ; , , ddots, ddots, 1; , , , 0, 0; , , , , 0]`,<br>
    `J_m(0)^(m-1) = [ ,  ,  , , 1; , , , , ; , , , , ; , , , , ; , , , , ]`,<br>
    `J_m(0)^m = 0`.
  </span>
  幂次每增加 1, `J_m(0)^k` 中值为 1 的斜线就向右上方移动一格, 矩阵的秩减少 1.
</p>

<p class="theorem">
  任意 `bm A in CC^(n xx n)` 相似于一个 Jordan 形矩阵 `bm J`,
  其中每个 Jordan 块的特征值都是 `bm A` 的特征值.
  不计 Jordan 块的排列顺序时, `bm J` 是唯一的,
  称为 `bm A` 的 Jordan 标准形.
</p>

<ol class="algorithm">
  <b>将方阵 `bm A` 化为 Jordan 标准形 `bm J`</b>.
  <li>求出 `bm A` 的特征多项式
    <span class="formula">
      `Delta_A(lambda) = prod_(k=1)^s (lambda - lambda_k)^(n_k)`,
      `quad sum n_k = n`.
    </span>
  </li>
  <li>对于一重的特征值 `lambda`, 它对应的 Jordan 块只能是一阶的 `[lambda]`;
    对于二重的特征值, 它对应的 Jordan 块可能是两个一阶的 `[lambda, ; , lambda]` 或一个二阶的
    `[lambda, 1; , lambda]`.
    一般地, 对于 `m` 重特征值, 整数 `m` 的每一种分拆 `m = m_1 + cdots + m_t`
    对应着一组可能的 Jordan 块 `"diag"(J_(m_1)(lambda), cdots, J_(m_t)(lambda))`.
  </li>
  <li>
    这些不同的 Jordan 块互不相似.
    比如两个一阶的 Jordan 块 `bm J_1 = [lambda, ; , lambda]`
    和二阶 Jordan 块 `bm J_2 = [lambda, 1; , lambda]` 不相似.
    这是因为如果它们相似, 则 `bm J_1 - lambda bm I` 和 `bm J_2 - lambda bm I` 也相似, 但这不可能, 因为
    `"rank"(bm J_1 - lambda bm I) = 0`, 而 `"rank"(bm J_2 - lambda bm I) = 1`.
    相似矩阵的秩总是相等的: 这是因为相似矩阵间相差若干初等变换, 而初等变换不改变矩阵的秩.
  </li>
  <li>为了判断出 2. 中究竟是哪种 Jordan 块, 考虑 `(bm J - lambda bm I)^k` 的秩
    <span class="formula">
       `r_k = "rank"(bm J - lambda bm I)^k`
       `= "rank"(bm A - lambda bm I)^k`,
       `quad k = 0, 1, cdots`.
    </span>
    注意: 我们事先不知道 `bm J` 的形式, 因此无法直接求出 `"rank"(bm J - lambda bm I)^k`,
    但可以改为求 `"rank"(bm A - lambda bm I)^k`.
  </li>
  <li>
    `k = 0` 时, `(bm J - lambda bm I)^0 = bm I` 的秩为 `r_0 = n`.
    `k = 1` 时, `bm J - lambda bm I` 把 `bm J` 的主对角线变为零, 于是所有 Jordan 块的秩都减少 1.
    换言之, `r_0 - r_1 =` 所有 Jordan 块的数目.
    `k` 从 1 变到 2 时, `bm J - lambda bm I` 中一阶 Jordan 块已经变成零, 阶数无法降低;
    其他 Jordan 块的阶数都减少 1. 换言之 `r_2 - r_1 =` 阶数大于 1 的 Jordan 块的数目.
    一般地
    <span class="formula">
      `r_(k+1) - r_k =` 阶数大于 `k` 的 Jordan 块的数目.
    </span>
    再作一阶差分就得到:
    <span class="formula">
      `(r_k - r_(k-1)) - (r_(k+1) - r_k) =` 阶数等于 `k` 的 Jordan 块数目.
    </span>
  </li>
  <li>
    对 `bm A` 的各个不同的特征值重复上述操作.
    得知了各阶 Jordan 块的数目后, Jordan 标准形就完全确定了.
  </li>
</ol>

<pre>
from sympy import Matrix
m = Matrix([[...]])
p, d = m.jordan_form()
simplify(p**-1*m*p - d) # zero matrix
</pre>

<script src="../../js/note.js?type=math"></script>
</body>
</html>
