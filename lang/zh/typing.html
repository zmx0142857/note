<style>
* {
  box-sizing: border-box;
}
:root {
  --fg: #eee;
  --fg2: #aaa;
  --fg3: #ccc;

  --bg: #222;
  --bg2: #333;
  --bg3: #666;
  --bg4: rgba(0, 0, 0, 0.5);

  --bd: #303030;
  --bd2: #888;

  --color-error: #e88;
  --color-blue: #1976d2;
}

::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
::-webkit-scrollbar-thumb {
  background-color: #666;
  background-clip: padding-box;
  min-height: 28px;
}
::-webkit-scrollbar-track-piece {
  background-color: transparent;
}
/* firefox */
html {
  scrollbar-color: var(--bg3) var(--bg2);
}
* {
  scrollbar-width: thin;
}

body {
  background-color: var(--bg);
}
.g-inline-block {
  display: inline-block;
}
.g-relative {
  position: relative;
}
.g-absolute {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}
.input {
  position: relative;
  background: var(--bg2);
  width: 100%;
  height: 500px;
  border-radius: 4px;
  color: var(--fg2);
}
.input-area {
  color: transparent;
  background: transparent;
  resize: none;
  border: none;
  caret-color: var(--fg);
}
.input-bg,
.input-area {
  padding: 8px 8px 40px 8px;
  font-family: monospace;
  font-size: 20px;
  line-height: 30px;
  line-break: anywhere;
  white-space: pre-wrap;
  overflow-y: scroll; /* 保证前后两层都有滚动条, 从而有相同的宽度 */
}
.composition-str {
  position: absolute;
}

.color-normal {
  color: var(--fg);
}
.color-dim {
  color: var(--fg2);
}
.color-error {
  color: var(--color-error);
}
.color-transparent {
  color: transparent;
}
.bg-gold {
  background-image: linear-gradient(45deg, #ff8400, gold);
}
.anim-gold {
  background-image: linear-gradient(45deg, #ff9d0b, gold, #ff9d0b, gold);
  background-size: 200%;
  animation: anim-gold 4s infinite linear;
}
@keyframes anim-gold {
  0% { background-position: 0% 0%; }
  50% { background-position: 300% 0%; }
  100% { background-position: 600% 0%; }
}

.tool-bar {
  text-align: right;
}
.btn {
  display: inline-flex;
  align-items: center;
  padding: 8px 16px;
  border-radius: 2px;
  font-size: 14px;
  cursor: pointer;
  color: var(--fg);
  background-color: transparent;
  border: 1px solid var(--bd2);
  opacity: 0.9;
  margin-top: 8px;
}
.btn.btn-primary {
  background-color: var(--color-blue);
  border-color: var(--color-blue);
}
.btn:active {
  opacity: 1;
}
.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.btn-suffix {
  position: relative;
  border-left: 1px solid var(--bd2);
  margin-left: 6px;
  display: inline-block;
  height: 18px;
  width: 36px;
  margin-right: -16px;
  font-size: 20px;
}
.btn-suffix-arrow::after {
  content: '';
  position: absolute;
  display: block;
  top: 2px;
  left: 12px;
  width: 8px;
  height: 8px;
  border-left: 1px solid var(--bd2);
  border-top: 1px solid var(--bd2);
  transform: rotate(-135deg);
  transform-origin: center;
}
.status-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--bg);
  border-top: 1px solid var(--bd);
  color: var(--fg3);
  font-size: 14px;
  line-height: 24px;
  display: flex;
  gap: 4px;
  height: 25px;
}
.status-badge {
  background-color: var(--color-blue);
  padding: 0 10px;
  margin-right: 4px;
}
.status-divider {
  border-right: 1px solid var(--bd);
  margin: 4px;
}

.toast {
  display: none;
  background-color: var(--color-blue);
  color: var(--fg);
  border-radius: 8px;
  padding: 8px;
  transition: opacity .5s;
  height: 132px;
  width: 132px;
  font-size: 14px;
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}
.toast-header {
  font-size: 32px;
  line-height: 50px;
  margin-bottom: 8px;
}
.modal {
  display: none;
  position: absolute;
  z-index: 1;
  transition: opacity .2s;
}
.modal-mask {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: var(--bg4);
}
.modal-body {
  position: fixed;
  background-color: var(--bg2);
  padding: 20px;
  color: var(--fg);
  border-radius: 16px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80vw;
  overflow: hidden;
}
.modal-setting h3 {
  margin-top: 0;
}
.modal-setting h4 {
  position: relative;
}
.modal-setting h4::before {
  content: '';
  width: 4px;
  height: 19px;
  background-color: var(--color-blue);
  display: inline-block;
  vertical-align: middle;
  margin-right: 4px;
  border-radius: 2px;
}
.modal-setting input[type=number] {
  width: 160px;
}
.modal-history {
  max-height: 600px;
  overflow: auto;
}
.modal-history-table {
  color: var(--fg);
  width: 100%;
  min-width: 500px;
  border-top: 1px solid;
  border-bottom: 1px solid;
}
.modal-history-table tr:not(:first-child) {
  border-top: 1px solid var(--bd);
}
.modal-history-table th {
  white-space: nowrap;
}
.modal-history-table td {
  padding: 4px;
  text-align: center;
  white-space: nowrap;
}
.empty {
  min-height: 100px;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
}

.menu {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 1;
}
.menu-mask {
  width: 100%;
  height: 100%;
}
.menu-body {
  position: absolute;
  background: var(--bg);
  padding: 6px;
  border-radius: 4px;
  color: var(--fg);
  transform: translate(-100%, -100%);
}
.menu-body-item {
  padding: 4px 10px;
  cursor: pointer;
  border-radius: 4px;
  white-space: nowrap;
}
.menu-body-item:hover {
  background: var(--bg2);
}
.menu-body-item-hint {
  font-size: 0.8em;
  color: var(--fg2);
  pointer-events: none;
}
.loading {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: var(--bg4);
}
.loading::after {
  content: '';
  position: absolute;
  background-color: var(--fg);
  width: 20px;
  height: 20px;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  animation: loading-anim 1.5s infinite ease-in-out;
}
@keyframes loading-anim {
  0% { transform: translate(-50%, -50%) scale(1.5) rotate(0) }
  50% { transform: translate(-50%, -50%) scale(1) rotate(45deg) }
  100% { transform: translate(-50%, -50%) scale(1.5) rotate(90deg) }
}
</style>

<div class="input">
  <div class="input-bg g-absolute"></div>
  <textarea class="input-area g-absolute" disabled></textarea>
</div>

<div class="tool-bar">
  <button class="btn btn-primary btn-start" disabled title="请先载文">开始</button>
  <button class="btn btn-reload" disabled title="请先载文">重载</button>
  <button class="btn btn-load">载文 <a class="btn-suffix btn-suffix-arrow"></a></button>
  <button class="btn btn-history">历史</button>
  <button class="btn btn-setting">设置</button>
</div>

<div class="status-bar">
  <span class="status-badge">--</span>
  <span class="status-time">00:00.000</span>
  <span class="status-divider"></span>
  <span class="status-speed" title="字/分">0.00 速</span>
  <span class="status-divider"></span>
  <span class="status-key-speed" title="键/秒">0.00 击</span>
  <span class="status-divider"></span>
  <span class="status-acc">100.00%</span>
</div>

<div class="modal">
  <div class="modal-mask"></div>
  <div class="modal-body"></div>
</div>

<div class="toast"></div>

<div class="menu">
  <div class="menu-mask"></div>
  <div class="menu-body"></div>
</div>

<div class="loading"></div>

<script>
const $ = el => document.querySelector(el)
const $inputArea = $('.input-area')
const $inputBg = $('.input-bg')
const $statusBadge = $('.status-badge')
const $statusTime = $('.status-time')
const $statusSpeed = $('.status-speed')
const $statusKeySpeed = $('.status-key-speed')
const $statusAcc = $('.status-acc')
const $btnSetting = $('.btn-setting')
const $btnStart = $('.btn-start')
const $btnLoad = $('.btn-load')
const $btnLoadSuffix = $('.btn-load .btn-suffix')
const $btnReload = $('.btn-reload')
const $btnHistory = $('.btn-history')

const Constants = {
  space: '␣',
  linebreak: '↵',
  storage: {
    history: 'typing.history',
    setting: 'typing.setting',
    maturity: 'typing.maturity',
  },
}

const Utils = {
  // 处理空格与换行
  processText (text) {
    // 将最后一个空格外的所有空格换成占位符
    // return (text.slice(0, -1).replace(/ /g, Constants.space) + text.slice(-1))
    return text.replace(/ /g, Constants.space)
      // 将换行换成占位符
      .replace(/↵\n|\r\n|\n|\r/g, Constants.linebreak)
  },
  // 还原换行符
  restoreLinebreak (text) {
    return text.replace(/↵/g, Constants.linebreak + '\n')
  },
  // 还原空格
  restoreSpace (text) {
    return text.replace(/␣$/, ' ')
  },
  // 补零
  pad (x, len, str = '0') {
    return (str.repeat(len) + x).slice(-len)
  },
  between (x, min, max) {
    if (x < min) return min
    if (x > max) return max
    return Number.isFinite(x) ? x : min
  },
  // 格式化时间
  formatTime (millis) {
    // const hh = Utils.pad(millis / (1000 * 3600) | 0, 2)
    const mm = Utils.pad(millis % (1000 * 3600) / (1000 * 60) | 0, 2)
    const ss = Utils.pad(millis % (1000 * 60) / 1000 | 0, 2)
    const ms = Utils.pad(millis % 1000, 3)
    return `${mm}:${ss}.${ms}`
  },
  formatDate (timestamp) {
    const offset = -60 * 1000 * new Date().getTimezoneOffset()
    return new Date(timestamp + offset).toISOString().slice(0, 19).replace('T', ' ')
  },
  parseJson (str, defaultValue = {}) {
    if (!str) return defaultValue
    try {
      return JSON.parse(str)
    } catch (err) {
      return defaultValue
    }
  },
  getStorage (key, defaultValue = {}) {
    return Utils.parseJson(localStorage.getItem(key), defaultValue)
  },
  setStorage (key, value) {
    localStorage.setItem(key, JSON.stringify(value))
  },
  shuffle (arr) {
    const n = arr.length
    for (let i = 0; i < n; ++i) {
      const j = (i + (n-i) * Math.random()) | 0
      const tmp = arr[i]
      arr[i] = arr[j]
      arr[j] = tmp
    }
  },
  // 在闭区间 [lo, hi] 中寻找第一个使 fn(n) 成立的 n
  bsearch (lo, hi, fn) {
    --lo, ++hi
    while (hi - lo > 1) {
      const mid = lo + ((hi - lo) >> 1)
      if (fn(mid)) hi = mid
      else lo = mid
    }
    return hi
  },
  // 根据先验概率生成随机单字
  // TODO: 如何生成不重复单字?
  sample (arr, maturity, limit, prefer = 8) {
    const cumsum = []
    let sum = 0
    arr.forEach(ch => {
      // 对于没有出现过的字, 给予高的权重; 否则 keySpeed 越大权重越小 (n方反比)
      sum += 1 / Math.pow(maturity[ch]?.keySpeed || 1, prefer)
      cumsum.push(sum)
    })
    limit = limit || arr.length
    const res = []
    for (let i = 0; i < limit; ++i) {
      const r = Math.random() * sum
      let j = Utils.bsearch(0, cumsum.length - 1, j => cumsum[j] >= r)
      j = Math.min(j, arr.length - 1)
      res.push(arr[j])
    }
    console.log(res.map(ch => ch + ': ' + (maturity[ch]?.keySpeed || 1)).join('\n'))
    return res
  },
  escapeHTML (text) {
    return text.replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
  },
  html (arr, ...args) {
    const buf = []
    arr.forEach((str, i) => {
      buf.push(str)
      if (args[i] === undefined) args[i] = ''
      buf.push(Utils.escapeHTML(String(args[i])))
    })
    return buf.join('')
  },
}


const UI = {
  toast ({ html, className = 'toast' }) {
    const $toast = $('.toast')
    $toast.className = className
    $toast.innerHTML = html
    Object.assign($toast.style, {
      display: 'block',
      opacity: '1',
    })
    setTimeout(() => {
      $toast.style.opacity = '0'
    }, 2000)
    setTimeout(() => {
      $toast.style.display = 'none'
    }, 2500)
  },
  modal ({ show, html, className = 'modal' }) {
    UI.modal.show = show
    const $modal = $('.modal')
    $modal.className = className
    if (show) {
      Object.assign($modal.style, {
        display: 'block',
        opacity: '0',
      })
      $modal.querySelector('.modal-body').innerHTML = html
      $modal.querySelector('.modal-mask').onclick = () => UI.modal({ show: false })
      setTimeout(() => {
        $modal.style.opacity = '1'
      }, 200)
    } else {
      $modal.style.opacity = '0'
      setTimeout(() => {
        $modal.style.display = 'none'
      }, 200)
    }
  },
  menu ({ show, html, className = 'menu', bodyStyle }) {
    UI.menu.show = show
    const $menu = $('.menu')
    $menu.className = className
    if (show) {
      Object.assign($menu.style, {
        display: 'block',
      })
      const $body = $menu.querySelector('.menu-body')
      $body.innerHTML = html
      Object.assign($body.style, { ...bodyStyle })
      const $mask = $menu.querySelector('.menu-mask')
      $mask.onclick = () => UI.menu({ show: false })
    } else {
      $menu.style.display = 'none'
    }
  },
  file ({ accept, oninput }) {
    // 创建 <input type="file" /> 后马上移除, 以免 onchange 不触发
    const $btnFile = document.createElement('input')
    $btnFile.hidden = true
    $btnFile.type = 'file'
    $btnFile.accept = accept
    $btnFile.oninput = oninput
    document.body.append($btnFile)
    $btnFile.click()
    document.body.removeChild($btnFile)
  },
  loading ({ show }) {
    const $loading = $('.loading')
    UI.loading.show = show
    if (show) {
      $loading.style.display = 'block'
    } else {
      $loading.style.display = 'none'
    }
  },
}

const Typing = {
  loadedFile: '', // 当前载入的文件 (未处理)
  loadedText: '', // 当前载入的文章
  setting: {}, // 用户设置
  current: {}, // 当前打字信息
  history: [], // 历史记录
  maturity: {}, // 单字成熟度
  compositionStr: '', // 未上屏的编码
  onLoad () {
    Typing.history = Utils.getStorage(Constants.storage.history, [])
    Typing.setting = {
      ...Typing.defaultSetting(),
      ...Utils.getStorage(Constants.storage.setting, {})
    }
    Typing.maturity = Utils.getStorage(Constants.storage.maturity, {})
  },
  defaultSetting () {
    return {
      slice: 0,
      randomType: 'none',
      blankType: ['trim'],
      limit: 0,
      preferNew: 8, // 练习生字的倾向, 1 到 10
    }
  },
  // 更新背景文字
  updateBg (textArr) {
    const res = []
    const buf = []
    let className = ''
    const flush = ({ alignLast } = {}) => {
      const text = Utils.restoreLinebreak(buf.join(''))
      // 最后一字如果打错, 做对齐处理, 以减少打字时的闪烁体验
      if (alignLast && buf.length === 1 && className === 'color-error') {
        const c2 = Typing.current.text[textArr.length - 1]
        res.push(Utils.html`<span class="g-inline-block g-relative color-transparent">${c2}<span class="g-inline-block g-absolute color-error">${text}</span></span>`)
        buf.length = 0
        return
      }
      if (buf.length) {
        res.push(Utils.html`<span class="${className}">${text}</span>`)
        buf.length = 0
      }
    }
    let correctCount = 0
    let errorCount = 0
    textArr.forEach((c1, i) => {
      const c2 = Typing.current.text[i]
      const cls = c1 === c2 ? 'color-normal' : 'color-error'
      if (c1 === c2) {
        ++correctCount
      } else {
        ++errorCount
      }
      if (cls !== className) {
        flush()
        className = cls
      }
      buf.push(c1)
    })
    Typing.current.correctCount = correctCount
    Typing.current.errorCount = errorCount
    flush({ alignLast: true })
    if (Typing.compositionStr) {
      res.push(Utils.html`<span class="color-normal composition-str">${Typing.compositionStr}</span>`)
    }
    className = 'color-dim'
    buf.push(...Typing.current.text.slice(textArr.length))
    flush()
    return res.join('')
  },
  start () {
    if (!Typing.loadedText) return
    const text = Utils.processText(Typing.loadedText)
    const textArr = [...text]
    $inputBg.innerText = Utils.restoreLinebreak(text)
    $inputArea.value = ''
    $inputArea.disabled = false
    $inputArea.focus()
    Typing.current = {
      text: textArr, // 待输入文本
      isEnglish: textArr.filter(ch => /[↵␣\u0000-\u00ff]/.test(ch)).length / textArr.length > 0.9, // 是否为英文文章
      pauseTime: 0, // 上一次暂停输入的时刻
      startTime: 0, // 开始输入的时刻 (扣除暂停时间)
      timer: undefined, // interval 定时器
      correctCount: 0, // 正确字数
      errorCount: 0, // 错误字数
      backspaceCount: 0, // 回改数
      keyCount: 0, // 击键数
    }
  },
  finish () {
    $inputArea.disabled = true
    clearInterval(Typing.current.timer)
    Typing.current.timer = undefined
    Typing.updateStatus()

    // 计算成熟度
    Typing.current.text.forEach(ch => {
      const record = Typing.maturity[ch] || { count: 0, keySpeed: 0 }
      const { keySpeed, acc } = Typing.current
      record.keySpeed = (record.keySpeed * record.count + keySpeed * acc / 100) / (++record.count)
      Typing.maturity[ch] = record
    })
    Utils.setStorage(Constants.storage.maturity, Typing.maturity)

    Typing.current.text = Typing.current.text.join('')
    Typing.history.push(Typing.current)
    Utils.setStorage(Constants.storage.history, Typing.history)

    const badge = $statusBadge.textContent
    UI.toast({
      className: badge === 'φ' ? 'toast anim-gold' : 'toast',
      html: Utils.html`<div class="toast-header">${$statusBadge.textContent}</div>
        <div>${$statusSpeed.textContent}</div>
        <div>${$statusKeySpeed.textContent}</div>
        <div>${$statusAcc.textContent}</div>
      `,
    })
    $btnStart.focus()
  },
  logMaturity () {
    console.log(
      Object.entries(Typing.maturity)
      .sort((a, b) => b[1].keySpeed - a[1].keySpeed)
      .map(v => v[0] + ' ' + v[1].keySpeed.toFixed(2)).join('\n')
    )
  },
  pause () {
    if (!Typing.current.timer) return
    clearInterval(Typing.current.timer)
    Typing.current.timer = undefined
    Typing.current.pauseTime = new Date().valueOf()
  },
  resume () {
    Typing.current.startTime += new Date().valueOf() - Typing.current.pauseTime
    Typing.current.timer = setInterval(Typing.updateStatus, 50)
  },
  // 计算字母评分
  getBadge (speed, acc, isEnglish) {
    if (isEnglish) speed = (speed + 50) / 2
    return speed > 200 && acc >= 98 ? 'φ'
      : speed > 150 ? 'V+'
      : speed > 120 ? 'V'
      : speed > 100 ? 'S'
      : speed > 80 ? 'A'
      : speed > 60 ? 'B'
      : speed > 40 ? 'C'
      : 'D'
  },
  // 更新状态栏
  updateStatus () {
    const { correctCount, errorCount, backspaceCount, keyCount, isEnglish } = Typing.current
    const millis = new Date().valueOf() - Typing.current.startTime
    const speed = correctCount * 1000 * 60 / millis
    const keySpeed = keyCount * 1000 / millis
    const acc = Math.max((1 - backspaceCount / keyCount) * (correctCount / (correctCount + errorCount) || 0) * 100, 0)
    const badge = Typing.getBadge(speed, acc, isEnglish)
    Object.assign(Typing.current, {
      millis, speed, keySpeed, acc, badge,
    })
    $statusTime.textContent = Utils.formatTime(millis)
    $statusSpeed.textContent = speed.toFixed(2) + ' 速'
    $statusKeySpeed.textContent = keySpeed.toFixed(2) + ' 击'
    $statusAcc.textContent = acc.toFixed(2) + '%'
    $statusBadge.textContent = badge
    if (badge === 'φ') {
      $statusBadge.classList.add('bg-gold')
    } else {
      $statusBadge.classList.remove('bg-gold')
    }
  },
  onCompositionUpdate (e) {
    Typing.compositionStr = e.data
  },
  onCompositionEnd (e) {
    Typing.compositionStr = ''
    Typing.onInput(e)
  },
  // 文本框输入事件
  onInput (e) {
    // 输入禁用时不触发事件
    if ($inputArea.disabled) return
    // 用户输入时开始记时
    if (!Typing.current.timer) Typing.resume()
    const value = Utils.processText(e.target.value)
    e.target.value = Utils.restoreSpace(Utils.restoreLinebreak(value))

    const text = [...value]
    const isFinish = text.length === Typing.current.text.length
    const isCorrect = text[text.length - 1] === Typing.current.text[text.length - 1]
    const textArr = Typing.compositionStr ? [...value.slice(0, -Typing.compositionStr.length)] : [...value]
    $inputBg.innerHTML = Typing.updateBg(textArr)
    $inputArea.scrollTo({ top: $inputArea.scrollHeight, left: 0 })
    if (isFinish && isCorrect && !Typing.compositionStr) {
      Typing.finish()
    }
  },
  onKeyUp (e) {
    if (e.code === 'Backspace') {
      // 多删一个换行符
      if (e.target.value.endsWith(Constants.linebreak + '\n')) {
        e.target.value = e.target.value.slice(0, -1)
      }
      ++Typing.current.backspaceCount
    } else {
      if (e.code === 'Space') Typing.onCompositionEnd(e)
      // keyup 可能会触发两次, 这里用节流处理
      if (this.keyUpThrottle === e.code) return
      this.keyUpThrottle = e.code
      // console.log('keyCount++', e.code)
      setTimeout(() => {
        ++Typing.current.keyCount
        this.keyUpThrottle = null
      }, 20)
    }
  },
  onScroll (e) {
    $inputBg.scrollTo({ top: e.target.scrollTop, left: 0 })
  },
  onFileInput (e) {
    const file = e.target.files[0]
    const reader = new FileReader()
    reader.onload = function () {
      Typing.loadedFile = this.result
      Typing.reload()
    }
    reader.readAsText(file)
  },
  load () {
    UI.file({
      accept: '.txt',
      oninput: Typing.onFileInput
    })
  },
  reload () {
    $btnStart.disabled = false
    $btnStart.title = ''
    $btnReload.disabled = false
    $btnReload.title = '启用随机化时，文章会被重排。刷到满意成绩后就按重载打下一组吧！'
    Typing.loadedText = Typing.preloadText(Typing.loadedFile)
    Typing.start()
  },
  openBuiltin (e) {
    e.preventDefault()
    e.stopPropagation()
    UI.menu({
      show: true,
      html: `<div class="menu-body-list">
          <div class="menu-body-item" data-src="../data/zh-char-5000.txt" role="link">单字练习</div>
          <div class="menu-body-item" data-src="../data/zh-word.txt" role="link">词组练习</div>
          <div class="menu-body-item" data-click="loadFromClipboard" role="link">剪贴板
            <span class="menu-body-item-hint">(Ctrl-Shift-V)</span>
          <div>
      </div>`,
      bodyStyle: {
        left: e.target.offsetLeft + 37 + 'px',
        top: e.target.offsetTop - 10 + 'px',
      },
    })
    $('.menu-body-list').onclick = (e) => {
      if ([...e.target.classList].includes('menu-body-item')) {
        const dataClick = e.target.getAttribute('data-click')
        if (dataClick) {
          return Typing[dataClick]()
        }
        const dataSrc = e.target.getAttribute('data-src')
        if (dataSrc === '../data/zh-word.txt' && Typing.setting.slice <= 3000) {
          return Typing.loadBuiltin(dataSrc.replace('.txt', '-3000.txt'))
        } else {
          const { setting } = Typing
          setting.slice = setting.slice || 500
          setting.limit = setting.limit || 20
          setting.randomType = setting.randomType === 'none' ? dataSrc.includes('char') ? 'char' : 'line' : setting.randomType
          return Typing.loadBuiltin(dataSrc)
        }
      }
    }
  },
  loadFromClipboard () {
    UI.menu({ show: false })
    const res = window.prompt('在下面粘贴文章内容：')
    if (res) {
      Typing.loadedFile = res
      Typing.setting.slice = 0
      Typing.setting.randomType = 'none'
      Typing.setting.limit = 0
      Utils.setStorage(Constants.storage.setting, Typing.setting)
      Typing.reload()
    }
  },
  async loadBuiltin (src) {
    UI.menu({ show: false })
    UI.loading({ show: true })
    try {
      const res = await fetch(src)
      const text = await res.text()
      Typing.loadedFile = text
      Typing.reload()
    } finally {
      UI.loading({ show: false })
    }
  },
  preloadText (text) {
    const { setting } = Typing
    // 随机化
    if (setting.randomType === 'repeat') {
      text = [...text]
      if (setting.slice > 0) text = text.slice(0, setting.slice)
      text = text[Math.random() * text.length | 0].repeat(setting.limit)
    } else if (setting.randomType === 'char') {
      text = [...text]
      if (setting.slice > 0) text = text.slice(0, setting.slice)
      // Utils.shuffle(text)
      const prefer = Utils.between(Typing.setting.preferNew, 1, 10)
      text = Utils.sample(text, Typing.maturity, setting.limit, prefer)
      text = text.join('')
    } else if (setting.randomType === 'line') {
      text = text.split('\n')
      if (setting.slice > 0) text = text.slice(0, setting.slice)
      Utils.shuffle(text)
      text = text.join('\n')
    } else {
      if (setting.slice > 0) text = [...text].slice(0, setting.slice).join('')
    }
    // 空白处理
    if (setting.blankType.includes('trim')) text = text.trim()
    if (setting.blankType.includes('nobreak')) text = text.replace(/\r|\n/g, '')
    if (setting.blankType.includes('noblank')) text = text.replace(/\s/g, '')
    // 限定字数
    if (setting.limit > 0) text = text.slice(0, setting.limit)
    console.log(text)
    return text
  },
  changeSetting (name, value) {
    Typing.setting[name] = value
    Utils.setStorage(Constants.storage.setting, Typing.setting)
  },
  showSetting () {
    const { setting } = Typing
    UI.modal({
      show: true,
      html: Utils.html`
        <div class="modal-setting">
          <h3 style="margin-top: 0">设置</h3>
          <h4>截取</h4>
          <label>前 <input type="number" name="slice" min="0" placeholder="0 代表不截取" value="${setting.slice}" />
            <span class="modal-setting-slice-unit">${setting.randomType === 'line' ? '行' : '字'}</span>
          </label>
          <h4>随机化</h4>
          <p>单字练习时可以选择字乱序，词组练习时可以选择行乱序</p>
          <label><input type="radio" name="randomType" value="none" ${setting.randomType === 'none' ? 'checked' : ''} /> 无</label>
          <label><input type="radio" name="randomType" value="char" ${setting.randomType === 'char' ? 'checked' : ''} /> 字乱序</label>
          <label><input type="radio" name="randomType" value="line" ${setting.randomType === 'line' ? 'checked' : ''} /> 行乱序</label>
          <label><input type="radio" name="randomType" value="repeat" ${setting.randomType === 'repeat' ? 'checked' : ''}/> 重复</label>
          <h4>空白处理</h4>
          <label><input type="checkbox" name="blankType" value="trim" ${setting.blankType.includes('trim') ? 'checked' : ''} /> 去除文章前后空白</label>
          <label><input type="checkbox" name="blankType" value="nobreak" ${setting.blankType.includes('nobreak') ? 'checked' : ''} /> 去除换行</label>
          <label><input type="checkbox" name="blankType" value="noblank" ${setting.blankType.includes('noblank') ? 'checked' : ''} /> 去除所有空白</label>
          <h4>限定字数</h4>
          <label><input type="number" name="limit" min="0" placeholder="0 代表不限字数" value="${setting.limit}" /></label>
          <h4>生字偏好</h4>
          <label><input type="number" name="preferNew" min="1" max="10" placeholder="生字偏好程度 (1-10)" value="${setting.preferNew}" /></label>
        </div>
      `
    })
    let timer
    const onSettingInput = (e) => {
      const { name, type, value, checked } = e.target
      if (type === 'radio') {
        Typing.changeSetting(name, value)
      } else if (type === 'checkbox') {
        if (checked) {
          Typing.setting[name].push(value)
          Typing.changeSetting(name, Typing.setting[name])
        } else {
          Typing.changeSetting(name, Typing.setting[name].filter(v => v !== value))
        }
      } else if (type === 'number') {
        clearTimeout(timer)
        timer = setTimeout(() => {
          Typing.changeSetting(name, Number(value))
        }, 500)
      }

      // 表单交互
      if (name === 'randomType') {
        $('.modal-setting-slice-unit').textContent = value === 'line' ? '行' : '字'
      }
    }
    ;[...document.querySelectorAll('.modal-setting input')].forEach(input => {
      input.oninput = onSettingInput
    })
  },
  showHistory () {
    UI.modal({
      show: true,
      html: `
        <div class="modal-history">
          <table class="modal-history-table">
            <tr>
              <th>文章</th>
              <th>成绩</th>
              <th title="字/分">速度</th>
              <th title="键/秒">击键</th>
              <th>键准</th>
              <th>码长</th>
              <th>字数</th>
              <th>错字</th>
              <th>回改</th>
              <th>日期</th>
            </tr>
            ${[...Typing.history].reverse().map(record => (
              Utils.html`<tr>
                <td>${(record.text ?? '').slice(0, 10)}</td>
                <td>${record.badge}</td>
                <td>${(record.speed ?? NaN).toFixed(2)}</td>
                <td>${(record.keySpeed ?? NaN).toFixed(2)}</td>
                <td>${(record.acc ?? NaN).toFixed(2)}%</td>
                <td>${(record.keyCount / record.text.length).toFixed(2)}</td>
                <td>${(record.text ?? '').length}</td>
                <td>${record.errorCount}</td>
                <td>${record.backspaceCount}</td>
                <td>${Utils.formatDate(record.startTime)}</td>
              </tr>`
            )).join('\n')}
          </table>
          ${Typing.history.length === 0 ? '<div class="empty">暂无数据</div>' : ''}
        </div>
      `
    })
  },
  onKeyPress (e) {
    if (e.code === 'KeyV') {
      if (e.ctrlKey && e.shiftKey && $inputArea.disabled) {
        Typing.loadFromClipboard()
      }
    }
  },
}

$btnHistory.onclick = Typing.showHistory
$btnSetting.onclick = Typing.showSetting
$btnLoad.onclick = Typing.load
$btnLoadSuffix.onclick = Typing.openBuiltin
$btnReload.onclick = Typing.reload
$btnStart.onclick = Typing.start
$inputArea.oninput = Typing.onInput
// $inputArea.addEventListener('compositionstart', Typing.onCompositionStart)
$inputArea.addEventListener('compositionupdate', Typing.onCompositionUpdate)
$inputArea.addEventListener('compositionend', Typing.onCompositionEnd)
$inputArea.onblur = Typing.pause
$inputArea.oncontextmenu = (e) => e.preventDefault()
$inputArea.onpaste = (e) => e.preventDefault()
$inputArea.onkeyup = Typing.onKeyUp // 注意: 中文输入时 onKeyDown 可能不会触发, 而 onKeyUp 可能触发两次
$inputArea.onscroll = Typing.onScroll
document.onkeypress = Typing.onKeyPress

Typing.onLoad()
</script>
