<link rel="stylesheet" href="../../css/vanilla-ui.css">
<style>
:root {
  --anki-green: #97e2bd;
}
@media (prefers-color-scheme: dark) {
  :root {
    --anki-green: #448866;
  }
}
.main {
  position: absolute;
  height: 400px;
  gap: 20px;
}
.deck {
  position: relative;
  width: 300px;
  height: 400px;
  perspective: 1000px;
}
.card {
  --is-back: 0;
  position: absolute;
  width: 300px;
  height: 400px;
  border-radius: var(--va-md);
  overflow: hidden;
  background-color: var(--va-bg2);
  transition: transform .3s, opacity .3s;
  transform: rotateY(calc(var(--is-back) * 180deg));
  text-align: center;
  font-size: 28px;
}
.card.is-back {
  --is-back: 1;
}
.card-front, .card-back {
  display: flex;
  flex-direction: column;
  padding: 60px 16px 40px 16px;
  overflow-y: auto;
}
.card-front-content, .card-back-content {
  max-height: 100%; /* é˜²æ­¢ g-center å±…ä¸­å†…å®¹æº¢å‡ºä¸å¯è§ */
  gap: 40px;
  align-items: center;
}
.card-front-content::after, .card-back-content::after {
  content: '';
  display: block;
  width: 100%;
  height: 1px; /* äº§ç”Ÿ 40px çš„åº•éƒ¨ gap */
  flex-shrink: 0;
}
.card-front-title {
  position: relative;
  line-break: anywhere;
  max-width: 80%;
}
.card-back {
  display: none;
  background-color: var(--anki-green);
  transform: scaleX(-1);
}
.card.is-back .card-back {
  display: flex;
}
.card.is-back .card-front {
  display: none;
}
.card.is-left {
  opacity: 0;
  transform: translate3d(-200px, 0, -20px) rotateY(calc(-20deg + var(--is-back) * 180deg));
  pointer-events: none;
}
.card.is-right {
  opacity: 0;
  transform: translate3d(200px, 0, -20px) rotateY(calc(20deg + var(--is-back) * 180deg));
  pointer-events: none;
}
.card.is-new .card-front::after {
  content: 'NEW';
  position: absolute;
  top: 12px;
  left: -18px;
  transform: rotate(-45deg);
  background-color: rgb(var(--va-c-red));
  color: #fff;
  width: 80px;
  text-align: center;
  font-size: 16px;
}
.card-input {
  height: var(--va-xl);
  border-radius: var(--va-md);
  background-color: var(--va-bg3);
  border: none;
  padding: var(--va-md);
  color: var(--va-fg);
  font-size: 20px;
  width: 80%;
}
.card-choice-item {
  background: var(--va-bg3);
  color: var(--va-fg);
  font-size: 20px;
  border: none;
  border-radius: 40px;
  padding: 8px 26px;
  width: 100%;
  cursor: pointer;
}
.card-choice-item:hover {
  opacity: 0.8;
}
.card-choice-item + .card-choice-item {
  margin-top: 8px;
}
.card-choice-item.is-active {
  outline: 2px solid var(--va-fg);
}
.card-tts {
  position: absolute;
  left: -35px;
  top: 4px;
  background: transparent;
  border: none;
  cursor: pointer;
  user-select: none;
  font-size: 18px;
  height: 30px;
}
.link {
  font-size: 48px;
  cursor: pointer;
  user-select: none;
  transition: text-shadow .3s, transform .3s;
  z-index: 1;
}
.link[disabled] {
  cursor: not-allowed;
  transform: none;
  opacity: 0.3;
}
.link:not([disabled]):hover {
  text-shadow: 0 0 6px var(--va-fg);
  transform: scale(1.1);
}
.deck-name {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  color: var(--va-fg2);
}
.deck-tips {
  position: absolute;
  bottom: 36px;
  left: 50%;
  transform: translateX(-50%);
  color: rgb(var(--va-c-red));
}
.form-tips {
  color: rgb(var(--va-c-red));
  font-size: 14px;
}
.deck-progress {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
}
.deck-list {
  width: 300px;
  margin-bottom: var(--va-md);
}
.deck-item {
  display: block;
  width: 100%;
  font-size: 16px;
  text-align: left;
  color: var(--va-fg);
  border: none;
  background-color: transparent;
  padding: var(--va-md);
  cursor: pointer;
  line-height: 20px;
}
.deck-item:hover {
  background: var(--va-bg3);
  border-radius: var(--va-md);
}
.deck-item.is-active::before {
  content: 'âœ”';
  color: rgb(var(--va-c-green));
  margin-right: var(--va-md);
}
.btn-group {
  display: flex;
  justify-content: flex-end;
  gap: var(--va-md);
  margin: 8px 0;
}
.add-deck-input {
  color: var(--va-fg);
  background-color: var(--va-bg);
  border-radius: var(--va-xs);
  width: 300px;
}
select {
  width: 120px;
  height: 24px;
  border-radius: 4px;
  color: #333;
}
option {
  color: #333;
}
</style>

<body class="g-full g-center g-overflow-hidden">

<main class="main g-center">
  <a class="link link-prev">â®</a>
  <div class="deck"></div>
  <a class="link link-next">â¯</a>

  <div class="deck-name"></div>
  <div class="deck-tips"></div>
  <div class="deck-progress">0 / 0</div>
</main>

<script type="module">
import { $, div, Modal, Button, Table, Menu, Console, Toast } from '../../js/vanilla-ui.js'

// Console()

const $main = $('.main')
const $deck = $($main, '.deck')
const $linkPrev = $($main, '.link-prev')
const $linkNext = $($main, '.link-next')
const $deckProgress = $($main, '.deck-progress')
const $deckTips = $($main, '.deck-tips')
const $deckName = $($main, '.deck-name')

const Utils = {
  uid (length = 16) {
    return Math.random().toFixed(length).slice(2)
  },
  uniq (arr) {
    return [...new Set(arr)]
  },
  between (x, min, max) {
    if (x < min) return min
    if (x > max) return max
    return x
  },
  round (x, digits) {
    const pow = Math.pow(10, digits)
    return Math.round(x * pow) / pow
  },
  parseJson (str, defaultValue = {}, options) {
    if (!str) return defaultValue
    try {
      return JSON.parse(str, options) ?? defaultValue
    } catch (e) {
      return defaultValue
    }
  },
  // åœ¨å·¦é—­å³å¼€åŒºé—´ [lo, hi) ä¸­æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä½¿ fn(i) æˆç«‹çš„ i
  bsearch (lo, hi, fn) {
    --lo
    while (hi - lo > 1) {
      const mid = lo + ((hi - lo) >> 1)
      if (fn(mid)) hi = mid
      else lo = mid
    }
    return hi
  },
  // æ‰“ä¹±æ•°ç»„, åŒºé—´ [lo, hi)
  shuffle(arr, lo = 0, hi) {
    hi ??= arr.length
    for (let i = lo; i < hi; ++i) {
      const j = (i + (hi - i) * Math.random()) | 0 // random of [i, hi)
      const tmp = arr[i]
      arr[i] = arr[j]
      arr[j] = tmp
    }
    return arr
  },
  /**
   * ä» 0 ~ n-1 ä¸­éšæœºæŠ½å– k ä¸ªä¸é‡å¤çš„æ•°å­—,
   * è¦æ±‚å«æœ‰ include ä¸­çš„æ•°å­—, ä½†ä¸å« exclude ä¸­çš„æ•°å­—
   * @param {Number} n
   * @param {Number} k
   * @param {Array} include
   * @param {Array} exclude
   */
  choices (n, k = 1, include = [], exclude = []) {
    const ret = include.slice()
    const len = n
    n -= include.length + exclude.length
    k -= include.length
    for (let i = 0; i < len; ++i) {
      if (exclude.indexOf(i) > -1 || include.indexOf(i) > -1) continue
      if (Math.random() < k/n) {
        ret.push(i)
        if (--k === 0) break
      }
      --n
    }
    return Utils.shuffle(ret)
  },
  saveGlobals () {
    localStorage.setItem(`${Globals.key}.globals`, JSON.stringify(Globals))
  },
  loadGlobals () {
    Object.assign(Globals, Utils.parseJson(localStorage.getItem(`${Globals.key}.globals`)))
    // load dataset from localStorage
    Globals.decks.forEach(key => {
      if (!Deck.dataset[key]) {
        const str = localStorage.getItem(`${Globals.key}.deck.${key}`)
        if (str) {
          const data = Utils.parseJson(str)
          Deck.dataset[key] = {
            name: data.name,
            cards: () => data.cards,
          }
        }
      }
    })
  },
  download ({ url, blob, filename = 'untitled' }) {
    if (typeof blob === 'string') blob = new Blob([blob])
    const a = document.createElement('a')
    a.href = url || URL.createObjectURL(blob)
    a.download = filename
    a.style.display = 'none'
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    if (!url) URL.revokeObjectURL(a.href)
  },
  upload ({ id = 'file-input', multiple = false, accept } = {}) {
    return new Promise(resolve => {
      const input = document.getElementById(id) || document.createElement('input')
      input.type = 'file'
      input.id = id
      input.style.display = 'none'
      input.multiple = multiple
      input.accept = accept
      input.onclick = () => input.value = null // æ¸…ç©ºé€‰ä¸­çš„æ–‡ä»¶
      input.onchange = () => resolve(input.files)
      document.body.appendChild(input)
      input.click()
    })
  },
  async readFile (blob, { type = 'string' } = {}) {
    if (!blob) return
    return new Promise((resolve, reject) => {
      const reader = new window.FileReader()
      reader.onload = () => resolve(reader.result)
      reader.onerror = reject
      if (type === 'string') return reader.readAsText(blob)
      if (type === 'base64') return reader.readAsDataURL(blob)
      if (type === 'bytes') return reader.readAsArrayBuffer(blob)
      reject('unknown type: ' + type)
    })
  },
  parseTsv (text = '') {
    text = text.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n')
    return text.split('\n').map(row => row.split('\t'))
  },
  // å«æœ‰é€—å·æˆ–æ¢è¡Œçš„å­—æ®µéœ€è¦ç”¨åŒå¼•å·åŒ…è£¹
  // åŒå¼•å·éœ€è¦è½¬ä¹‰ä¸ºä¸¤ä¸ªåŒå¼•å·
  parseCsv (text = '') {
    text = [...text.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n')]
    const rows = [], row = [], buf = []
    let inQuote = false
    const flush = (flag) => {
      row.push(buf.join(''))
      buf.length = 0
      if (flag) {
        rows.push(row.slice())
        row.length = 0
      }
    }
    for (let i = 0; i < text.length; ++i) {
      const ch = text[i]
      if (ch === '"') {
        if (text[i+1] !== ch) {
          inQuote = !inQuote
        } else if (inQuote) {
          buf.push(ch)
          ++i
        } else {
          inQuote = true
        }
      } else if (ch === ',') {
        inQuote ? buf.push(ch) : flush()
      } else if (ch === '\n') {
        inQuote ? buf.push(ch) : flush(true)
      } else {
        buf.push(ch)
      }
    }
    flush(true)
    return rows
  },
  b64encode (str) {
    return btoa(String.fromCharCode(...new TextEncoder().encode(str)))
  },
  linebreak (str) {
    return str.trim().replace(/\n/g, '<br/>')
  },
}

const ScoreEnum = {
  bad: 0,
  good: 1,
  great: 2,
  perfect: 3,
}

const Globals = {
  now: 0, // å½“å‰æ—¶é—´
  maxHistory: 15, // æœ€å¤§å†å²è®°å½•æ•°
  key: 'anki', // æœ¬åœ°å­˜å‚¨çš„é”®å
  deck: 'shuangpin', // é»˜è®¤ç‰Œç»„
  decks: [],
}

class Card {
  /**
   * è®°å¿†å¡ç‰‡
   * @param {object} props
   * @param {boolean} props.enable æ˜¯å¦å¯ç”¨
   * @param {string} props.front æ­£é¢å†…å®¹
   * @param {string} props.back èƒŒé¢å†…å®¹
   * @param {string} props.hint æç¤º
   * @param {string[]} props.tags æ ‡ç­¾
   * @param {object[]} props.history å¾—åˆ†å†å²è®°å½•
   * @param {number} props.due ä¸‹æ¬¡å¤ä¹ æ—¶é—´
   * @param {number} props.interval é—´éš”æ—¶é—´
   * @param {number} props.ease ç®€æ˜“åº¦ç³»æ•°, æ•°å€¼è¶Šå¤§è¶Šç®€å•
   * @param {number} props.mastery æŒæ¡ç¨‹åº¦
   * @param {number} props.weight æƒé‡
   */
  constructor (props) {
    Object.assign(this, {
      enable: true,
      front: '',
      back: '',
      hint: '',
      tags: [],
      history: [],
      // å­¦ä¹ å‚æ•°
      due: 0,
      interval: 2.5,
      ease: 2.5,
      mastery: 0,
      weight: 0,
      ...props,
    })
  }
  get isNew () {
    return !this.history.length
  }
  // æ›´æ–°å­¦ä¹ å‚æ•° (SM-2 ç®—æ³•)
  learn (score, time) {
    this.history.push({ score, time })
    if (this.history.length > Globals.maxHistory) this.history.shift()
    const x = ScoreEnum.perfect - score
    const offset = 0.1 * (1 - x * (0.8 + 0.2 * x))
    this.ease = Utils.between(this.ease + offset, 1.3, 2.5)
    this.interval = Utils.between(Math.round(this.interval * this.ease), 0, 25)
    this.due = Globals.now + this.interval
  }
  // æ›´æ–°æƒé‡ [0, 1]
  updateWeight () {
    if (!this.enable) return this.weight = 0 // è¢«ç¦ç”¨çš„å¡ç‰‡æƒé‡ä¸º 0
    if (this.isNew) return this.weight = 1 // æ–°å¡ç‰‡çš„æƒé‡æœ€å¤§
    const since = Globals.now - (this.due - this.interval) // è·ç¦»ä¸Šæ¬¡å¤ä¹ çš„æ—¶é—´
    const timeFactor = Math.exp(-since / (this.interval + 1))
    const accuracyFactor = this.history.reduce((a, b) => a + Boolean(b.score), 0) / this.history.length || 0
    const easeFactor = Math.min(this.ease / 2.5, 1.5)
    this.mastery = 0.5 * timeFactor + 0.3 * accuracyFactor + 0.2 * easeFactor // ç†Ÿç»ƒåº¦ [0, 1]
    const urgency = Math.exp(-Math.max(this.due - Globals.now, 0)) // ç´§æ€¥ç¨‹åº¦
    this.weight = Utils.between(0.5 * (1 + urgency - this.mastery), 0.02, 1)
    if (Number.isNaN(this.weight)) console.warn('weight is NaN', this)
    return this.weight
  }
  getFront (prob) {
    return (prob ?? this.prob) > 0.5 ? this.back : this.front
  }
  getBack (prob) {
    return (prob ?? this.prob) > 0.5 ? this.front : this.back
  }
}

class Deck {
  constructor ({ key = 'default', name = 'é»˜è®¤ç‰Œç»„', desc = '' } = {}) {
    this.key = key
    this.name = name
    this.desc = desc
    this.cards = []
    this.load()
  }
  filter (match) {
    return this.cards.filter(card => {
      const ok = !match || match(card)
      if (ok) card.updateWeight()
      return ok && card.weight > 0
    })
  }
  // å–å‡ºè‡³å¤š count å¼ å¡ç‰‡, æŒ‰æƒé‡ä»å¤§åˆ°å°æ’åº. é»˜è®¤å–å‡ºæ‰€æœ‰å¡ç‰‡
  deal (count, match) {
    return this.filter(match).sort((a, b) => b.weight - a.weight).slice(0, count)
  }
  // éšæœºæŠ½è‡³å¤š count å¼ å¡ç‰‡, é»˜è®¤æŠ½ 1 å¼ 
  draw (count = 1, match) {
    const res = []
    const arr = this.filter(match)
    if (!arr.length) return res
    // è®¡ç®—æ¦‚ç‡åˆ†å¸ƒ
    const cumsum = []
    let sum = 0
    arr.forEach(card => {
      sum += card.weight
      cumsum.push(sum)
    })
    for (let i = 0; i < count; ++i) {
      const r = Math.random() * sum
      let j = Utils.bsearch(0, cumsum.length, j => cumsum[j] >= r)
      j = Math.min(j, arr.length-1)
      res.push(arr[j])
    }
    return res
  }
  save () {
    Utils.saveGlobals()
    if (Array.isArray(this.key)) {
      this.key.forEach(key => {
        const storeKey = `${Globals.key}.deck.${key}`
        const data = this.loadOne(key, false)
        data.cards = this.cards.filter(v => v.deck === key)
        localStorage.setItem(storeKey, JSON.stringify(data))
      })
    } else {
      localStorage.setItem(`${Globals.key}.deck.${this.key}`, JSON.stringify(this))
    }
  }
  load () {
    Utils.loadGlobals()
    if (Array.isArray(this.key)) {
      const dataList = this.key.map(key => this.loadOne(key))
      this.name = 'å¤åˆå¡ç»„'
      this.desc = dataList.map(v => v.name).join(', ')
      this.cards = dataList.flatMap(v => v.cards)
    } else {
      Object.assign(this, this.loadOne(this.key))
    }
    return this
  }
  loadOne (key, needsCards = true) {
    const data = Utils.parseJson(localStorage.getItem(`${Globals.key}.deck.${key}`))
    if (!data.cards?.length) {
      const { name, desc, cards } = Deck.dataset[key] || {}
      data.name = name || ''
      data.desc = desc || ''
      if (cards) data.cards = Utils.shuffle(cards())
    }
    if (data.cards?.length) {
      data.cards = data.cards.map(v => {
        const card = new Card(v)
        Object.defineProperty(card, 'deck', {
          enumerable: false, // è·³è¿‡ JSON åºåˆ—åŒ–
          value: key,
        })
        return card
      })
    }
    return data
  }
  stat () {
    return this.cards.map(card => {
      card.updateWeight()
      const avgTime = card.history.reduce((a, b) => a + b.time, 0) / (card.history.length * 1000) || 0
      return {
        front: card.front,
        mastery: card.mastery,
        weight: card.weight,
        avgTime,
        isNew: card.isNew,
      }
    })
  }
}

const KanaData = [
  ['a', 'ã‚', 'ã‚¢'], ['i', 'ã„', 'ã‚¤'], ['u', 'ã†', 'ã‚¦'], ['e', 'ãˆ', 'ã‚¨'], ['o', 'ãŠ', 'ã‚ª'],
  ['ka', 'ã‹', 'ã‚«'], ['ki', 'ã', 'ã‚­'], ['ku', 'ã', 'ã‚¯'], ['ke', 'ã‘', 'ã‚±'], ['ko', 'ã“', 'ã‚³'],
  ['sa', 'ã•', 'ã‚µ'], ['shi', 'ã—', 'ã‚·'], ['su', 'ã™', 'ã‚¹'], ['se', 'ã›', 'ã‚»'], ['so', 'ã', 'ã‚½'],
  ['ta', 'ãŸ', 'ã‚¿'], ['chi', 'ã¡', 'ãƒ'], ['tsu', 'ã¤', 'ãƒ„'], ['te', 'ã¦', 'ãƒ†'], ['to', 'ã¨', 'ãƒˆ'],
  ['na', 'ãª', 'ãƒŠ'], ['ni', 'ã«', 'ãƒ‹'], ['nu', 'ã¬', 'ãƒŒ'], ['ne', 'ã­', 'ãƒ'], ['no', 'ã®', 'ãƒ'],
  ['ha', 'ã¯', 'ãƒ'], ['hi', 'ã²', 'ãƒ’'], ['fu', 'ãµ', 'ãƒ•'], ['he', 'ã¸', 'ãƒ˜'], ['ho', 'ã»', 'ãƒ›'],
  ['ma', 'ã¾', 'ãƒ'], ['mi', 'ã¿', 'ãƒŸ'], ['mu', 'ã‚€', 'ãƒ '], ['me', 'ã‚', 'ãƒ¡'], ['mo', 'ã‚‚', 'ãƒ¢'],
  ['ya', 'ã‚„', 'ãƒ¤'], ['yu', 'ã‚†', 'ãƒ¦'], ['yo', 'ã‚ˆ', 'ãƒ¨'],
  ['ra', 'ã‚‰', 'ãƒ©'], ['ri', 'ã‚Š', 'ãƒª'], ['ru', 'ã‚‹', 'ãƒ«'], ['re', 'ã‚Œ', 'ãƒ¬'], ['ro', 'ã‚', 'ãƒ­'],
  ['wa', 'ã‚', 'ãƒ¯'], ['wo', 'ã‚’', 'ãƒ²'], ['n', 'ã‚“', 'ãƒ³'],
  ['ga', 'ãŒ', 'ã‚¬'], ['gi', 'ã', 'ã‚®'], ['gu', 'ã', 'ã‚°'], ['ge', 'ã’', 'ã‚²'], ['go', 'ã”', 'ã‚´'],
  ['za', 'ã–', 'ã‚¶'], ['ji', 'ã˜', 'ã‚¸'], ['zu', 'ãš', 'ã‚º'], ['ze', 'ãœ', 'ã‚¼'], ['zo', 'ã', 'ã‚¾'],
  ['da', 'ã ', 'ãƒ€'], //['di','ã¢','ãƒ‚'], //['du','ã¥','ãƒ…'],
  ['de', 'ã§', 'ãƒ‡'], ['do', 'ã©', 'ãƒ‰'],
  ['ba', 'ã°', 'ãƒ'], ['bi', 'ã³', 'ãƒ“'], ['bu', 'ã¶', 'ãƒ–'], ['be', 'ã¹', 'ãƒ™'], ['bo', 'ã¼', 'ãƒœ'],
  ['pa', 'ã±', 'ãƒ‘'], ['pi', 'ã´', 'ãƒ”'], ['pu', 'ã·', 'ãƒ—'], ['pe', 'ãº', 'ãƒš'], ['po', 'ã½', 'ãƒ'],
  ['kya', 'ãã‚ƒ', 'ã‚­ãƒ£'], ['kyu', 'ãã‚…', 'ã‚­ãƒ¥'], ['kyo', 'ãã‚‡', 'ã‚­ãƒ§'],
  ['sha', 'ã—ã‚ƒ', 'ã‚·ãƒ£'], ['shu', 'ã—ã‚…', 'ã‚·ãƒ¥'], ['sho', 'ã—ã‚‡', 'ã‚·ãƒ§'],
  ['cha', 'ã¡ã‚ƒ', 'ãƒãƒ£'], ['chu', 'ã¡ã‚…', 'ãƒãƒ¥'], ['cho', 'ã¡ã‚‡', 'ãƒãƒ§'],
  ['nya', 'ã«ã‚ƒ', 'ãƒ‹ãƒ£'], ['nyu', 'ã«ã‚…', 'ãƒ‹ãƒ¥'], ['nyo', 'ã«ã‚‡', 'ãƒ‹ãƒ§'],
  ['hya', 'ã²ã‚ƒ', 'ãƒ’ãƒ£'], ['hyu', 'ã²ã‚…', 'ãƒ’ãƒ¥'], ['hyo', 'ã²ã‚‡', 'ãƒ’ãƒ§'],
  ['mya', 'ã¿ã‚ƒ', 'ãƒŸãƒ£'], ['myu', 'ã¿ã‚…', 'ãƒŸãƒ¥'], ['myo', 'ã¿ã‚‡', 'ãƒŸãƒ§'],
  ['rya', 'ã‚Šã‚ƒ', 'ãƒªãƒ£'], ['ryu', 'ã‚Šã‚…', 'ãƒªãƒ¥'], ['ryo', 'ã‚Šã‚‡', 'ãƒªãƒ§'],
  ['gya', 'ãã‚ƒ', 'ã‚®ãƒ£'], ['gyu', 'ãã‚…', 'ã‚®ãƒ¥'], ['gyo', 'ãã‚‡', 'ã‚®ãƒ§'],
  ['ja', 'ã˜ã‚ƒ', 'ã‚¸ãƒ£'], ['ju', 'ã˜ã‚…', 'ã‚¸ãƒ¥'], ['jo', 'ã˜ã‚‡', 'ã‚¸ãƒ§'],
  ['bya', 'ã³ã‚ƒ', 'ãƒ“ãƒ£'], ['byu', 'ã³ã‚…', 'ãƒ“ãƒ¥'], ['byo', 'ã³ã‚‡', 'ãƒ“ãƒ§'],
  ['pya', 'ã´ã‚ƒ', 'ãƒ”ãƒ£'], ['pyu', 'ã´ã‚…', 'ãƒ”ãƒ¥'], ['pyo', 'ã´ã‚‡', 'ãƒ”ãƒ§'],
]

const ShuangpinData = [
  ['iu', 'q'], ['ia', 'w'], ['ua', 'w'], ['e', 'e'], ['uan', 'r'], ['er', 'r'], ['Ã¼e', 't'],
  ['uai', 'y'], ['Ã¼', 'y'], ['sh', 'u'], ['ch', 'i'], ['o', 'o'], ['uo', 'o'], ['un', 'p'],
  ['a', 'a'], ['ong', 's'], ['iong', 's'], ['iang', 'd'], ['uang', 'd'], ['en', 'f'], ['eng', 'g'],
  ['ang', 'h'], ['an', 'j'], ['ao', 'k'], ['ai', 'l'], ['ing', ';'],
  ['ei', 'z'], ['ie', 'x'], ['iao', 'c'], ['ui', 'v'], ['zh', 'v'], ['ou', 'b'], ['in', 'n'], ['ian', 'm'],
]

Deck.dataset = {
  arithmetic: {
    name: 'ä¸¤ä½æ•°ä¹˜ä¸€ä½æ•°',
    cards: () => [...Array(8).keys()].flatMap(i =>
      [...Array(8).keys()].map(j => ({
        front: `${i + 12} Ã— ${j + 2}`,
        back: `${(i + 12) * (j + 2)}`,
      }))
    ),
  },
  shuangpin: {
    name: 'åŒæ‹¼',
    cards: () => ShuangpinData.map(v => ({ front: v[0], back: v[1] })),
  },
  hirakana: {
    name: 'å¹³å‡å',
    cards: () => KanaData.slice(0, 69).map(v => ({ front: v[1], back: v[0] })),
  },
  katakana: {
    name: 'ç‰‡å‡å',
    cards: () => KanaData.slice(0, 69).map(v => ({ front: v[2], back: v[0] })),
  },
  'hirakana-youon': {
    name: 'å¹³å‡åæ‹—éŸ³',
    cards: () => KanaData.slice(69).map(v => ({ front: v[1], back: v[0] })),
  },
  'katakana-youon': {
    name: 'ç‰‡å‡åæ‹—éŸ³',
    cards: () => KanaData.slice(69).map(v => ({ front: v[2], back: v[0] })),
  },
}
Deck.builtinLength = Object.keys(Deck.dataset).length
Globals.decks = Object.keys(Deck.dataset)
Globals.deck = Globals.decks[0]

const langNames = {
  'zh-CN': 'ä¸­æ–‡',
  'en-US': 'English',
  'ru-RU': 'Ğ ÑƒÑÑĞºĞ¸Ğ¹',
  'ja-JP': 'æ—¥æœ¬èª',
}
const langOptions = []

const UI = {
  state: {},
  reload (key) {
    Globals.deck = key
    const deck = new Deck({ key })
    // æŠ½å–è‡³å¤š 30 å¼ å¡ç‰‡, å…¶ä¸­æ–°å¡ç‰‡è‡³å¤š 20 å¼ 
    const newCards = deck.deal(20, v => v.isNew)
    const oldCards = deck.draw(30 - newCards.length, v => !v.isNew)
    Object.assign(this.state, {
      index: 0,
      progress: 0,
      deck,
      cards: [...new Set(oldCards), ...newCards],
      startTime: 0,
      pauseTime: 0,
      totalTime: 0,
      stat: {},
      errCount: 0,
      questionType: 'choice',
      questionDirection: 'forward',
    })
    $deck.innerHTML = ''
    this.render()

    const modal = this.state.modal = Modal({
      closable: false,
      style: {
        width: '280px',
      },
      innerHTML: `<h3>${deck.name}</h3>
      <p>${deck.desc}</p>
      <p>è¿›åº¦: ${deck.cards.filter(v => !v.isNew).length}/${deck.cards.length}</p>
      <form class="welcome-form">
        <p>é¢˜å‹:
          <label><input type="radio" name="questionType" value="choice" checked>é€‰æ‹©</label>
          <label><input type="radio" name="questionType" value="fill">å¡«ç©º</label>
        </p>
        <p>æ–¹å‘:
          <label><input type="radio" name="questionDirection" value="forward" checked>æ­£å‘</label>
          <label><input type="radio" name="questionDirection" value="reverse">åå‘</label>
          <label><input type="radio" name="questionDirection" value="random">éšæœº</label>
        </p>
        <p>è¯­è¨€:
          <select name="lang" value="${deck.lang || ''}">
          ${deck.lang ? `<option value="${deck.lang}">${langNames[deck.lang] || deck.lang}</option>` : ''}
          </select>
        </p>
      </form>
      <div class="btn-group"></div>
      `
    })
    const btnGroup = $(modal.body, '.btn-group')
    $(modal, 'select').onclick = (e) => this.initLangs(e.target)

    Button({
      container: btnGroup,
      innerHTML: 'å¡ç»„',
      onClick: () => {
        this.showDeckList({ container: modal.body })
      },
    })

    Button({
      container: btnGroup,
      innerHTML: 'å¤ä¹ ',
      onClick: () => {
        const oldCards = this.state.deck.draw(30, v => !v.isNew)
        this.state.cards = [...new Set(oldCards)]
        this.onStart({ modal })
      },
    })

    Button({
      container: btnGroup,
      innerHTML: 'å¼€å§‹â†’',
      type: 'primary',
      onClick: () => {
        this.onStart({ modal })
      }
    })
  },
  onStart ({ modal }) {
    modal.setShow(false)
    this.state.startTime = new Date().valueOf()
    const form = $(modal.body, '.welcome-form')
    this.state.questionType = form.questionType.value
    this.state.questionDirection = form.questionDirection.value
    this.state.stat = undefined // é‡ç½®ç»Ÿè®¡
    console.log(this.state)

    const { deck } = this.state
    this.assignProb(deck.cards)

    // è¯­éŸ³åˆæˆ
    deck.lang = (deck.lang || form.lang.value || '')
    if (deck.lang) {
      const tts = this.state.tts = new SpeechSynthesisUtterance()
      tts.lang = deck.lang
      tts.rate = 1
      tts.pitch = 1
      tts.volume = 1
      tts.onstart = () => console.log('tts start:', tts.text)
      // tts.onend = () => console.log('tts end:', tts.text)
      tts.onerror = () => console.error('tts error:', tts.text)
    }

    $deck.innerHTML = ''
    Globals.deck = deck.key
    Utils.saveGlobals()
    this.render()
    this.focus()
  },
  initLangs (container) {
    if (langOptions.length) return
    if (!window.SpeechSynthesis) return Toast({ innerHTML: 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆ' })
    langOptions.push(...Utils.uniq(window.speechSynthesis.getVoices().map(v => v.lang)))
    // å…ˆæŒ‰å­—æ¯åºæ’åº, å†æŠŠå¸¸ç”¨è¯­è¨€æ’åˆ°å‰é¢
    langOptions.sort().sort((a, b) => (!!langNames[b] - !!langNames[a]))
    console.log('langOptions', langOptions)
    // é‡è¯•
    if (!langOptions.length) {
      this.initLangs.count ||= 0
      if (++this.initLangs.count < 3) {
        setTimeout(() => this.initLangs(container), 500)
      }
      return
    }
    container.innerHTML = langOptions.map(lang => `<option value="${lang}">${langNames[lang] || lang}</option>`).join('\n')
  },
  assignProb (cards) {
    const { questionDirection } = this.state
    cards.forEach(card => {
      Object.defineProperty(card, 'prob', {
        enumerable: false,
        value: questionDirection === 'reverse' ? 1 : questionDirection === 'random' ? Math.random() : 0,
        configurable: true, // å…è®¸é‡æ–°è¦†ç›–å®šä¹‰
      })
    })
    return cards
  },
  // äº‹ä»¶æ³¨å†Œ
  init () {
    const mouse = { x: 0, y: 0, time: 0 }
    div.on($deck, 'pointerdown', e => {
      mouse.x = e.clientX
      mouse.y = e.clientY
      mouse.time = new Date().valueOf()
    })
    div.on($deck, 'touchmove', e => {
      if (e.touches.length === 1) {
        const dx = e.touches[0].clientX - mouse.x
        const dy = e.touches[0].clientY - mouse.y
        if (Math.abs(dx) < Math.abs(dy)) return // å…è®¸çºµå‘æ»šåŠ¨
      }
      e.preventDefault() // ç¦ç”¨æ¨ªå‘æ»šåŠ¨
    }, { passive: false })
    div.on($deck, 'pointerup', e => {
      const dx = e.clientX - mouse.x
      const dy = e.clientY - mouse.y
      const dt = new Date().valueOf() - mouse.time
      const absdx = Math.abs(dx)
      const absdy = Math.abs(dy)
      if (absdx < 10 && absdy < 10 && ['card-front', 'card-back', 'card-front-content', 'card-back-content'].some(v => e.target.classList.contains(v))) { // click
        const $card = e.target.parentNode
        this.flipCard($card)
      } else if (dt < 500 && dx > 50 && absdx > absdy) { // swipe right
        this.prevCard()
      } else if (dt < 500 && dx < -50 && absdx > absdy) { // swipe left
        this.nextCard()
      }
    })
    $linkPrev.onclick = () => this.prevCard()
    $linkNext.onclick = () => this.nextCard()
    div.on(document, 'keydown', (e) => {
      // å¼¹çª—æ—¶, ç¦ç”¨ä¸»ç•Œé¢çš„é”®ç›˜äº¤äº’
      if (this.state.modal && this.state.modal.style.display !== 'none') return

      if (e.key === 'ArrowLeft') {
        this.prevCard()
      } else if (e.key === 'ArrowRight') {
        this.nextCard()
      } else if (e.key === 'ArrowUp') {
        this.flipCard()
      } else if (e.key === 'Enter') {
        if (this.state.stat) return this.showStat() // å·²ç»è¿›å…¥ç»“ç®—ç¯èŠ‚ä¸å…è®¸æäº¤
        if (this.state.index < this.state.progress) return // åšè¿‡çš„é¢˜ä¸å…è®¸é‡å¤æäº¤
        const $input = $($deck, '.is-active:not(.is-back) .card-input')
        if (!$input) return
        if (!$input.value) return $deckTips.textContent = 'è¯·è¾“å…¥ç­”æ¡ˆ'
        this.checkAnswer($input.value)
      } else if ('1234'.includes(e.key)) {
        if (this.state.stat) return this.showStat() // å·²ç»è¿›å…¥ç»“ç®—ç¯èŠ‚ä¸å…è®¸æäº¤
        if (this.state.index < this.state.progress) return // åšè¿‡çš„é¢˜ä¸å…è®¸é‡å¤æäº¤
        const $choices = $($deck, '.is-active:not(.is-back) .card-choice')
        if ($choices) {
          const $choice = $choices.children[Number(e.key) - 1]
          if ($choice) {
            this.selectChoice($choices, $choice)
          }
        }
      }
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          this.resume()
        } else if (document.visibilityState === 'hidden') {
          this.pause()
        }
      })
      window.onblur = () => this.pause()
      window.onfocus = () => this.resume()
    })
  },
  getCardClass (index, el) {
    const { state } = this
    return div.clsx('card', {
      'is-left': index < state.index,
      'is-active': index === state.index,
      'is-right': index > state.index,
      'is-new': el ? el.classList.contains('is-new') : state.cards[index]?.isNew,
    })
  },
  render () {
    const { state } = this
    const len = $deck.children.length
    if (len <= state.progress) {
      Utils.shuffle(state.cards, len) // æ‰“ä¹±æœªå‡ºç°çš„å¡ç‰‡
      const frag = div()
      frag.innerHTML = state.cards.slice(len).map((card, index) => {
        return `
        <div class="${this.getCardClass(len === 0 ? index : len + index + 1)}">
          <div class="card-front g-full g-center">
            <div class="card-front-content g-column">
            <span class="card-front-title">
              <button class="${div.clsx('card-tts', {
                'g-none': !state.tts
              })}">ğŸ”Š</button> ${Utils.linebreak(card.getFront())}
            </span>
            ${state.questionType === 'choice' ?  this.renderChoiceQuestion(card) : this.renderFillQuestion(card)}
            </div>
          </div>
          <div class="card-back g-full g-center">
            <div class="card-back-content g-column">${Utils.linebreak(card.getBack())}</div>
          </div>
        </div>
        `
      }).join('\n')
      $.all(frag, '.card-choice').forEach($choices => {
        $choices.childNodes.forEach(v => {
          v.onclick = () => {
            this.selectChoice($choices, v)
          }
        })
      })
      let busy = false
      $.all(frag, '.card-tts').forEach((v, i) => {
        v.onclick = () => {
          if (busy) return
          busy = setTimeout(() => busy = false, 1000)
          const { tts, cards } = state
          tts.text = cards.slice(len)[i].getFront()
          window.speechSynthesis.speak(tts)
        }
      })
      div.append($deck, [...frag.children])
    }

    // ç‰Œé¢ä¿¡æ¯
    $deckName.textContent = Deck.dataset[state.cards[state.index].deck].name
    $deckTips.textContent = ''
    $deckProgress.textContent = `${state.index + 1} / ${state.cards.length}`

    // å·¦å³æŒ‰é’®
    div.attr($linkPrev, 'disabled', state.index === 0)
    div.attr($linkNext, 'disabled', state.index >= state.progress)

    // è¿‡æ¸¡åŠ¨ç”»
    $deck.childNodes.forEach(($card, index) => {
      $card.className = this.getCardClass(index, $card)
    })

    // ç„¦ç‚¹
    if (!state.stat) this.focus()
  },
  focus (delay = 50) {
    setTimeout(() => {
      const $card = $deck.children[this.state.progress]
      if ($card?.classList?.contains('is-active')) {
        $($card, '.card-input')?.focus()
      }
    }, delay)
  },
  // é€‰æ‹©é¢˜
  renderChoiceQuestion (card) {
    const cards = this.state.deck.cards.filter(v => v.deck === card.deck)
    const choices = Utils.choices(cards.length, 4, [cards.indexOf(card)])
    return `
    <div class="card-choice">
      ${choices.map(v => `
        <button class="card-choice-item" data-value="${cards[v].getBack(card.prob).replace(/"/g, '&quot;')}">
          ${Utils.linebreak(cards[v].getBack(card.prob))}
        </button>
      `).join('\n')}
    </div>
    `
  },
  // å¡«ç©ºé¢˜
  renderFillQuestion (card) {
    return '<input class="card-input" />'
  },
  selectChoice ($choices, $choice) {
    if (this.state.stat) return this.showStat() // å·²ç»è¿›å…¥ç»“ç®—ç¯èŠ‚ä¸å…è®¸æäº¤
    if (this.state.index < this.state.progress) return // åšè¿‡çš„é¢˜ä¸å…è®¸é‡å¤æäº¤
    $choices.childNodes.forEach(v => v.className = div.clsx('card-choice-item', {
      'is-active': $choice === v,
    }))
    this.checkAnswer($choice.getAttribute('data-value').replace(/&quot;/g, '"'))
  },
  prevCard () {
    this.state.index = Math.max(0, this.state.index - 1)
    this.render()
  },
  nextCard (skip) {
    const { state } = this
    if (!skip && state.index >= state.progress) return
    state.index = Math.min(state.cards.length - 1, state.index + 1)
    // æ–°é¢˜ç›®
    if (state.index > state.progress) {
      state.progress = state.index
      state.startTime = new Date().valueOf()
    }
    this.render()
  },
  flipCard () {
    const $card = $($deck, '.card.is-active')
    if ($card) $card.classList.toggle('is-back')
    if (state.index === state.progress) {
      state.peeked = true
    }
  },
  checkAnswer (value) {
    const { cards, deck, index, startTime } = this.state
    const card = cards[index]
    const time = new Date().valueOf() - startTime
    this.state.totalTime += time
    if (value === card.getBack()) {
      const avgTime = this.state.totalTime / (index + 1)
      const rate = time / avgTime
      const score = rate <= 1 ? ScoreEnum.perfect
        : rate <= 1.5 ? ScoreEnum.great
        : rate <= 2 ? ScoreEnum.good
        : ScoreEnum.bad
      card.learn(score, time)
      if (this.state.peeked) {
        state.peeked = false
        console.log('å·çœ‹ç½šä¸€é¢˜')
        cards.push(card)
        this.render()
      } else if (score === ScoreEnum.bad) {
        console.log('è¶…æ—¶ç½šä¸€é¢˜')
        cards.push(card)
        this.render()
      }
      if (index === cards.length - 1) {
        this.finish()
      } else {
        this.nextCard(true)
      }
    } else {
      card.learn(ScoreEnum.bad, time)
      this.state.errCount += 1
      console.log('ç­”é”™ç½šä¸€é¢˜')
      cards.push(card)
      this.render()
      $deckTips.textContent = 'è¯·é‡è¯•'
    }
  },
  pause () {
    if (this.state.stat || this.state.pauseTime) return
    console.log('pause...')
    this.state.pauseTime = new Date().valueOf()
  },
  resume () {
    if (this.state.stat || !this.state.pauseTime) return
    console.log('resume...')
    this.state.startTime += new Date().valueOf() - this.state.pauseTime
    this.state.pauseTime = 0
  },
  finish () {
    const { deck, cards } = this.state
    deck.save()
    Globals.now += 1
    const ranking = deck.stat().filter(v => !v.isNew)
      // æ³¨æ„: è¿™é‡Œçš„ç”¨æ—¶æ˜¯ card.history ä¸­çš„å¹³å‡ç”¨æ—¶, è€Œä¸æ˜¯æœ¬æ¬¡ç»ƒä¹ çš„å¹³å‡ç”¨æ—¶
      .sort((a, b) => Utils.round(b.mastery, 2) - Utils.round(a.mastery, 2) || Utils.round(a.avgTime, 2) - Utils.round(b.avgTime, 2))
    this.state.stat = {
      best: ranking.slice(0, 3),
      worst: ranking.slice(-3),
      totalTime: this.state.totalTime / 1000, // second
      avgSpeed: cards.length / this.state.totalTime * 1000 * 60, // per minute
      totalCount: cards.length,
      errCount: this.state.errCount,
    }
    this.showStat()
  },
  // ç»ƒä¹ ç»“ç®—å¼¹çª—
  showStat () {
    const { stat } = this.state
    console.log(stat)
    if (!stat.totalCount) return
    const modal = this.state.modal = Modal({
      innerHTML: div.html`<h3>ç»ƒä¹ å®Œæˆ</h3>
      <p>æ­£ç¡®: ${stat.totalCount - stat.errCount}/${stat.totalCount}</p>
      <p>ç”¨æ—¶: ${stat.totalTime.toFixed(1)} ç§’</p>
      <p>é€Ÿåº¦: ${stat.avgSpeed.toFixed(2)} é¢˜/åˆ†</p>`
    })
    const container = $(modal, '.va-modal-body')
    Table({
      container,
      columns: [
        { label: 'é¢˜ç›®', key: 'front', render: v => () => div.html`<td class="g-ellipsis" style="max-width:200px" title="${v}">${v}</td>` },
        { label: 'ç†Ÿç»ƒåº¦', key: 'mastery', render: v => typeof v === 'string' ? v : Math.round(v * 100) },
        { label: 'å†å²å¹³å‡ç”¨æ—¶ (ç§’)', key: 'avgTime', render: v => typeof v === 'string' ? v : v.toFixed(2) },
      ],
      data: [...stat.best, { front: 'â€¦', mastery: 'â€¦', avgTime: 'â€¦' }, ...stat.worst],
      style: {
        margin: '0 auto 8px auto',
      },
    })
    const btnGroup = div({
      container,
      className: 'btn-group',
    })
    Button({
      container: btnGroup,
      innerHTML: 'è¿”å›',
      onClick: () => modal.setShow(false),
    })
    Button({
      container: btnGroup,
      type: 'primary',
      innerHTML: 'å®Œæˆ',
      onClick: () => this.reload(this.state.deck.key)
    })
  },
  // æ˜¾ç¤ºå¡ç»„åˆ—è¡¨
  showDeckList ({ container }) {
    const decks = Object.keys(Deck.dataset).map(key => new Deck({ key }))
    container.innerHTML = `<h3>é€‰æ‹©å¡ç»„</h3>
      <div class="deck-list">
      ${decks.map((deck, index) => {
        const progress = `${deck.cards.filter(v => !v.isNew).length}/${deck.cards.length}`
        return `<button class="deck-item" data-index="${index}">
          ${deck.name} ${progress}
        </button>`
      }).join('\n')}
      </div>
      <div class="btn-group"></div>
    `
    const deckList = div({
      selector: '.deck-list',
      on: {
        click: (e) => {
          const item = e.target
          if (item.classList.contains('deck-item')) {
            item.classList.toggle('is-active')
          }
        },
        contextmenu: (e) => {
          const item = e.target
          if (item.classList.contains('deck-item')) {
            e.preventDefault()
            const { index } = item.dataset
            const menu = Menu({
              items: [
                { label: 'å¯¼å‡º', value: 'export' },
                Number(index) >= Deck.builtinLength && { label: 'ç¼–è¾‘', value: 'edit' },
                Number(index) >= Deck.builtinLength && { label: 'åˆ é™¤', value: 'delete' },
              ].filter(Boolean),
              show: false,
              onSelect: (value) => {
                menu.setShow(false)
                if (value === 'export') {
                  this.exportDeck(decks[index])
                } else if (value === 'edit') {
                  this.addDeckForm({ container, json: JSON.stringify(decks[index], null, 2) })
                } else if (value === 'delete') {
                  if (window.confirm(`åˆ é™¤å¡ç»„ "${decks[index].name}" å—?`)) {
                    this.deleteDeck(decks[index])
                    this.showDeckList({ container })
                  }
                }
              },
            })
            Object.assign(menu.body.style, {
              left: e.clientX,
              top: e.clientY,
            })
            menu.setShow(true)
          }
        }
      }
    })
    const btnGroup = $(container, '.btn-group')
    Button({
      container: btnGroup,
      innerHTML: 'æ–°å¢...',
      onClick: () => {
        this.addDeckForm({ container })
      }
    })
    Button({
      container: btnGroup,
      innerHTML: 'å–æ¶ˆ',
      onClick: () => {
        this.reload(Globals.deck)
      }
    })
    Button({
      container: btnGroup,
      type: 'primary',
      innerHTML: 'ç¡®å®š',
      onClick () {
        const selected = [...$.all(container, '.deck-item.is-active')]
        if (selected.length) {
          const keys = selected.map(v => decks[v.dataset.index].key)
          UI.reload(keys.length === 1 ? keys[0] : keys)
        }
      }
    })

    Object.assign(container.style, {
      width: 'unset',
      height: 'unset',
    })
  },
  // æ–°å¢å¡ç»„è¡¨å•
  addDeckForm ({ container, json = '' }) {
    container.innerHTML = `<h3>${json ? 'ç¼–è¾‘å¡ç»„' : 'æ–°å¢å¡ç»„'}</h3>
      <textarea class="add-deck-input" rows="20" placeholder='ç¤ºä¾‹: {
  "key": "alphabet",
  "name": "è‹±è¯­å­—æ¯",
  "desc": "",
  "cards": [
    { "front": "A", "back": "a" },
    { "front": "B", "back": "b" },
    { "front": "C", "back": "c" }
  ]
}'></textarea>
      <div class="form-tips"></div>
      <div class="btn-group"></div>
    `
    const $input = $(container, '.add-deck-input')
    if (json) $input.value = json
    const btnGroup = $(container, '.btn-group')
    const btnUpload = Button({
      container: btnGroup,
      innerHTML: 'ä¸Šä¼ ...',
      onClick: async () => {
        const file = (await Utils.upload())[0]
        const text = await Utils.readFile(file)
        console.log(text)
        const csvData = /\.csv$/.test(file.name) ? Utils.parseCsv(text)
          : /\.tsv$/.test(file.name) ? Utils.parseTsv(text)
          : undefined
        console.log(csvData)
        if (!csvData) return Toast({ innerHTML: 'ä»…æ”¯æŒ .csv ä¸ .tsv æ ¼å¼' })
        const jsonData = Utils.parseJson($input.value.trim())
        const name = file.name.replace(/\.(c|t)sv$/, '')
        Object.assign(jsonData, {
          key: Utils.b64encode(name),
          name,
          desc: '',
          ...jsonData,
          cards: csvData.map(([front, back]) => ({ front, back }))
        })
        $input.value = JSON.stringify(jsonData, null, 2)
      },
    })
    btnUpload.title = 'ä»…æ”¯æŒ .csv ä¸ .tsv æ ¼å¼'
    Button({
      container: btnGroup,
      innerHTML: 'å–æ¶ˆ',
      onClick: () => this.showDeckList({ container })
    })
    Button({
      container: btnGroup,
      type: 'primary',
      innerHTML: 'ç¡®å®š',
      onClick: () => {
        const $input = $(container, '.add-deck-input')
        const $tips = $(container, '.form-tips')
        const data = Utils.parseJson($input.value.trim())
        if (data.key && !Globals.decks.includes(data.key)) {
          $tips.innerHTML = ''
          this.importDeck(data)
          this.showDeckList({ container })
        } else {
          $tips.innerHTML = 'è¯·æ£€æŸ¥æ•°æ®æ ¼å¼'
        }
      }
    })
  },
  exportDeck (deck) {
    const str = JSON.stringify(deck, null, 2)
    const blob = new Blob([str], { type: 'text/plain;charset=utf-8' })
    Utils.download({ blob, filename: `${Globals.key}.deck.${deck.key}.json` })
  },
  importDeck (data) {
    localStorage.setItem(`${Globals.key}.deck.${data.key}`, JSON.stringify(data))
    if (!Globals.decks.includes(data.key)) Globals.decks.push(data.key)
    Utils.saveGlobals()
    Utils.loadGlobals()
  },
  deleteDeck (deck) {
    delete Deck.dataset[deck.key]
    Globals.decks = Globals.decks.filter(v => v !== deck.key)
    Globals.deck = Globals.decks[0]
    localStorage.removeItem(`${Globals.key}.deck.${deck.key}`)
    Utils.saveGlobals()
  },
}

UI.init()
Utils.loadGlobals()
UI.reload(Globals.deck)

window.UI = UI
window.div = div
</script>
</body>
