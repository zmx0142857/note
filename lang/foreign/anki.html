<link rel="stylesheet" href="../../css/vanilla-ui.css">
<style>
:root {
  --anki-green: #97e2bd;
}
@media (prefers-color-scheme: dark) {
  :root {
    --anki-green: #448866;
  }
}
.main {
  position: absolute;
  height: 400px;
  gap: 20px;
}
.deck {
  position: relative;
  width: 300px;
  height: 400px;
  perspective: 1000px;
}
.card {
  --is-back: 0;
  position: absolute;
  width: 300px;
  height: 400px;
  border-radius: var(--va-md);
  overflow: hidden;
  background-color: var(--va-bg2);
  transition: transform .3s, opacity .3s;
  transform: rotateY(calc(var(--is-back) * 180deg));
  text-align: center;
  font-size: 28px;
}
.card.is-back {
  --is-back: 1;
}
.card-front, .card-back {
  display: flex;
  flex-direction: column;
  padding: 60px 16px 40px 16px;
  overflow-y: auto;
}
.card-front-content, .card-back-content {
  max-height: 100%; /* 防止 g-center 居中内容溢出不可见 */
  gap: 40px;
  align-items: center;
}
.card-front-content::after, .card-back-content::after {
  content: '';
  display: block;
  width: 100%;
  height: 1px; /* 产生 40px 的底部 gap */
  flex-shrink: 0;
}
.card-back {
  display: none;
  background-color: var(--anki-green);
  transform: scaleX(-1);
}
.card.is-back .card-back {
  display: flex;
}
.card.is-back .card-front {
  display: none;
}
.card.is-left {
  opacity: 0;
  transform: translate3d(-200px, 0, -20px) rotateY(calc(-20deg + var(--is-back) * 180deg));
  pointer-events: none;
}
.card.is-right {
  opacity: 0;
  transform: translate3d(200px, 0, -20px) rotateY(calc(20deg + var(--is-back) * 180deg));
  pointer-events: none;
}
.card-input {
  height: var(--va-xl);
  border-radius: var(--va-md);
  background-color: var(--va-bg3);
  border: none;
  padding: var(--va-md);
  color: var(--va-fg);
  font-size: 20px;
  width: 80%;
}
.card-choice-item {
  background: var(--va-bg3);
  color: var(--va-fg);
  font-size: 20px;
  border: none;
  border-radius: 999px;
  padding: var(--va-md);
  width: 100%;
  cursor: pointer;
}
.card-choice-item:hover {
  opacity: 0.8;
}
.card-choice-item + .card-choice-item {
  margin-top: 8px;
}
.card-choice-item.is-active {
  outline: 2px solid var(--va-fg);
}
.link {
  font-size: 48px;
  cursor: pointer;
  user-select: none;
  transition: text-shadow .3s, transform .3s;
  z-index: 1;
}
.link[disabled] {
  cursor: not-allowed;
  transform: none;
  opacity: 0.3;
}
.link:not([disabled]):hover {
  text-shadow: 0 0 6px var(--va-fg);
  transform: scale(1.1);
}
.deck-name {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  color: var(--va-fg2);
}
.deck-tips {
  position: absolute;
  bottom: 36px;
  left: 50%;
  transform: translateX(-50%);
  color: rgb(var(--va-c-red));
}
.form-tips {
  color: rgb(var(--va-c-red));
  font-size: 14px;
}
.deck-progress {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
}
.deck-list {
  width: 300px;
  margin-bottom: var(--va-md);
}
.deck-item {
  display: block;
  width: 100%;
  font-size: 16px;
  text-align: left;
  color: var(--va-fg);
  border: none;
  background-color: transparent;
  padding: var(--va-md);
  cursor: pointer;
  line-height: 20px;
}
.deck-item:hover {
  background: var(--va-bg3);
  border-radius: var(--va-md);
}
.deck-item.is-active::before {
  content: '✔';
  color: rgb(var(--va-c-green));
  margin-right: var(--va-md);
}
.btn-group {
  display: flex;
  justify-content: flex-end;
  gap: var(--va-md);
  margin: 8px 0;
}
.add-deck-input {
  color: var(--va-fg);
  background-color: var(--va-bg);
  border-radius: var(--va-xs);
  width: 300px;
}
</style>

<body class="g-full g-center g-overflow-hidden">

<main class="main g-center">
  <a class="link link-prev">❮</a>
  <div class="deck"></div>
  <a class="link link-next">❯</a>

  <div class="deck-name"></div>
  <div class="deck-tips"></div>
  <div class="deck-progress">0 / 0</div>
</main>

<script type="module">
import { $, div, Modal, Button, Table, Menu, Console } from '../../js/vanilla-ui.js'

// Console()

const $main = $('.main')
const $deck = $($main, '.deck')
const $linkPrev = $($main, '.link-prev')
const $linkNext = $($main, '.link-next')
const $deckProgress = $($main, '.deck-progress')
const $deckTips = $($main, '.deck-tips')
const $deckName = $($main, '.deck-name')

const Utils = {
  uid (length = 16) {
    return Math.random().toFixed(length).slice(2)
  },
  between (x, min, max) {
    if (x < min) return min
    if (x > max) return max
    return x
  },
  round (x, digits) {
    const pow = Math.pow(10, digits)
    return Math.round(x * pow) / pow
  },
  parseJson (str, defaultValue = {}, options) {
    if (!str) return defaultValue
    try {
      return JSON.parse(str, options) ?? defaultValue
    } catch (e) {
      return defaultValue
    }
  },
  // 在左闭右开区间 [lo, hi) 中查找第一个使 fn(i) 成立的 i
  bsearch (lo, hi, fn) {
    --lo
    while (hi - lo > 1) {
      const mid = lo + ((hi - lo) >> 1)
      if (fn(mid)) hi = mid
      else lo = mid
    }
    return hi
  },
  shuffle(arr) {
    const n = arr.length
    for (let i = 0; i < n; ++i) {
      const j = (i + (n - i) * Math.random()) | 0 // random of [i, n)
      const tmp = arr[i]
      arr[i] = arr[j]
      arr[j] = tmp
    }
    return arr
  },
  /**
   * 从 0 ~ n-1 中随机抽取 k 个不重复的数字,
   * 要求含有 include 中的数字, 但不含 exclude 中的数字
   * @param {Number} n
   * @param {Number} k
   * @param {Array} include
   * @param {Array} exclude
   */
  choices (n, k = 1, include = [], exclude = []) {
    const ret = include.slice()
    const len = n
    n -= include.length + exclude.length
    k -= include.length
    for (let i = 0; i < len; ++i) {
      if (exclude.indexOf(i) > -1 || include.indexOf(i) > -1) continue
      if (Math.random() < k/n) {
        ret.push(i)
        if (--k === 0) break
      }
      --n
    }
    return Utils.shuffle(ret)
  },
  saveGlobals () {
    localStorage.setItem(`${Globals.key}.globals`, JSON.stringify(Globals))
  },
  loadGlobals () {
    Object.assign(Globals, Utils.parseJson(localStorage.getItem(`${Globals.key}.globals`)))
    // load dataset from localStorage
    Globals.decks.forEach(key => {
      if (!Deck.dataset[key]) {
        const str = localStorage.getItem(`${Globals.key}.deck.${key}`)
        if (str) {
          const data = Utils.parseJson(str)
          Deck.dataset[key] = {
            name: data.name,
            cards: () => data.cards,
          }
        }
      }
    })
  },
  download ({ url, blob, filename = 'untitled' }) {
    if (typeof blob === 'string') blob = new Blob([blob])
    const a = document.createElement('a')
    a.href = url || URL.createObjectURL(blob)
    a.download = filename
    a.style.display = 'none'
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    if (!url) URL.revokeObjectURL(a.href)
  },
  upload ({ id = 'file-input', multiple = false, accept } = {}) {
    return new Promise(resolve => {
      const input = document.getElementById(id) || document.createElement('input')
      input.type = 'file'
      input.id = id
      input.style.display = 'none'
      input.multiple = multiple
      input.accept = accept
      input.onclick = () => input.value = null // 清空选中的文件
      input.onchange = () => resolve(input.files)
      document.body.appendChild(input)
      input.click()
    })
  },
  async readFile (blob, { type = 'string' } = {}) {
    if (!blob) return
    return new Promise((resolve, reject) => {
      const reader = new window.FileReader()
      reader.onload = () => resolve(reader.result)
      reader.onerror = reject
      if (type === 'string') return reader.readAsText(blob)
      if (type === 'base64') return reader.readAsDataURL(blob)
      if (type === 'bytes') return reader.readAsArrayBuffer(blob)
      reject('unknown type: ' + type)
    })
  },
  // 含有逗号或换行的字段需要用双引号包裹
  // 双引号需要转义为两个双引号
  parseCsv (text = '') {
    text = [...text.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n')]
    const rows = [], row = [], buf = []
    let inQuote = false
    const flush = (flag) => {
      row.push(buf.join(''))
      buf.length = 0
      if (flag) {
        rows.push(row.slice())
        row.length = 0
      }
    }
    for (let i = 0; i < text.length; ++i) {
      const ch = text[i]
      if (ch === '"') {
        if (text[i+1] !== ch) {
          inQuote = !inQuote
        } else if (inQuote) {
          buf.push(ch)
          ++i
        } else {
          inQuote = true
        }
      } else if (ch === ',') {
        inQuote ? buf.push(ch) : flush()
      } else if (ch === '\n') {
        inQuote ? buf.push(ch) : flush(true)
      } else {
        buf.push(ch)
      }
    }
    flush(true)
    return rows
  },
  b64encode (str) {
    return btoa(String.fromCharCode(...new TextEncoder().encode(str)))
  },
  trim (str) {
    return str.trim().replace(/\n/g, '<br/>')
  },
}

const ScoreEnum = {
  bad: 0,
  good: 1,
  great: 2,
  perfect: 3,
}

const Globals = {
  now: 0, // 当前时间
  maxHistory: 15, // 最大历史记录数
  key: 'anki', // 本地存储的键名
  deck: 'shuangpin', // 默认牌组
  decks: [],
}

class Card {
  /**
   * 记忆卡片
   * @param {object} props
   * @param {boolean} props.enable 是否启用
   * @param {string} props.front 正面内容
   * @param {string} props.back 背面内容
   * @param {string} props.hint 提示
   * @param {string[]} props.tags 标签
   * @param {object[]} props.history 得分历史记录
   * @param {number} props.due 下次复习时间
   * @param {number} props.interval 间隔时间
   * @param {number} props.ease 简易度系数, 数值越大越简单
   * @param {number} props.mastery 掌握程度
   * @param {number} props.weight 权重
   */
  constructor (props) {
    Object.assign(this, {
      enable: true,
      front: '',
      back: '',
      hint: '',
      tags: [],
      history: [],
      // 学习参数
      due: 0,
      interval: 50,
      ease: 2.5,
      mastery: 0,
      weight: 0,
      ...props,
    })
  }
  get isNew () {
    return !this.history.length
  }
  // 更新学习参数 (SM-2 算法)
  learn (score, time) {
    this.history.push({ score, time })
    if (this.history.length > Globals.maxHistory) this.history.shift()
    const x = ScoreEnum.perfect - score
    const offset = 0.1 * (1 - x * (0.8 + 0.2 * x))
    this.ease = Utils.between(this.ease + offset, 1.3, 2.5)
    this.interval = Utils.between(Math.round(this.interval * this.ease), 0, 500)
    this.due = Globals.now + this.interval
  }
  // 更新权重 [0, 1]
  updateWeight () {
    if (!this.enable) return this.weight = 0 // 被禁用的卡片权重为 0
    if (this.isNew) return this.weight = 1 // 新卡片的权重最大
    const since = Globals.now - (this.due - this.interval) // 距离上次复习的时间
    const timeFactor = Math.exp(-since / (this.interval + 1))
    const accuracyFactor = this.history.reduce((a, b) => a + Boolean(b.score), 0) / this.history.length || 0
    const easeFactor = Math.min(this.ease / 2.5, 1.5)
    this.mastery = 0.5 * timeFactor + 0.3 * accuracyFactor + 0.2 * easeFactor // 熟练度 [0, 1]
    const urgency = Math.exp(-Math.max(this.due - Globals.now, 0)) // 紧急程度
    this.weight = Utils.between(0.5 * (1 + urgency - this.mastery), 0.02, 1)
    if (Number.isNaN(this.weight)) console.warn('weight is NaN', this)
    return this.weight
  }
  getFront (prob) {
    return (prob ?? this.prob) > 0.5 ? this.back : this.front
  }
  getBack (prob) {
    return (prob ?? this.prob) > 0.5 ? this.front : this.back
  }
}

class Deck {
  constructor ({ key = 'default', name = '默认牌组', desc = '' } = {}) {
    this.key = key
    this.name = name
    this.desc = desc
    this.cards = []
    this.load()
  }
  filter (match) {
    return this.cards.filter(card => {
      const ok = !match || match(card)
      if (ok) card.updateWeight()
      return ok && card.weight > 0
    })
  }
  // 取出 count 张卡片, 按权重从大到小排序. 默认取出所有卡片
  deal (count, match) {
    return this.filter(match).sort((a, b) => b.weight - a.weight).slice(0, count)
  }
  // 随机抽 count 张卡片, 默认抽 1 张
  draw (count = 1, match) {
    const arr = this.filter(match)
    // 计算概率分布
    const cumsum = []
    let sum = 0
    arr.forEach(card => {
      sum += card.weight
      cumsum.push(sum)
    })
    const res = []
    for (let i = 0; i < count; ++i) {
      const r = Math.random() * sum
      let j = Utils.bsearch(0, cumsum.length, j => cumsum[j] >= r)
      j = Math.min(j, arr.length-1)
      res.push(arr[j])
    }
    return res
  }
  save () {
    Utils.saveGlobals()
    if (Array.isArray(this.key)) {
      this.key.forEach(key => {
        const storeKey = `${Globals.key}.deck.${key}`
        const data = this.loadOne(key, false)
        data.cards = this.cards.filter(v => v.deck === key)
        localStorage.setItem(storeKey, JSON.stringify(data))
      })
    } else {
      localStorage.setItem(`${Globals.key}.deck.${this.key}`, JSON.stringify(this))
    }
  }
  load () {
    Utils.loadGlobals()
    if (Array.isArray(this.key)) {
      const dataList = this.key.map(key => this.loadOne(key))
      this.name = '复合卡组'
      this.desc = dataList.map(v => v.name).join(', ')
      this.cards = dataList.flatMap(v => v.cards)
    } else {
      Object.assign(this, this.loadOne(this.key))
    }
    return this
  }
  loadOne (key, needsCards = true) {
    const data = Utils.parseJson(localStorage.getItem(`${Globals.key}.deck.${key}`))
    if (!data.cards?.length) {
      const { name, desc, cards } = Deck.dataset[key] || {}
      data.name = name || ''
      data.desc = desc || ''
      if (cards) data.cards = Utils.shuffle(cards())
    }
    if (data.cards?.length) {
      data.cards = data.cards.map(v => {
        const card = new Card(v)
        Object.defineProperty(card, 'deck', {
          enumerable: false, // 跳过 JSON 序列化
          value: key,
        })
        return card
      })
    }
    return data
  }
  stat () {
    return this.cards.map(card => {
      card.updateWeight()
      const avgTime = card.history.reduce((a, b) => a + b.time, 0) / (card.history.length * 1000) || 0
      return {
        front: card.front,
        mastery: card.mastery,
        weight: card.weight,
        avgTime,
        isNew: card.isNew,
      }
    })
  }
}

const KanaData = [
  ['a', 'あ', 'ア'], ['i', 'い', 'イ'], ['u', 'う', 'ウ'], ['e', 'え', 'エ'], ['o', 'お', 'オ'],
  ['ka', 'か', 'カ'], ['ki', 'き', 'キ'], ['ku', 'く', 'ク'], ['ke', 'け', 'ケ'], ['ko', 'こ', 'コ'],
  ['sa', 'さ', 'サ'], ['shi', 'し', 'シ'], ['su', 'す', 'ス'], ['se', 'せ', 'セ'], ['so', 'そ', 'ソ'],
  ['ta', 'た', 'タ'], ['chi', 'ち', 'チ'], ['tsu', 'つ', 'ツ'], ['te', 'て', 'テ'], ['to', 'と', 'ト'],
  ['na', 'な', 'ナ'], ['ni', 'に', 'ニ'], ['nu', 'ぬ', 'ヌ'], ['ne', 'ね', 'ネ'], ['no', 'の', 'ノ'],
  ['ha', 'は', 'ハ'], ['hi', 'ひ', 'ヒ'], ['fu', 'ふ', 'フ'], ['he', 'へ', 'ヘ'], ['ho', 'ほ', 'ホ'],
  ['ma', 'ま', 'マ'], ['mi', 'み', 'ミ'], ['mu', 'む', 'ム'], ['me', 'め', 'メ'], ['mo', 'も', 'モ'],
  ['ya', 'や', 'ヤ'], ['yu', 'ゆ', 'ユ'], ['yo', 'よ', 'ヨ'],
  ['ra', 'ら', 'ラ'], ['ri', 'り', 'リ'], ['ru', 'る', 'ル'], ['re', 'れ', 'レ'], ['ro', 'ろ', 'ロ'],
  ['wa', 'わ', 'ワ'], ['wo', 'を', 'ヲ'], ['n', 'ん', 'ン'],
  ['ga', 'が', 'ガ'], ['gi', 'ぎ', 'ギ'], ['gu', 'ぐ', 'グ'], ['ge', 'げ', 'ゲ'], ['go', 'ご', 'ゴ'],
  ['za', 'ざ', 'ザ'], ['ji', 'じ', 'ジ'], ['zu', 'ず', 'ズ'], ['ze', 'ぜ', 'ゼ'], ['zo', 'ぞ', 'ゾ'],
  ['da', 'だ', 'ダ'], //['di','ぢ','ヂ'], //['du','づ','ヅ'],
  ['de', 'で', 'デ'], ['do', 'ど', 'ド'],
  ['ba', 'ば', 'バ'], ['bi', 'び', 'ビ'], ['bu', 'ぶ', 'ブ'], ['be', 'べ', 'ベ'], ['bo', 'ぼ', 'ボ'],
  ['pa', 'ぱ', 'パ'], ['pi', 'ぴ', 'ピ'], ['pu', 'ぷ', 'プ'], ['pe', 'ぺ', 'ペ'], ['po', 'ぽ', 'ポ'],
  ['kya', 'きゃ', 'キャ'], ['kyu', 'きゅ', 'キュ'], ['kyo', 'きょ', 'キョ'],
  ['sha', 'しゃ', 'シャ'], ['shu', 'しゅ', 'シュ'], ['sho', 'しょ', 'ショ'],
  ['cha', 'ちゃ', 'チャ'], ['chu', 'ちゅ', 'チュ'], ['cho', 'ちょ', 'チョ'],
  ['nya', 'にゃ', 'ニャ'], ['nyu', 'にゅ', 'ニュ'], ['nyo', 'にょ', 'ニョ'],
  ['hya', 'ひゃ', 'ヒャ'], ['hyu', 'ひゅ', 'ヒュ'], ['hyo', 'ひょ', 'ヒョ'],
  ['mya', 'みゃ', 'ミャ'], ['myu', 'みゅ', 'ミュ'], ['myo', 'みょ', 'ミョ'],
  ['rya', 'りゃ', 'リャ'], ['ryu', 'りゅ', 'リュ'], ['ryo', 'りょ', 'リョ'],
  ['gya', 'ぎゃ', 'ギャ'], ['gyu', 'ぎゅ', 'ギュ'], ['gyo', 'ぎょ', 'ギョ'],
  ['ja', 'じゃ', 'ジャ'], ['ju', 'じゅ', 'ジュ'], ['jo', 'じょ', 'ジョ'],
  ['bya', 'びゃ', 'ビャ'], ['byu', 'びゅ', 'ビュ'], ['byo', 'びょ', 'ビョ'],
  ['pya', 'ぴゃ', 'ピャ'], ['pyu', 'ぴゅ', 'ピュ'], ['pyo', 'ぴょ', 'ピョ'],
]

const ShuangpinData = [
  ['iu', 'q'], ['ia', 'w'], ['ua', 'w'], ['e', 'e'], ['uan', 'r'], ['er', 'r'], ['üe', 't'],
  ['uai', 'y'], ['ü', 'y'], ['sh', 'u'], ['ch', 'i'], ['o', 'o'], ['uo', 'o'], ['un', 'p'],
  ['a', 'a'], ['ong', 's'], ['iong', 's'], ['iang', 'd'], ['uang', 'd'], ['en', 'f'], ['eng', 'g'],
  ['ang', 'h'], ['an', 'j'], ['ao', 'k'], ['ai', 'l'], ['ing', ';'],
  ['ei', 'z'], ['ie', 'x'], ['iao', 'c'], ['ui', 'v'], ['zh', 'v'], ['ou', 'b'], ['in', 'n'], ['ian', 'm'],
]

Deck.dataset = {
  arithmetic: {
    name: '两位数乘一位数',
    cards: () => [...Array(8).keys()].flatMap(i =>
      [...Array(8).keys()].map(j => ({
        front: `${i + 12} × ${j + 2}`,
        back: `${(i + 12) * (j + 2)}`,
      }))
    ),
  },
  shuangpin: {
    name: '双拼',
    cards: () => ShuangpinData.map(v => ({ front: v[0], back: v[1] })),
  },
  hirakana: {
    name: '平假名',
    cards: () => KanaData.slice(0, 69).map(v => ({ front: v[1], back: v[0] })),
  },
  katakana: {
    name: '片假名',
    cards: () => KanaData.slice(0, 69).map(v => ({ front: v[2], back: v[0] })),
  },
  'hirakana-youon': {
    name: '平假名拗音',
    cards: () => KanaData.slice(69).map(v => ({ front: v[1], back: v[0] })),
  },
  'katakana-youon': {
    name: '片假名拗音',
    cards: () => KanaData.slice(69).map(v => ({ front: v[2], back: v[0] })),
  },
}
Deck.builtinLength = Object.keys(Deck.dataset).length
Globals.decks = Object.keys(Deck.dataset)
Globals.deck = Globals.decks[0]

const UI = {
  state: {},
  reload (key) {
    Globals.deck = key
    const deck = new Deck({ key })
    Object.assign(this.state, {
      index: 0,
      progress: 0,
      deck,
      cards: deck.deal(20),
      startTime: 0,
      pauseTime: 0,
      totalTime: 0,
      stat: {},
      errCount: 0,
      questionType: 'choice',
      questionDirection: 'forward',
    })
    $deck.innerHTML = ''
    this.render()

    const modal = this.state.modal = Modal({
      closable: false,
      style: {
        width: '280px',
      },
      innerHTML: `<h3>${deck.name}</h3>
      <p>${deck.desc}</p>
      <p>进度: ${deck.cards.filter(v => !v.isNew).length}/${deck.cards.length}</p>
      <form class="welcome-form">
        <p>题型:
          <label><input type="radio" name="questionType" value="choice" checked>选择</label>
          <label><input type="radio" name="questionType" value="fill">填空</label>
        </p>
        <p>方向:
          <label><input type="radio" name="questionDirection" value="forward" checked>正向</label>
          <label><input type="radio" name="questionDirection" value="reverse">反向</label>
          <label><input type="radio" name="questionDirection" value="random">随机</label>
        </p>
      </form>
      <div class="btn-group"></div>
      `
    })
    const modalBody = modal.body
    const btnGroup = $(modalBody, '.btn-group')

    Button({
      container: btnGroup,
      innerHTML: '卡组...',
      onClick: () => {
        this.showDeckList({ container: modalBody })
      },
    })

    Button({
      container: btnGroup,
      innerHTML: '开始→',
      type: 'primary',
      onClick: () => {
        modal.setShow(false)
        this.state.startTime = new Date().valueOf()
        const form = $(modalBody, '.welcome-form')
        this.state.questionType = form.questionType.value
        this.state.questionDirection = form.questionDirection.value
        this.state.stat = undefined // 重置统计
        console.log(this.state)
        this.assignProb(this.state.deck.cards)
        $deck.innerHTML = ''
        Globals.deck = key
        Utils.saveGlobals()
        this.render()
        this.focus()
      }
    })
  },
  assignProb (cards) {
    const { questionDirection } = this.state
    cards.forEach(card => {
      Object.defineProperty(card, 'prob', {
        enumerable: false,
        value: questionDirection === 'reverse' ? 1 : questionDirection === 'random' ? Math.random() : 0,
        configurable: true, // 允许重新覆盖定义
      })
    })
    return cards
  },
  // 事件注册
  init () {
    const mouse = { x: 0, y: 0, time: 0 }
    div.on($deck, 'pointerdown', e => {
      mouse.x = e.clientX
      mouse.y = e.clientY
      mouse.time = new Date().valueOf()
    })
    div.on($deck, 'touchmove', e => {
      if (e.touches.length === 1) {
        const dx = e.touches[0].clientX - mouse.x
        const dy = e.touches[0].clientY - mouse.y
        if (Math.abs(dx) < Math.abs(dy)) return // 允许纵向滚动
      }
      e.preventDefault() // 禁用横向滚动
    }, { passive: false })
    div.on($deck, 'pointerup', e => {
      const dx = e.clientX - mouse.x
      const dy = e.clientY - mouse.y
      const dt = new Date().valueOf() - mouse.time
      const absdx = Math.abs(dx)
      const absdy = Math.abs(dy)
      if (absdx < 10 && absdy < 10 && ['card-front', 'card-back', 'card-front-content', 'card-back-content'].some(v => e.target.classList.contains(v))) { // click
        const $card = e.target.parentNode
        this.flipCard($card)
      } else if (dt < 500 && dx > 50 && absdx > absdy) { // swipe right
        this.prevCard()
      } else if (dt < 500 && dx < -50 && absdx > absdy) { // swipe left
        this.nextCard()
      }
    })
    $linkPrev.onclick = () => this.prevCard()
    $linkNext.onclick = () => this.nextCard()
    div.on(document, 'keydown', (e) => {
      // 弹窗时, 禁用主界面的键盘交互
      if (this.state.modal && this.state.modal.style.display !== 'none') return

      if (e.key === 'ArrowLeft') {
        this.prevCard()
      } else if (e.key === 'ArrowRight') {
        this.nextCard()
      } else if (e.key === 'ArrowUp') {
        this.flipCard()
      } else if (e.key === 'Enter') {
        if (this.state.stat) return this.showStat() // 已经进入结算环节不允许提交
        if (this.state.index < this.state.progress) return // 做过的题不允许重复提交
        const $input = $($deck, '.is-active:not(.is-back) .card-input')
        if (!$input) return
        if (!$input.value) return $deckTips.textContent = '请输入答案'
        this.checkAnswer($input.value)
      } else if ('1234'.includes(e.key)) {
        if (this.state.stat) return this.showStat() // 已经进入结算环节不允许提交
        if (this.state.index < this.state.progress) return // 做过的题不允许重复提交
        const $choices = $($deck, '.is-active:not(.is-back) .card-choice')
        if ($choices) {
          const $choice = $choices.children[Number(e.key) - 1]
          if ($choice) {
            this.selectChoice($choices, $choice)
          }
        }
      }
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          this.resume()
        } else if (document.visibilityState === 'hidden') {
          this.pause()
        }
      })
      window.onblur = () => this.pause()
      window.onfocus = () => this.resume()
    })
  },
  getCardClass (index, isBack) {
    const { state } = this
    return div.clsx('card', {
      'is-left': index < state.index,
      'is-active': index === state.index,
      'is-right': index > state.index,
      'is-back': isBack,
    })
  },
  render () {
    const { state } = this

    // 牌面信息
    $deckName.textContent = Deck.dataset[state.cards[state.index].deck].name
    $deckTips.textContent = ''
    $deckProgress.textContent = `${state.index + 1} / ${state.cards.length}`

    // 左右按钮
    div.attr($linkPrev, 'disabled', state.index === 0)
    div.attr($linkNext, 'disabled', state.index >= state.progress)

    const len = $deck.children.length
    if (len <= state.progress) {
      const frag = div()
      frag.innerHTML = state.cards.slice(len).map((card, index) => {
        return `
        <div class="${this.getCardClass(len === 0 ? index : len + index + 1)}">
          <div class="card-front g-full g-center">
            <div class="card-front-content g-column">${Utils.trim(card.getFront())}
            ${state.questionType === 'choice' ?  this.renderChoiceQuestion(card) : this.renderFillQuestion(card)}
            </div>
          </div>
          <div class="card-back g-full g-center">
            <div class="card-back-content g-column">${Utils.trim(card.getBack())}</div>
          </div>
        </div>
        `
      }).join('\n')
      $.all(frag, '.card-choice').forEach($choices => {
        $choices.childNodes.forEach(v => {
          v.onclick = () => {
            this.selectChoice($choices, v)
          }
        })
      })
      div.append($deck, [...frag.children])
    }
    // 过渡动画
    $deck.childNodes.forEach(($card, index) => {
      // const isBack = $card.classList.contains('is-back')
      $card.className = this.getCardClass(index, false)
    })

    // 焦点
    if (!state.stat) this.focus()
  },
  focus (delay = 50) {
    setTimeout(() => {
      const $card = $deck.children[this.state.progress]
      if ($card?.classList?.contains('is-active')) {
        $($card, '.card-input')?.focus()
      }
    }, delay)
  },
  // 选择题
  renderChoiceQuestion (card) {
    const cards = this.state.deck.cards.filter(v => v.deck === card.deck)
    const choices = Utils.choices(cards.length, 4, [cards.indexOf(card)])
    return `
    <div class="card-choice">
      ${choices.map(v => `
        <button class="card-choice-item" data-value="${cards[v].getBack(card.prob).replace(/"/g, '&quot;')}">
          ${Utils.trim(cards[v].getBack(card.prob))}
        </button>
      `).join('\n')}
    </div>
    `
  },
  // 填空题
  renderFillQuestion (card) {
    return '<input class="card-input" />'
  },
  selectChoice ($choices, $choice) {
    if (this.state.stat) return this.showStat() // 已经进入结算环节不允许提交
    if (this.state.index < this.state.progress) return // 做过的题不允许重复提交
    $choices.childNodes.forEach(v => v.className = div.clsx('card-choice-item', {
      'is-active': $choice === v,
    }))
    this.checkAnswer($choice.getAttribute('data-value').replace(/&quot;/g, '"'))
  },
  prevCard () {
    this.state.index = Math.max(0, this.state.index - 1)
    this.render()
  },
  nextCard (skip) {
    const { state } = this
    if (!skip && state.index >= state.progress) return
    state.index = Math.min(state.cards.length - 1, state.index + 1)
    // 新题目
    if (state.index > state.progress) {
      state.progress = state.index
      state.startTime = new Date().valueOf()
      Globals.now += 1
    }
    this.render()
  },
  flipCard () {
    const $card = $($deck, '.card.is-active')
    if ($card) $card.classList.toggle('is-back')
  },
  checkAnswer (value) {
    const { cards, deck, index, startTime } = this.state
    const card = cards[index]
    const time = new Date().valueOf() - startTime
    this.state.totalTime += time
    if (value === card.getBack()) {
      const avgTime = this.state.totalTime / (index + 1)
      const rate = time / avgTime
      const score = rate <= 1 ? ScoreEnum.perfect
        : rate <= 1.5 ? ScoreEnum.great
        : rate <= 2 ? ScoreEnum.good
        : ScoreEnum.bad
      card.learn(score, time)
      if (score === ScoreEnum.bad) {
        console.log('超时罚一题')
        cards.push(...deck.draw(1))
        this.render()
      }
      if (index === cards.length - 1) {
        this.finish()
      } else {
        this.nextCard(true)
      }
    } else {
      card.learn(ScoreEnum.bad, time)
      this.state.errCount += 1
      console.log('答错罚两题')
      cards.push(...deck.draw(2))
      this.render()
      $deckTips.textContent = '请重试'
    }
  },
  pause () {
    if (this.state.stat || this.state.pauseTime) return
    console.log('pause...')
    this.state.pauseTime = new Date().valueOf()
  },
  resume () {
    if (this.state.stat || !this.state.pauseTime) return
    console.log('resume...')
    this.state.startTime += new Date().valueOf() - this.state.pauseTime
    this.state.pauseTime = 0
  },
  finish () {
    const { deck, cards } = this.state
    deck.save()
    const ranking = deck.stat().filter(v => !v.isNew)
      // 注意: 这里的用时是 card.history 中的平均用时, 而不是本次练习的平均用时
      .sort((a, b) => Utils.round(b.mastery, 2) - Utils.round(a.mastery, 2) || Utils.round(a.avgTime, 2) - Utils.round(b.avgTime, 2))
    this.state.stat = {
      best: ranking.slice(0, 3),
      worst: ranking.slice(-3),
      totalTime: this.state.totalTime / 1000, // second
      avgSpeed: cards.length / this.state.totalTime * 1000 * 60, // per minute
      totalCount: cards.length,
      errCount: this.state.errCount,
    }
    this.showStat()
  },
  // 练习结算弹窗
  showStat () {
    const { stat } = this.state
    console.log(stat)
    if (!stat.totalCount) return
    const modal = this.state.modal = Modal({
      innerHTML: `<h3>练习完成</h3>
      <p>正确: ${stat.totalCount - stat.errCount}/${stat.totalCount}</p>
      <p>用时: ${stat.totalTime.toFixed(1)} 秒</p>
      <p>速度: ${stat.avgSpeed.toFixed(2)} 题/分</p>`
    })
    const container = $(modal, '.va-modal-body')
    Table({
      container,
      columns: [
        { label: '题目', key: 'front', render: v => v.slice(0, 10) },
        { label: '熟练度', key: 'mastery', render: v => typeof v === 'string' ? v : Math.round(v * 100) },
        { label: '历史平均用时 (秒)', key: 'avgTime', render: v => typeof v === 'string' ? v : v.toFixed(2) },
      ],
      data: [...stat.best, { front: '…', mastery: '…', avgTime: '…' }, ...stat.worst],
      style: {
        margin: '0 auto 8px auto',
      },
    })
    const btnGroup = div({
      container,
      className: 'btn-group',
    })
    Button({
      container: btnGroup,
      innerHTML: '返回',
      onClick: () => modal.setShow(false),
    })
    Button({
      container: btnGroup,
      type: 'primary',
      innerHTML: '再来一组',
      onClick: () => this.reload(this.state.deck.key)
    })
  },
  // 显示卡组列表
  showDeckList ({ container }) {
    const decks = Object.keys(Deck.dataset).map(key => new Deck({ key }))
    container.innerHTML = `<h3>选择卡组</h3>
      <div class="deck-list">
      ${decks.map((deck, index) => {
        const progress = `${deck.cards.filter(v => !v.isNew).length}/${deck.cards.length}`
        return `<button class="deck-item" data-index="${index}">
          ${deck.name} ${progress}
        </button>`
      }).join('\n')}
      </div>
      <div class="btn-group"></div>
    `
    const deckList = div({
      selector: '.deck-list',
      on: {
        click: (e) => {
          const item = e.target
          if (item.classList.contains('deck-item')) {
            item.classList.toggle('is-active')
          }
        },
        contextmenu: (e) => {
          const item = e.target
          if (item.classList.contains('deck-item')) {
            e.preventDefault()
            const { index } = item.dataset
            const menu = Menu({
              items: [
                { label: '导出', value: 'export' },
                Number(index) >= Deck.builtinLength && { label: '删除', value: 'delete' },
              ].filter(Boolean),
              show: false,
              onSelect: (value) => {
                menu.setShow(false)
                if (value === 'export') {
                  this.exportDeck(decks[index])
                } else if (value === 'delete') {
                  if (window.confirm(`删除卡组 "${decks[index].name}" 吗?`)) {
                    this.deleteDeck(decks[index])
                    this.showDeckList({ container })
                  }
                }
              },
            })
            Object.assign(menu.body.style, {
              left: e.clientX,
              top: e.clientY,
            })
            menu.setShow(true)
          }
        }
      }
    })
    const btnGroup = $(container, '.btn-group')
    Button({
      container: btnGroup,
      innerHTML: '新增...',
      onClick: () => {
        this.addDeckForm({ container })
      }
    })
    Button({
      container: btnGroup,
      innerHTML: '取消',
      onClick: () => {
        this.reload(Globals.deck)
      }
    })
    Button({
      container: btnGroup,
      type: 'primary',
      innerHTML: '确定',
      onClick () {
        const selected = [...$.all(container, '.deck-item.is-active')]
        if (selected.length) {
          const keys = selected.map(v => decks[v.dataset.index].key)
          UI.reload(keys.length === 1 ? keys[0] : keys)
        }
      }
    })

    Object.assign(container.style, {
      width: 'unset',
      height: 'unset',
    })
  },
  // 新增卡组表单
  addDeckForm ({ container }) {
    container.innerHTML = `<h3>新增卡组</h3>
      <textarea class="add-deck-input" rows="20" placeholder='示例: {
  "key": "alphabet",
  "name": "英语字母",
  "desc": "",
  "cards": [
    { "front": "A", "back": "a" },
    { "front": "B", "back": "b" },
    { "front": "C", "back": "c" }
  ]
}'></textarea>
      <div class="form-tips"></div>
      <div class="btn-group"></div>
    `
    const btnGroup = $(container, '.btn-group')
    Button({
      container: btnGroup,
      innerHTML: '上传...',
      onClick: async () => {
        const file = (await Utils.upload({ accept: 'text/csv' }))[0]
        const text = await Utils.readFile(file)
        const csvData = Utils.parseCsv(text)
        console.log(text)
        console.log(csvData)
        const $input = $(container, '.add-deck-input')
        const jsonData = Utils.parseJson($input.value.trim())
        const name = file.name.replace(/\.csv$/, '')
        Object.assign(jsonData, {
          key: Utils.b64encode(name),
          name,
          desc: '',
          ...jsonData,
          cards: csvData.map(([front, back]) => ({ front, back }))
        })
        $input.value = JSON.stringify(jsonData, null, 2)
      },
    })
    Button({
      container: btnGroup,
      innerHTML: '取消',
      onClick: () => this.showDeckList({ container })
    })
    Button({
      container: btnGroup,
      type: 'primary',
      innerHTML: '确定',
      onClick: () => {
        const $input = $(container, '.add-deck-input')
        const $tips = $(container, '.form-tips')
        const data = Utils.parseJson($input.value.trim())
        if (data.key && !Globals.decks.includes(data.key)) {
          $tips.innerHTML = ''
          this.importDeck(data)
          this.showDeckList({ container })
        } else {
          $tips.innerHTML = '请检查数据格式'
        }
      }
    })
  },
  exportDeck (deck) {
    const str = JSON.stringify(deck, null, 2)
    const blob = new Blob([str], { type: 'text/plain;charset=utf-8' })
    Utils.download({ blob, filename: `${Globals.key}.deck.${deck.key}.json` })
  },
  importDeck (data) {
    localStorage.setItem(`${Globals.key}.deck.${data.key}`, JSON.stringify(data))
    Globals.decks.push(data.key)
    Utils.saveGlobals()
    Utils.loadGlobals()
  },
  deleteDeck (deck) {
    delete Deck.dataset[deck.key]
    Globals.decks = Globals.decks.filter(v => v !== deck.key)
    Globals.deck = Globals.decks[0]
    localStorage.removeItem(`${Globals.key}.deck.${deck.key}`)
    Utils.saveGlobals()
  },
}

UI.init()
Utils.loadGlobals()
UI.reload(Globals.deck)

window.UI = UI
window.div = div
</script>
</body>
